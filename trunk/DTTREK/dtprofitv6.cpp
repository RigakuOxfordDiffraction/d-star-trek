//
// Copyright (c) 1996 Molecular Structure Corporation
//
// RESTRICTED RIGHTS NOTICE SHORT FORM (JUNE 1987)
//
// Use, reproduction, or disclosure is subject to restrictions set
// forth in Contract No. W-31-109-ENG-38 and Contract No.
// 943072401 with the University of Chicago, Operator of
// Argonne National Laboratory.
//
// dtprofit.cc     Initial author: J.W. Pflugrath           4-Jan-1996
//    Read a file of reflection profiles generated by dtintegrate and
//    integrate them with a profile fitting algorithm.
/*
 *
 * Copyright (C) 2014 Rigaku Americas Corporation
 *                    9009 New Trails Drive
 *                    The Woodlands, TX, USA  77381
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *    * Redistributions of source code must retain the above copyright
 *      notice(s), this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above copyright
 *      notice(s), this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 *    * Neither the name of the Rigaku Americas Corporation nor the 
 *      names of its contributors may be used to endorse or promote products
 *      derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL RIGAKU AMERICAS CORPORATION BE LIABLE 
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA OR PROFITS; OR BUSINESS INTERUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
 * DAMAGE.
 *
*/
//+Description
//
//    Example:  % dtprofit [ options ...] profit_refln_file
//
//    Command line options:
//                -scan   sName | -image sName
//                -ref    sReflectionFileName
//                -batch  degrees
//                -help
//
//+ToDo
//
//   Error messages need implementing
//
//+Include files

#include <iostream.h>
#include <iomanip.h>
#include "Dtrek.h"
#include "Cstring.h"
#include "Cintegrate.h"
#include "C3Ddata.h"
#include "Crotation.h"
#include "Creflnlist.h"
#include "Crefln.h"

#include "dskio.h"

//+Code begin

//+Definitions, constants, and initialization of static member variables

enum eMethods
{
  eMethod_VarianceAWeighted,
  eMethod_VarianceBWeighted,
  eMethod_UnitWeighted,
  eMethod_Kabsch
};

//+Public functions

#ifdef SSI_PC
#define main   dtprofit_main
#define vError dtprofit_vError
#endif

void vError(const int nErrorNum=0, const Cstring& sError=NULL);

int nDecompress(const int nArraySizeCompressed,
		const int nArraySizeUncompressed,
		const int *pnMask, float *pfArray1, float *pfArray2);
//

int main(int   argc,      // Command line argument count
         char *argv[])    // Pointers to command line args
{
  int            i, j, k;
  int            nStat, nReadStat;
  Cstring        sReflnFile      = sDtrekGetPrefix() + "dtprofit.ref";
  Cstring        sProfitFilename = sDtrekGetPrefix() + "reflnprofiles.profit";
  Cstring        sTemp;
  Cstring        sMissingOption
                    = "ERROR: dtprofit - missing option argument!";
  Cstring        sInvalidArgument
                    = "ERROR: dtprofit - invalid argument!";

  int            nSize;
  int            nProfitFile;
  float          a3fS0[3];
  int            a3nGridProfit[3];
  float          a3fSizeProfit[3];
  tagProfitRec   tProfitRec;            // A record of the Profit file
  C3Ddata       *po3DBoxProfit;
  C3Ddata       *po3DBoxVarProfit;
  C3Ddata       *po3DRefer;
  C3Ddata      **ppo3DReference;
  C3Ddata      **ppo3DVarReference;
  C3Ddata      **ppo3DNumContrib;
  C3Ddata      **ppo3DReferenceB;
  C3Ddata      **ppo3DVarReferenceB;
  C3Ddata      **ppo3DNumContribB;
  bool          *pbUseSecondary;
  float         *pfWeightRef;
  float         *pfObs, *pfVar, *pfNumContrib, *pfRef, *pfRefVar;
  float         *pfRefOverall, *pfRefVarOverall, *pfNumContribOverall;
  float         *pfNumReflns, *pfNumReflnsB;
  float         *pfSumRef;
  float          fMax;
  float          fBadFlag;
  Cstring       *psProfilesIn;
  int            nNumReflns;
  int            nNumWritten;
  int            nNumPixels;
  int            nNumReference;
  int            nNumProfiles;
  int            nArea;
  int            m_nVerbose = 1;
  float          m_fMinInRefPeak = 0.0;
  float          m_fMinInKabschProfile = 1.0;
  float          m_nMinContribs = 50;
  float          m_fOverallRotStart;
  float          m_fOverallRotEnd;
  float          m_fRotIncrement;
  float          m_fDegreesPerBatch = 0.0f;
  float          fTemp;
  int            m_nMinRefsPerBatch = 100;
  int            m_nImagesPerBatch;
  int            nTemp;
  Cstring        m_sBatchPrefix;
  bool           m_bRebatch = TRUE;

//  eMethods       m_eMethod = eMethod_Kabsch;
  eMethods       m_eMethod = eMethod_VarianceBWeighted;
  int            nFI_fSvec[3];
  int            nFI_fS0vec[3];
  char           a255cNum[256];
  Creflnlist     oReflnlist;            // A reflection list for the results

  Creflnlist    *poZoneReflnlist;       // Reflnlist for special h00, 0k0, 00l reflns
  int            nNumZeroes;

  // The following table is used to specify neighboring areas from whence
  // profiles will be summed into a given area's profile if it does not have
  // enough contributions of its own.  Use 99 after the last used offset
  // in a row if you do not specify a complete row.  The first offset is
  // always 0, to signify use the current area first.
  // TODO: This table should be supplied by Cintegrate class, since it
  // depends on the number of areas the detector face is divided into and
  // their spatial relationship to each other.

#define MAX_OFFSETS 20
#define DA          DTINT_MAX_AREAS
  int   nOffsets[DTINT_MAX_AREAS][MAX_OFFSETS] =
    {
      // 0    1     2     3     4     5     6     7       8      9
      //   10    11   12    13    14    15    16    17      18     19
      {     0,  -DA, +DA,    1,    6, 1-DA, 6-DA, 1+DA,   6+DA,     7,
	 7-DA, 7+DA,   8, 8-DA, 8+DA,    2, 2-DA, 2+DA, -DA-DA, +DA+DA }, // 0

      {     0,  -DA,  +DA,    6,    1,   5,   -1, 6-DA,   6+DA,  1-DA,
	 1+DA, 5-DA, 5+DA,-1-DA,-1+DA,   7, 7-DA, 7+DA, -DA-DA, +DA+DA }, // 1

      {     0,  -DA,  +DA,    6,    5,  -1, 6-DA, 6+DA, -1-DA, -1+DA,
	 5-DA, 5+DA,   -2,    4,-2-DA, -2+DA, 4-DA, 4+DA,-DA-DA,+DA+DA }, // 2

      {  0,  -DA, +DA,    6,    7,    1, 6-DA, 6+DA,   1-DA,   1+DA,
	 7-DA, 7+DA,  2, 8, 2-DA,  2+DA, 8-DA, 8+DA, -DA-DA, +DA+DA },    // 3

      {  0,  -DA, +DA,    6,   -1,    7,   1,   6-DA,  6+DA,  -1+DA,
	 -1+DA, 7-DA, 7+DA, 1-DA, 1+DA, 5, 5-DA, 5+DA, -DA-DA, +DA+DA },  // 4

      {  0,  -DA, +DA,   -1,   6,  -1-DA, 6-DA, -1+DA,   6+DA,  5,
	 5-DA, 5+DA,  4, 4-DA, 4+DA, -2, -2-DA, -2+DA, -DA-DA, +DA+DA },  // 5

      {  0,  -DA, +DA,    1,  -6,     6, 1-DA,  1+DA,   6-DA,  -6-DA,
	 6+DA, -6+DA,  7, -5, 7-DA, -5-DA, 7+DA, -5+DA, -DA-DA, +DA+DA }, // 6

      {  0,  -DA, +DA,    1,  -1,  1-DA, -1-DA,  1+DA,  -1+DA,  6,
	-6, 6-DA, -6-DA, 6+DA, -6+DA, 7, -5, -DA-DA, +DA+DA,        99 }, // 7

      {  0,  -DA, +DA,   -1, 1-DA, -1+DA, -2, -2-DA, -2+DA,  5,
	-7, 5-DA, -7-DA, 5+DA, -7+DA, 6, -6, 1, -DA-DA, +DA+DA },         // 8

      {  0,  -DA, +DA,    1, 1-DA,  1+DA,  2,  2-DA,  2+DA,  -6,
	 6, -6-DA, 6-DA, -6+DA,  6+DA, -5, 7, -1, -DA-DA, +DA+DA },       // 9

      {  0,  -DA, +DA,   -1, 1,  -1-DA, 1-DA,  -1+DA,  1+DA,  -6,
	 6, -6-DA, 6-DA, -6+DA,  6+DA, -7, 5, -DA-DA, +DA+DA, 99 },       // 10

      {  0,  -DA, +DA,   -1,  6,    -6, -1-DA,  -1+DA,  -6-DA,   6-DA,
	-6+DA,  6+DA, -7,  5, -7-DA, 5-DA, -7+DA, 5+DA, -DA-DA, +DA+DA }, // 11

      {  0,  -DA, +DA,    1, -6,    1-DA,  -6-DA,  1+DA, -6+DA,  -5,
	-5-DA,  -5+DA, -4,  -4-DA, -4+DA, 2, 2-DA, 2+DA, -DA-DA, +DA+DA },// 12

      {  0,  -DA, +DA,   -6,  1,    -7, -1,  -6-DA,  -6+DA,   1-DA,
    1+DA,  -7-DA, -7+DA, -1-DA, -1+DA, -5, -5-DA, -5+DA, -DA-DA, +DA+DA },// 13

      {  0,  -DA, +DA,   -6, -7,    -1, -6-DA,  -6+DA,  -1-DA,   -1+DA,
       -7-DA, -7+DA, -2, -8, -2-DA, -2+DA, -8-DA, -8+DA, -DA-DA, +DA+DA },// 14

      {  0,  -DA, +DA,   -6, -5,    1, -6-DA,  -6+DA,  1-DA,   1+DA,
         -5-DA, -5+DA, 2, -4, 2-DA, 2+DA, -4-DA, -4+DA, -DA-DA, +DA+DA }, // 15

      {  0,  -DA, +DA,   -6, -1,   -5, 1,  -6+DA,  -6+DA,   -1-DA,
     -1+DA, -5-DA, -5+DA, 1-DA, 1+DA, -7, -7-DA, -7+DA, -DA-DA, +DA+DA }, // 16

      {  0,  -DA, +DA,   -1, -6,   -1-DA, -6-DA,  -1+DA,  -6+DA,   -7,
      -7-DA, -7+DA, -2, -2-DA, -2+DA, -8, -8-DA, -8+DA, -DA-DA, +DA+DA }, // 17

    };

  float fScaleRefer, fNumPix;
  float fRefValue;
  float fIntensity, fVariance;
  float fDelRef, fDelObs, fCorr;
  float fSumNumer, fSumDenom, fAvgRef, fAvgObs;
  float fSumRefSq, fSumObsSq;
  float fSumSignal, fSumNoSignal, fNumSumS, fNumSumNS;
  float fSumMissing, fNumSumMissing;
  float fExpectedCounts;
  float fBackgroundVar;

  cout << "\ndtprofit:  Copyright (c) 1996 Molecular Structure Corporation\n";
  cout << D_K_DTREKVersion << endl << flush;

  // Copy command line to output log

  cout << "Command line:\n " << sGetCommandLine(argc, argv, 71) << endl << flush;

  // Parse command line arguments

  argc--; argv++;

  nStat = 1;

  if (1 <= argc)
    {
      sTemp = (const char*) argv[0];
      if ( ("-help" == sTemp) || ("-h" == sTemp) )
	{
	  vError();
	}
    }
  // Parse any additional command line options

  for (i = 0; i < argc; i++)
    {
      sTemp = (const char*) argv[i];
      cout << "Command line string: >>" << sTemp << "<<" << endl << flush;

      if ("-kabsch" == sTemp)
	{
	  m_eMethod = eMethod_Kabsch;
	}
      else if ("-var" == sTemp)
	{
	  m_eMethod = eMethod_VarianceBWeighted;
	}
      else if ("-unit" == sTemp)
	{
	  m_eMethod = eMethod_UnitWeighted;
	}
      else if ("-verbose" == sTemp)
	{
	  i++;
	if (i < argc)
	  {
	    nStat = sscanf(argv[i], "%d", &nTemp);
	    if (1 == nStat)
	      m_nVerbose = nTemp;
	    else
	      vError(6, sInvalidArgument);
	  }
	else
	  {
	    vError(5, sMissingOption);
	  }
	}
      else if ("-kmin" == sTemp)
	{
	  i++;
	if (i < argc)
	  {
	    nStat = sscanf(argv[i], "%f", &fTemp);
	    if (1 == nStat)
	      m_fMinInKabschProfile = fTemp;
	    else
	      vError(6, sInvalidArgument);
	  }
	else
	  {
	    vError(5, sMissingOption);
	  }
	}
      else if ("-pmin" == sTemp)
	{
	  i++;
	if (i < argc)
	  {
	    nStat = sscanf(argv[i], "%f", &fTemp);
	    if (1 == nStat)
	      m_fMinInRefPeak = fTemp;
	    else
	      vError(6, sInvalidArgument);
	  }
	else
	  {
	    vError(5, sMissingOption);
	  }
	}
      else if ("-min" == sTemp)
	{
	  i++;
	if (i < argc)
	  {
	    int nTemp;
	    nStat = sscanf(argv[i], "%d", &nTemp);
	    if ( (1 == nStat) && (0 < nTemp) )
	      m_nMinContribs = (float)nTemp;
	    else
	      vError(6, sInvalidArgument);
	  }
	else
	  {
	    vError(5, sMissingOption);
	  }
	}
      else if ("-norebatch" == sTemp)
	{
	  m_bRebatch = FALSE;
	}
      else if ("-dbatch" == sTemp)
	{
	  i++;
	  if (i < argc)
	    {
	      nStat = sscanf(argv[i], "%f", &fTemp);
	      if ( (1 == nStat) && (0.0 < m_fDegreesPerBatch) )
		m_fDegreesPerBatch = fTemp;
	      else
		vError(6, sInvalidArgument);
	    }
	  else
	    {
	      vError(5, sMissingOption);
	    }
	}
      else if ("-refsbatch" == sTemp)
	{
	  i++;
	  if (i < argc)
	    {
	      nStat = sscanf(argv[i], "%d", &nTemp);
	      if ( (1 == nStat) && (0 < nTemp) )
		m_nMinRefsPerBatch = nTemp;
	      else
		vError(6, sInvalidArgument);
	    }
	  else
	    {
	      vError(5, sMissingOption);
	    }
	}
      else
	{
	  vError(2, "Unknown command line option");
	}
    }

  // Print out settings

  cout << "dtprofit settings:\n"
       << "\nMinimum required contributors to a reference profile: "
       << m_nMinContribs
       << "\nMinimum reference profile value in peak area: "
       << m_fMinInRefPeak
       << endl << flush;

  if (eMethod_VarianceAWeighted == m_eMethod)
    {
      cout << "Variance weighted profile analysis method A used.\n";
    }
  else if (eMethod_VarianceBWeighted == m_eMethod)
    {
      cout << "Variance weighted profile analysis method B used.\n";
    }
  else if (eMethod_Kabsch == m_eMethod)
    {
      cout << "Kabsch profile analysis method used.\n";
      cout << "\nMinimum reference profile value in Kabsch signal area: "
           << m_fMinInKabschProfile << '\n';
    }
  else if (eMethod_UnitWeighted == m_eMethod)
    {
      cout << "Unit weighted profile analysis method used.\n";
    }
  else
    {
      vError(1, "dtprofit: unknown profile fitting method!\n");
    }

#ifdef SSI_PC
  cout << flush;
#endif

  // Open the Profit file and try to do something with it

  sProfitFilename = sTransSymbol(Cstring("$(") + sProfitFilename + ")");
  nSize           = sProfitFilename.length();
  nProfitFile = 1;
//  (void) dskbor(&nProfitFile, (const char *)sProfitFilename, &nSize, &nStat);
  (void) dskbor(&nProfitFile, sProfitFilename.string(), &nSize, &nStat);
  if (0 != nStat)
    vError(1, "Could not open file of Profit profiles: " + sProfitFilename);

  // Read header info in Profit file
  //  Thought:  maybe the first record should be a tagProfitRec structure
  //            with necessary info stuffed in the fields

  nSize = 3*sizeof(float);
  (void) dskbr(&nProfitFile, (char *)a3fS0, &nSize, &nStat);
  nSize = 3*sizeof(int);
  (void) dskbr(&nProfitFile, (char *)a3nGridProfit, &nSize, &nStat);
  nSize = 3*sizeof(float);
  (void) dskbr(&nProfitFile, (char *)a3fSizeProfit, &nSize, &nStat);
  nSize = sizeof(float);
  (void) dskbr(&nProfitFile, (char *)&fBadFlag, &nSize, &nStat);
  nSize = sizeof(int);
  (void) dskbr(&nProfitFile, (char *)&nNumReference, &nSize, &nStat);

  // Read in the Profit profiles

  cout << "Maximum number of reference profiles: " << nNumReference << '\n';
  cout << "\nReading profiles file " << sProfitFilename << " until end-of-file ..." << endl << flush;

  nNumProfiles = nNumReference + 1;

  // Allocate space for the reference profiles and variances, plus 2 extra for
  // the reflection profile and its variance

  ppo3DReference    = new C3Ddata* [nNumProfiles];
  ppo3DVarReference = new C3Ddata* [nNumProfiles];
  ppo3DNumContrib   = new C3Ddata* [nNumProfiles];
  ppo3DReferenceB   = new C3Ddata* [nNumProfiles];
  ppo3DVarReferenceB= new C3Ddata* [nNumProfiles];
  ppo3DNumContribB  = new C3Ddata* [nNumProfiles];
  pfWeightRef       = new float    [nNumProfiles];
  pfSumRef          = new float    [nNumProfiles];
  pfNumReflns       = new float    [nNumProfiles];
  pfNumReflnsB      = new float    [nNumProfiles];
  pbUseSecondary    = new bool     [nNumProfiles];
  psProfilesIn      = new Cstring  [nNumProfiles];

  for (i = 0; i < nNumProfiles; i++)
    {
      ppo3DReference[i] = new C3Ddata(a3nGridProfit[0], a3nGridProfit[1],
				      a3nGridProfit[2], 0, 0, 0,
				      e3Ddata_float);
      ppo3DReference[i]->vZero();  // Zero the data array

      ppo3DVarReference[i] = new C3Ddata(a3nGridProfit[0], a3nGridProfit[1],
					 a3nGridProfit[2], 0, 0, 0,
					 e3Ddata_float);
      ppo3DVarReference[i]->vZero();  // Zero the data array

      ppo3DNumContrib[i]   = new C3Ddata(a3nGridProfit[0], a3nGridProfit[1],
					 a3nGridProfit[2], 0, 0, 0,
					 e3Ddata_float);
      ppo3DNumContrib[i]->vZero();  // Zero the data array

      // The secondary profiles ...

      ppo3DReferenceB[i] = new C3Ddata(a3nGridProfit[0], a3nGridProfit[1],
				      a3nGridProfit[2], 0, 0, 0,
				      e3Ddata_float);
      ppo3DReferenceB[i]->vZero();  // Zero the data array

      ppo3DVarReferenceB[i] = new C3Ddata(a3nGridProfit[0], a3nGridProfit[1],
					 a3nGridProfit[2], 0, 0, 0,
					 e3Ddata_float);
      ppo3DVarReferenceB[i]->vZero();  // Zero the data array

      ppo3DNumContribB[i]   = new C3Ddata(a3nGridProfit[0], a3nGridProfit[1],
					 a3nGridProfit[2], 0, 0, 0,
					 e3Ddata_float);
      ppo3DNumContribB[i]->vZero();  // Zero the data array
      pfNumReflns[i] = 0.0;
      pfNumReflnsB[i]= 0.0;
      pfWeightRef[i] = 1.0;
      pfSumRef[i]    = 0.0;
    }

  // Use these as temporary pointers

  po3DBoxProfit     = new C3Ddata(a3nGridProfit[0], a3nGridProfit[1],
				  a3nGridProfit[2], 0, 0, 0,
				  e3Ddata_float);
  po3DBoxVarProfit  = new C3Ddata(a3nGridProfit[0], a3nGridProfit[1],
				  a3nGridProfit[2], 0, 0, 0,
				  e3Ddata_float);
  for (i = 0; i < nNumProfiles; i++)
    {
      pfWeightRef[i] = 1.0;
    }

  nNumPixels = a3nGridProfit[0] * a3nGridProfit[1] * a3nGridProfit[2];
  nNumReflns = 0;
  nNumWritten= 0;
  nReadStat  = 0;
  while ( (0 == nReadStat) || (2332 == nReadStat) )
    {
      nSize = sizeof(tagProfitRec);
      (void) dskbr(&nProfitFile, (char *)&tProfitRec, &nSize, &nReadStat);
      if ( (0 == nReadStat) && (-2332.0 == tProfitRec.fObsPx0) )
	{
	  // Special flag for a trailer record

	  nReadStat = 2332;
	  m_fOverallRotStart    =  tProfitRec.fCalcPx0;
	  m_fOverallRotEnd      =  tProfitRec.fCalcPx1;
	  m_fRotIncrement       =  tProfitRec.fCalcRotMid;
	  m_nImagesPerBatch     =  tProfitRec.nProfileSize;
	  m_sBatchPrefix        =  (Cstring)tProfitRec.a8cBatch;

	  if (3 < m_nVerbose)
	    {
	      cout << "Special informational record found!\n"
		   << "Overall rot start,end, and increment: "
		   << m_fOverallRotStart << ", " << m_fOverallRotEnd << ", "
		   << m_fRotIncrement << ", >>" << m_sBatchPrefix 
		   << "<<" << endl;
	    }
	}
      else
	{
	  nSize = sizeof(float) * tProfitRec.nProfileSize;
	  if (0 == nReadStat)
	    (void) dskbr(&nProfitFile, (char *)po3DBoxProfit->m_pfData, &nSize,
			 &nReadStat);
	  if (0 == nReadStat)
	    (void) dskbr(&nProfitFile, (char *)po3DBoxVarProfit->m_pfData, &nSize,
			 &nReadStat);
	}
      if (0 == nReadStat)
	{
          nNumReflns++;

	  nDecompress(tProfitRec.nProfileSize,
		      nNumPixels,
		      tProfitRec.anProfileMask,
		      po3DBoxProfit->m_pfData,
		      po3DBoxVarProfit->m_pfData);

	  // Ok, have a shoebox, what to do with it?
	  // Check resolution, rotation range, etc and if OK, add to
	  // appropriate reference profile

          if (20.0 < tProfitRec.fWeight)
            {
	      // TODO: Get weight for each profile, sort of done already above

	      nArea = tProfitRec.nProfile;
	      if ( (0 > nArea) || (nArea >= nNumReference) )
		{
		  cerr << "WARNING, bogus area: " << nArea << endl;
		  nArea = nNumReference;
		}
	      pfNumReflns[nArea] = pfNumReflns[nArea] + 1.0f;
	      for (j = 0; j < nNumProfiles; j++)
		{
		  pfWeightRef[j] = 1.0;
		  if (j != nArea) pfWeightRef[j] = 0.0;
		}

	      for (j = 0; j < nNumReference; j++)
                {
                  if (0.0 < pfWeightRef[j])
		    {
		      pfRef        = ppo3DReference[j]->m_pfData;
		      pfRefVar     = ppo3DVarReference[j]->m_pfData;
		      pfNumContrib = ppo3DNumContrib[j]->m_pfData;
		      pfObs        = po3DBoxProfit->m_pfData;
		      pfVar        = po3DBoxVarProfit->m_pfData;
		      for (k = 0; k < nNumPixels; k++)
			{
			  if (fBadFlag != *pfObs)
			    {
			      // Not flagged as bad so add in
			      // but shouldn't this be weighted by Intensity??

			      *pfRef    = *pfRef + pfWeightRef[j] * *pfObs;
			      *pfRefVar = *pfRefVar
                                            + pfWeightRef[j] * *pfVar;
			      *pfNumContrib = *pfNumContrib + 1.0f;
			    }
			  pfObs++;
			  pfVar++;
			  pfNumContrib++;
			  pfRef++;
			  pfRefVar++;
			}
		    }
                }
            }
	}
    } // end of nReadStat

  (void) dskbcr(&nProfitFile, &nStat);

  if (0 >= nNumReflns)
    {
      // Do not bother if no reflns.  No clean-up.

      cerr << "No reflections for profiles!\n" << flush;
#ifndef SSI_PC
      exit (2);
#else
      return (2);
#endif
    }

  cout << "\nNumber of reflection profiles read in: " <<  nNumReflns << '\n' << endl << flush;

  // Sum all profiles into overall reference profile

  psProfilesIn[nNumReference] = "Overall profile";
  for (j = 0; j < nNumReference; j++)
    {
      pfRefOverall        = ppo3DReference[nNumReference]->m_pfData;
      pfRefVarOverall     = ppo3DVarReference[nNumReference]->m_pfData;
      pfNumContribOverall = ppo3DNumContrib[nNumReference]->m_pfData;

      pfRef        = ppo3DReference[j]->m_pfData;
      pfRefVar     = ppo3DVarReference[j]->m_pfData;
      pfNumContrib = ppo3DNumContrib[j]->m_pfData;
      pfObs        = po3DBoxProfit->m_pfData;
      pfVar        = po3DBoxVarProfit->m_pfData;
      for (k = 0; k < nNumPixels; k++)
	{
	  *pfRefOverall++        += *pfRef++;
	  *pfRefVarOverall++     += *pfRefVar++;
	  *pfNumContribOverall++ += *pfNumContrib++;
	}
      pfNumReflns[nNumReference] += pfNumReflns[j];
    }

  // Now go through each reference profiles and make sure it has
  // contributions from at least n=50 reflections.
  // For any that do not, include profiles from neighboring areas
  // until they do.
  // If all neighbors are included and still don't have enough profiles,
  // just use the overall profile.

  for (j = 0; j < nNumReference; j++)
    {
      i = 0;
      pbUseSecondary[j] = FALSE;
      psProfilesIn[j] = (Cstring) j + " ";
      pfNumReflnsB[j] = pfNumReflns[j];

      while (    (m_nMinContribs > pfNumReflnsB[j]) && (MAX_OFFSETS > i)
	     &&  (99 != nOffsets[j % DTINT_MAX_AREAS][i]) )
	{
	  // Not enough contributions, so do something special
	  // Fill a secondary profile
	
	  nArea = j + nOffsets[j % DTINT_MAX_AREAS][i];
	  if ( (0 > nArea) || (nArea >= nNumReference) )
	    {
	      // Not legitimate, so skip
	    }
	  else
	    {
	      // Sum this area into ...

	      psProfilesIn[j] = psProfilesIn[j] + (Cstring) nArea + "/"
		                                + (Cstring)((int)pfNumReflns[nArea]) + " ";
	      pfRefOverall        = ppo3DReferenceB[j]->m_pfData;
	      pfRefVarOverall     = ppo3DVarReferenceB[j]->m_pfData;
	      pfNumContribOverall = ppo3DNumContribB[j]->m_pfData;

	      pfRef        = ppo3DReference[nArea]->m_pfData;
	      pfRefVar     = ppo3DVarReference[nArea]->m_pfData;
	      pfNumContrib = ppo3DNumContrib[nArea]->m_pfData;

	      for (k = 0; k < nNumPixels; k++)
		{
		  *pfRefOverall++        += *pfRef++;
		  *pfRefVarOverall++     += *pfRefVar++;
		  *pfNumContribOverall++ += *pfNumContrib++;
		}
	      if (j != nArea)
		pfNumReflnsB[j]          += pfNumReflns[nArea];
	    }
	  pbUseSecondary[j] = TRUE;
	  i++;
	}
      if (m_nMinContribs > pfNumReflnsB[j])
	{
	  // Still not enough reflns in the profile, after including neighbors,
	  // so use the overall profile instead

	  *ppo3DReferenceB[j]    = *ppo3DReference[nNumReference];
	  *ppo3DVarReferenceB[j] = *ppo3DVarReference[nNumReference];
	  *ppo3DNumContribB[j]   = *ppo3DNumContrib[nNumReference];
	  psProfilesIn[j]        = "Overall profile used!";
	  pbUseSecondary[j]      = TRUE;
	  pfNumReflnsB[j]        = pfNumReflns[nNumReference];
	}
    }

  // Copy any used secondary profiles to main profiles

  for (j = 0; j < nNumReference; j++)
    {
      if (pbUseSecondary[j])
	{
	  *ppo3DReference[j]    = *ppo3DReferenceB[j];
	  *ppo3DVarReference[j] = *ppo3DVarReferenceB[j];
	  *ppo3DNumContrib[j]   = *ppo3DNumContribB[j];
	  pfNumReflns[j]        = pfNumReflnsB[j];
	}
    }

  // Now have bunch of summed reference profiles so normalize them
  // Last profile is super profile of all profiles

  if (1 < m_nVerbose)
    {
      printf("Profile   Reflns  Sum(Pi**2/Vi)  Contributors\n"
	     "=============================================\n");
    }

  for (j = 0; j < nNumProfiles; j++)
    {
      pfRef        = ppo3DReference[j]->m_pfData;
      pfRefVar     = ppo3DVarReference[j]->m_pfData;
      pfNumContrib = ppo3DNumContrib[j]->m_pfData;
      fMax         = *pfRef;
      for (k = 0; k < nNumPixels; k++)
	{
	  if (0.0 != *pfNumContrib)
	    {
	      *pfRef      = *pfRef    / *pfNumContrib;
	      *pfRefVar   = *pfRefVar / *pfNumContrib;  // Maybe sqrt?
	      fMax        = max(fMax, *pfRef);          // Save maximum
	    }
	  pfRef++;
	  pfRefVar++;
	  pfNumContrib++;
	}

      // Normalize the reference profile so that maximum is 100
      //  and calculate another normalizing factor, so the
      //  sum of the reference profile is 1.0

      if (0.0 >= fMax)
	{
//	  printf("%4d      0\n");
//	  cerr << "Problem with a reference profile!\n";
//	  exit (1);
	  pfWeightRef[j] = 0.0;
	}
      else
	{
	  pfWeightRef[j] = 1.0;
	  pfRef        = ppo3DReference[j]->m_pfData;
	  pfRefVar     = ppo3DVarReference[j]->m_pfData;
	  pfSumRef[j]  = 0.0;
	  fScaleRefer  = 1.0f / fMax * 100.0f;
	  for (k = 0; k < nNumPixels; k++)
	    {
	      *pfRef    = *pfRef * fScaleRefer;
//	      *pfRefVar = sqrtf(*pfRefVar) * fScaleRefer; // Not sure about sqrt
	      *pfRefVar = *pfRefVar * fScaleRefer; // Not sure about sqrt
	      if (m_fMinInRefPeak <= *pfRef)
		{
		  pfSumRef[j] = pfSumRef[j] + *pfRef;
		}
	      pfRef++;
	      pfRefVar++;
	    }

	  if (1 < m_nVerbose)
	    {
	      printf("%4d %9.0f %9.0f      %s\n", j, pfNumReflns[j], pfSumRef[j],
		     psProfilesIn[j].string());
	    }
	}
    }

////////////////////////////////////////////////////////////////////////
//DEBUG write out the profit reference profile for viewing
// Tile them DTINT_MAX_AREAS per image
  {
    int ii, jj;
    short int iValue;
    float     fValue;
    Cimage oImageRefer(28 * 6 + 1, 28 * 3 + 1, eImage_I2);

    for (j = 0; j < nNumReference; j=j+DTINT_MAX_AREAS)
      {
	// Create an image of all the profiles

	oImageRefer.nSetNextPixel(0,0);
	iValue = 1000;
	for (ii = 0; ii < 28 * 6 + 1; ii++)
	  {
	    oImageRefer.vSetNextPixel(iValue);
	  }
	for (i = 0; i < DTINT_MAX_AREAS; i++)
	  {
	    Cimage oImageProfile(ppo3DReference[j+i]);
//	    Cimage oImageSigma(ppo3DVarReference[j+i]);
	    oImageProfile.nSetNextPixel(0,0);
//	    oImageSigma.nSetNextPixel(0,0);
	    for (jj = 0; jj < 27; jj++)
	      {
		oImageRefer.nSetNextPixel((i % 6)*28, (i / 6)*28+jj+1);
		iValue = 1000;
		oImageRefer.vSetNextPixel(iValue);
		for (ii = 0; ii < 27; ii++)
		  {
		    fValue = oImageProfile.fGetNextPixel();
//		    if (0.0 < fValue)
//		      fValue = fValue / oImageSigma.fGetNextPixel() ;
//		    else
//		      {
//			fValue = oImageSigma.fGetNextPixel() ;
//			fValue = 0.0;
//		      }
		    iValue = (int) (100.0 * fValue);
		    oImageRefer.vSetNextPixel(iValue);
		  }
		iValue = 1000;
		oImageRefer.vSetNextPixel(iValue);
	      }
	    oImageRefer.nSetNextPixel((i % 6)*28, (i / 6)*28+28);
	    iValue = 1000;
	    for (ii = 0; ii < 29; ii++)
	      {
		oImageRefer.vSetNextPixel(iValue);
	      }
	  }
	oImageRefer.m_oHeader.nReplaceValue(Cimage_header::ms_sNumReflns,
					  pfNumReflns[j], 1);
	sprintf(a255cNum, sDtrekGetPrefix() + "D%04d.refprof", j+1);

	// If verbosity not high enough, reduce verbosity of Cimage class to 0
	// to reduce output

	if (2 > m_nVerbose)
	  {
	    oImageRefer.vSetVerboseLevel(0);
	  }

	oImageRefer.nWrite(Cstring(a255cNum));
      }
  }

  cout << "...fitting observed profiles to reference profiles...\n" << flush;

////////////////////////////////////////////////////////////////////////
  // Loop again to fit each profile to a reference profile

  // Some variables for statistics

  float a10fCorrSig[10];
  float a10fCorrSD[10];
  float a10fNumRefln[10];
  float a10nCorrHist[10];

  for (i = 0; i < 10; i++)
    {
      a10fCorrSig[i]  = 0.0;
      a10fCorrSD[i]   = 0.0;
      a10fNumRefln[i] = 0.0;
      a10nCorrHist[i] = 0;
    }

  // Setup the output reflection list with the proper fields,
  // Open the output reflection file and write the header

  int nFI_nBadFlag, nFI_fOtherInt, nFI_fOtherSig, nFI_fLP, nFI_fCorr;

  nFI_nBadFlag  = oReflnlist.nExpandGetField(D_K_ProfitnBadFlag);
  nFI_fOtherInt = oReflnlist.nExpandGetField(D_K_ProfitfOtherInt);
  nFI_fOtherSig = oReflnlist.nExpandGetField(D_K_ProfitfOtherSig);
  (void) oReflnlist.nExpandGetField(oReflnlist.ms_sfObsPx0);
  (void) oReflnlist.nExpandGetField(oReflnlist.ms_sfObsPx1);
  (void) oReflnlist.nExpandGetField(oReflnlist.ms_sfObsRotMid);
  (void) oReflnlist.nExpandGetField(oReflnlist.ms_sfObsRotWidth);
  (void) oReflnlist.nExpandGetField(oReflnlist.ms_sfCalcPx0);
  (void) oReflnlist.nExpandGetField(oReflnlist.ms_sfCalcPx1);
  (void) oReflnlist.nExpandGetField(oReflnlist.ms_sfCalcRotMid);
  (void) oReflnlist.nExpandGetField(oReflnlist.ms_sfResolution);
  nFI_fLP       = oReflnlist.nExpandGetField("fLPfactor");
  nFI_fCorr     = oReflnlist.nExpandGetField("fCorrelation");
  nFI_fSvec[0]  = oReflnlist.nExpandGetField(Cintegrate::ms_sfSvec0);
  nFI_fSvec[1]  = oReflnlist.nExpandGetField(Cintegrate::ms_sfSvec1);
  nFI_fSvec[2]  = oReflnlist.nExpandGetField(Cintegrate::ms_sfSvec2);

  nFI_fS0vec[0] = oReflnlist.nExpandGetField(Cintegrate::ms_sfS0vec0);
  nFI_fS0vec[1] = oReflnlist.nExpandGetField(Cintegrate::ms_sfS0vec1);
  nFI_fS0vec[2] = oReflnlist.nExpandGetField(Cintegrate::ms_sfS0vec2);

  (void) oReflnlist.nExpandGetField(oReflnlist.ms_ssBatch);

  // Make sure poZoneReflnlist has all the same fields as oReflnlist

  int nFI_nSortFlag;
  poZoneReflnlist = new Creflnlist(oReflnlist);
  nFI_nSortFlag  = poZoneReflnlist->nExpandGetField(D_K_ProfitnBadFlag);
  if (nFI_nSortFlag != nFI_nBadFlag)
    {
      cout << "WARNING! nFISortFlag, nFIBadFlag: " << nFI_nSortFlag
           << nFI_nBadFlag << endl << flush;
    }

  // If the overwrite environment variable is set, then make sure
  // any existing reflnlist file gets a version number appended, so it is
  // not overwritten

  nStat = nFileAppendVersion(sReflnFile, TRUE);
  if (0 != nStat)
    {
      cerr << "ERROR in dtprofit: renaming reflnlist output file: " << sReflnFile << "!\n";
#ifdef SSI_PC
      return (2);
#else
      exit (2);
#endif
      /////////
    }

  // NEW!!!! 18-Apr-2000
  // Do not write out each refln as it is processed.
  // Instead, create a big reflnlist and insert reflns
  
  //  ofstream oOut(sTransSymbol(sReflnFile).string());

  // Expand oReflnlist to include the number of known reflections

  oReflnlist.nExpand(nNumReflns);

  // Create a reflection to hold answers to write out

  Crefln oRefln(&oReflnlist);

  // Open the Profit file and try to do something with it

  nSize       = sProfitFilename.length();
  nProfitFile = 1;
//  (void) dskbor(&nProfitFile, (const char *)sProfitFilename, &nSize, &nStat);
  (void) dskbor(&nProfitFile, sProfitFilename.string(), &nSize, &nStat);
  if (0 != nStat)
    vError(1, "Could not open file of Profit profiles.");

  // Read header info in Profit file
  //  Thought:  maybe the first record should be a tagProfitRec structure
  //            with necessary info stuffed in the fields

  nSize = 3*sizeof(float);
  (void) dskbr(&nProfitFile, (char *)a3fS0, &nSize, &nStat);
  nSize = 3*sizeof(int);
  (void) dskbr(&nProfitFile, (char *)a3nGridProfit, &nSize, &nStat);
  nSize = 3*sizeof(float);
  (void) dskbr(&nProfitFile, (char *)a3fSizeProfit, &nSize, &nStat);
  nSize = sizeof(float);
  (void) dskbr(&nProfitFile, (char *)&fBadFlag, &nSize, &nStat);
  nSize = sizeof(int);
  (void) dskbr(&nProfitFile, (char *)&nNumReference, &nSize, &nStat);

  // Read in the Profit profiles

  nReadStat  = 0;

  //  for (int n = 0; (n < nNumReflns) && oOut; n++)
  for (int n = 0; (n < nNumReflns); n++)
    {
      nSize = sizeof(tagProfitRec);
      (void) dskbr(&nProfitFile, (char *)&tProfitRec, &nSize, &nReadStat);
//      nSize = sizeof(float) * nNumPixels;
      if ( (0 == nReadStat) && (-2332.0 == tProfitRec.fObsPx0) )
	{
	  // Special flag for a trailer record

	  nReadStat = 2332;

	  m_fOverallRotStart    =  tProfitRec.fCalcPx0;
	  m_fOverallRotEnd      =  tProfitRec.fCalcPx1;
	  m_fRotIncrement       =  tProfitRec.fCalcRotMid;
	  m_nImagesPerBatch     =  tProfitRec.nProfileSize;
	  if (3 < m_nVerbose)
	    {
	      cout << "Special informational record found!\n"
		   << "Overall rot start,end, and increment: "
		   << m_fOverallRotStart << ", " << m_fOverallRotEnd << ", "
		   << m_fRotIncrement << ", " << m_nImagesPerBatch << endl;
	    }
	}
      else
	{
	  nSize = sizeof(float) * tProfitRec.nProfileSize;
	  if (0 == nReadStat)
	    (void) dskbr(&nProfitFile, (char *)po3DBoxProfit->m_pfData,
			 &nSize, &nReadStat);
	  if (0 == nReadStat)
	    (void) dskbr(&nProfitFile, (char *)po3DBoxVarProfit->m_pfData,
			 &nSize, &nReadStat);
	}
      if (0 == nReadStat)
	{
	  // Ok, have a shoebox, what to do with it?
	  // 1. Get reference profile possibly by using a weighted function
          //    of nearby reference profiles
          //

	  nDecompress(tProfitRec.nProfileSize,
		      nNumPixels,
		      tProfitRec.anProfileMask,
		      po3DBoxProfit->m_pfData,
		      po3DBoxVarProfit->m_pfData);

	  nArea = tProfitRec.nProfile;
	  if ( (0 > nArea) || (nArea >= nNumReference) )
	    {
	      cerr << "WARNING, bogus area: " << nArea << endl;
	      nArea = nNumReference;
	    }

          po3DRefer   = ppo3DReference[nArea];   // For now, just one profile
	  fScaleRefer = 1.0f / pfSumRef[nArea];   // Scale factor so sum[Pi] = 1.0;

	  // Compute  Sum[Pi*Ci/Vi] / Sum[Pi*Pi/Vi]
	  //  where
	  //        Pi is reference profile value for pixel i
	  //        Ci is reflection profile value for pixel i (observed counts
	  //             less background)
	  //        Vi is variance of reflection profile value for pixel i
	  //             (usually total counts before background subtraction)
	  // The reference profile is normalized so that Sum[Pi] = 1.0
	  // Be sure to exclude pixels that are flagged as bad.
	  //
	  // Compute correlation of the observed profile with the reference
	  // profile.  Correlation is defined as (see Numerical Recipes p. 484):
	  //                                                  2           2
	  //      Sum[(Pi - |P|)(Ci - |C|)] / sqrt(Sum[Pi-|P|] Sum[Ci-|C|] )

          pfRef     = po3DRefer->m_pfData;
          pfObs     = po3DBoxProfit->m_pfData;
          pfVar     = po3DBoxVarProfit->m_pfData;

	  fSumNumer = 0.0;
	  fSumDenom = 0.0;
	  fAvgRef   = 0.0;
	  fAvgObs   = 0.0;
	  fNumPix   = 0.0;
          fSumSignal= 0.0;
          fSumNoSignal = 0.0;
          fNumSumNS    = 0.0;
          fNumSumS     = 0.0;
          fSumMissing  = 0.0;
          fNumSumMissing = 0.0;
	  fExpectedCounts = tProfitRec.fOtherInt / tProfitRec.fRecipLP;
	  fBackgroundVar  = tProfitRec.fBackgSig * tProfitRec.fBackgSig;
          for (i = 0; i < nNumPixels; i++)
            {
	      if ( (fBadFlag != *pfObs) && (m_fMinInRefPeak <= *pfObs) )
		{
		  fRefValue = *pfRef * fScaleRefer;
		  fNumPix   = fNumPix    + 1.0f;

                  if (eMethod_VarianceAWeighted == m_eMethod)
                    {
                      // Weighted by variance:

                      fSumNumer = fSumNumer  +  fRefValue * *pfObs / *pfVar;
                      fSumDenom = fSumDenom  +  fRefValue * fRefValue  / *pfVar;

                    }
                  else if (eMethod_VarianceBWeighted == m_eMethod)
                    {
                      // Weighted by a different variance:

		      fVariance = fabs(fRefValue * fExpectedCounts)
			           + fBackgroundVar;
                      fSumNumer = fSumNumer  +  fRefValue * *pfObs / fVariance;
                      fSumDenom = fSumDenom  +  fRefValue * fRefValue  / fVariance;

                    }
                  else if (eMethod_UnitWeighted == m_eMethod)
                    {

                      // Equal weights:

                      fSumNumer = fSumNumer  +  fRefValue * *pfObs;
                      fSumDenom = fSumDenom  +  fRefValue * fRefValue;
                    }
                  else if (eMethod_Kabsch == m_eMethod)
                    {
                      // Kabsch method [J. Appl. Crys. (1988) 21, 916-924]:
                      //   Hmmm, this appears to be using the reference profile as a mask
                      //   to determine what is peak and what is background! No wonder he
                      //   calls it profile analysis and not profile fitting!

                      if (m_fMinInKabschProfile <= *pfRef)
                        {
                          // In signal region

                          fSumSignal = fSumSignal + fRefValue;    // Sum reference profile here
                          fNumSumS   = fNumSumS   + 1.0f;
                          fSumNumer  = fSumNumer  + *pfObs;       // Straight summation here
                          fSumDenom  = fSumDenom  + *pfVar;       // Sum variance too
                        }
                      else
                        {
                          // Outside of signal region

                          fSumNoSignal = fSumNoSignal  +  fRefValue; // Sum reference profile here
                          fNumSumNS    = fNumSumNS + 1.0f;
                        }
                    }

		  fAvgRef   = fAvgRef    +  fRefValue;
		  fAvgObs   = fAvgObs    + *pfObs;
		}
              else
                {
                  fSumMissing    = fSumMissing    + *pfRef * fScaleRefer;
                  fNumSumMissing = fNumSumMissing + 1.0f;
                }

	      pfRef++;
	      pfObs++;
	      pfVar++;
            }

	  if (4 < m_nVerbose)
	    {
	      cout << fNumPix << " : fNumPix\n";
	      cout << fAvgObs << " : fAvgObs\n";
	      cout << fAvgRef << " : fAvgRef\n";
	      cout << fSumNumer << " : fSumNumer\n";
	      cout << fSumDenom << " : fSumDenom\n";
	    }

	  if (0.0 != fNumPix)
	    {
	      fAvgObs    = fAvgObs / fNumPix;
	      fAvgRef    = fAvgRef / fNumPix;
	    }

	  // We still need to decide how to treat the missing intensity for
	  // pixels flagged as bad in the different methods below
	  // For example, if there are too many missing pixels, what should we do?

          if (eMethod_Kabsch == m_eMethod)
            {
              // Kabsch method
              // We have: Sum of reference profile within signal region
              //                                  outside signal region
              //          Sum of observed profile  within signal region (in fSumNumer)
              //          Sum of observed variance within signal region (in fSumDenom)
              // So estimate intensity outside of signal region as signal
	      //    inside signal region times ratio of profile inside and outside signal region

              if (0.0 >= fNumSumS)
                {
                  // No reference profile signal, so set intensity to 0.0

		  cout << "WARNING! no reference profile!\n" << endl;
                  fIntensity = 0.0;
                  fVariance  = 0.0;
                }
              else if (0.0 >= fSumNumer)
                {
                  // Negative reflection, scale variance by (total profile) / (signal profile)

                  fVariance  = fSumDenom * (fSumSignal + fSumNoSignal) / fSumSignal;
		  fIntensity = fSumNumer;
                }
              else
                {
                  // Normal reflection

                  fVariance  = fSumDenom * (fSumNoSignal / fSumSignal);  // Estimate variance in low region
                  fIntensity = fSumNumer * (fSumNoSignal / fSumSignal);  // Estimate intensity in low region
                  if (fIntensity > fVariance)
                    {
                      // If estimated intensity outside of signal region is too high, then
                      // make it more reasonable, this is a bit difference from Kabsch

                      fIntensity = fVariance;
                    }

                  // Now estimate intensity for the entire reflection,
		  // including an estimate for the missing pixels

                  fIntensity  = (fSumNumer + fIntensity) * (fSumSignal + fSumNoSignal + fSumMissing)
                                                         / (fSumSignal + fSumNoSignal);
                  fVariance   = (fSumDenom + fVariance ) * (fSumSignal + fSumNoSignal + fSumMissing)
                                                         / fSumSignal;
                }
            }

          // Other profile fitting methods

	  else if (0.0 != fSumDenom)
	    {

	      fIntensity = fSumNumer / fSumDenom;
	    }
	  else
	    {
	      fIntensity = 0.0;
	    }

	  // Now compute correlation and info for variance

          pfRef     = po3DRefer->m_pfData;
          pfObs     = po3DBoxProfit->m_pfData;
          pfVar     = po3DBoxVarProfit->m_pfData;

	  fSumNumer = 0.0;
	  fSumRefSq = 0.0;
	  fSumObsSq = 0.0;
	  if (eMethod_Kabsch != m_eMethod) fVariance = 0.0;

          for (i = 0; i < nNumPixels; i++)
            {
	      if ( (fBadFlag != *pfObs) && (m_fMinInKabschProfile <= *pfRef) )
		{
		  //
		  fRefValue = *pfRef * fScaleRefer;
		  fDelRef   = fRefValue - fAvgRef;
		  fDelObs   = *pfObs - fAvgObs;
		  fSumNumer = fSumNumer  +  fDelRef * fDelObs;
		  fSumRefSq = fSumRefSq  +  fDelRef * fDelRef;
		  fSumObsSq = fSumObsSq  +  fDelObs * fDelObs;
		  fDelRef   = (fIntensity * fRefValue) - *pfObs;
                  if (eMethod_Kabsch != m_eMethod)
                    {
                      // Compute variance only if not Kabsch method

		      fDelRef   = (fIntensity * fRefValue) - *pfObs;
                      fVariance = fVariance  + (fDelRef * fDelRef)
			           + fBackgroundVar;  // Include per pix bkgvar
                    }
		}
	      pfRef++;
	      pfObs++;
	      pfVar++;
            }
	  fCorr = fSumRefSq * fSumObsSq;
	  if (0.0 < fCorr)
	    {
	      fCorr = fSumNumer / sqrtf(fCorr);
	    }

	  // Accumulate some statistics to help judge whether profile fitting
	  // makes sense or not

	  if (0.0 <= fVariance)
	    {
	      fVariance       = sqrtf(fVariance);       // Convert to sigma
	      j               = (int) (fIntensity / fVariance / 3.0);
	      j               = min(max(0, j), 9);         // Limit index to 0->9
	      a10fNumRefln[j] = a10fNumRefln[j] + 1.0f;
	      a10fCorrSig[j]  = a10fCorrSig[j]  + fCorr;
	      a10fCorrSD[j]   = a10fCorrSD[j]   + (fCorr * fCorr);
	      j               = (int) (fCorr * 10.0);
	      j               = min(max(0, j), 9);      // Limit index to 0->9
	      a10nCorrHist[j]++;
	    }
	  else
	    {
	      cout << "WARNING! Variance < 0!\n";
	    }

	  if (0.0 != tProfitRec.fOtherInt)
	    fCorr = fIntensity * tProfitRec.fRecipLP / tProfitRec.fOtherInt;

	  oRefln.vSetH( tProfitRec.nH );
	  oRefln.vSetK( tProfitRec.nK );
	  oRefln.vSetL( tProfitRec.nL );
	  oRefln.vSetField(nFI_nBadFlag, (int)0);
	  oRefln.vSetIntensity( fIntensity * tProfitRec.fRecipLP );
	  oRefln.vSetSigmaI( fVariance * tProfitRec.fRecipLP );
	  oRefln.vSetField(nFI_fOtherInt, tProfitRec.fOtherInt);
	  oRefln.vSetField(nFI_fOtherSig, tProfitRec.fOtherSig);
	  oRefln.vSetField(oReflnlist.m_nFI_fObsPx0, tProfitRec.fObsPx0);
	  oRefln.vSetField(oReflnlist.m_nFI_fObsPx1, tProfitRec.fObsPx1);
	  oRefln.vSetField(oReflnlist.m_nFI_fObsRotMid, tProfitRec.fObsRotMid);
	  oRefln.vSetField(oReflnlist.m_nFI_fObsRotWidth, tProfitRec.fObsRotWidth);
	  oRefln.vSetField(oReflnlist.m_nFI_fCalcPx0, tProfitRec.fCalcPx0);
	  oRefln.vSetField(oReflnlist.m_nFI_fCalcPx1, tProfitRec.fCalcPx1);
	  oRefln.vSetField(oReflnlist.m_nFI_fCalcRotMid, tProfitRec.fCalcRotMid);
	  oRefln.vSetField(oReflnlist.m_nFI_fResolution, tProfitRec.fResolution);
	  oRefln.vSetField(nFI_fLP, tProfitRec.fRecipLP);
	  oRefln.vSetField(nFI_fCorr, fCorr);
	  for (i = 0; i < 3; i++)
	    {
	      oRefln.vSetField(nFI_fSvec[i], tProfitRec.a3fSrot[i]);
	      oRefln.vSetField(nFI_fS0vec[i], tProfitRec.a3fS0rot[i]);
	    }
	  oRefln.vSetField(oReflnlist.m_nFI_sBatch, (Cstring)tProfitRec.a8cBatch);

	  oReflnlist.nInsert(&oRefln);  // Insert reflection into list

	  // oRefln.vWrite(&oOut);  // Write out the reflection

	  if (0 < m_nVerbose)
	    {
	      // If oRefln is a zone (for now: h00, 0k0, 00l) add to oZoneReflnlist

	      nNumZeroes = 0;
	      if (0 == oRefln.nGetH()) nNumZeroes++;
	      if (0 == oRefln.nGetK()) nNumZeroes++;
	      if (0 == oRefln.nGetL()) nNumZeroes++;
	      if ( (2 <= nNumZeroes)  && (0.0 != oRefln.fGetSigmaI()) )
		{
		  poZoneReflnlist->nInsert(&oRefln);
		}
	    }
	  nNumWritten++;
        } // end if (0 == nReadStat)
    } // end n loop

  (void) dskbcr(&nProfitFile, &nStat);
  //  oOut.close();

  // Sort reflnlist on ObsRotMid angles and re-label sBatch's

  oReflnlist.vSort(eReflnField_float_type, oReflnlist.m_nFI_fObsRotMid, NULL);
  float fRotMin, fRotMax;
  Crefln *poRefln;
  int    *pnIndex;
  int nBatchMin;
  Cstring sBatchMin, sBatchMax;
  pnIndex   = oReflnlist.pnGetSortIndex();
  poRefln   = oReflnlist.poGetRefln(pnIndex[0]);
  fRotMin   = poRefln->fGetField(oReflnlist.m_nFI_fObsRotMid);
  sBatchMin = poRefln->sGetField(oReflnlist.m_nFI_sBatch);
  poRefln   = oReflnlist.poGetRefln(pnIndex[oReflnlist.nGetNumReflns()-1]);
  fRotMax   = poRefln->fGetField(oReflnlist.m_nFI_fObsRotMid);
  sBatchMax = poRefln->sGetField(oReflnlist.m_nFI_sBatch);

  sTemp = sBatchMin;
  if ("" != m_sBatchPrefix)
    sTemp = sBatchMin.after(m_sBatchPrefix);
  nBatchMin = atoi(sTemp.string());

  if (3 < m_nVerbose)
    {
      cout << "RotMin,Max: " << fRotMin << ", " << fRotMax << endl;
      cout << "sBatchMin,Max: " << sBatchMin << ", " << sBatchMax << endl;
    }

  // Divide reflections into scaling batches.  One scaling batch per image

  float fDegreesPerBatch = 1.0;

  // Default is 1 degree per scaling batch unless set

  if (0.0 < m_fDegreesPerBatch)
    {
      // User input the desired degrees per batch 

      fDegreesPerBatch = m_fDegreesPerBatch;
      cout << "\nScaling batch ids will be every " << fDegreesPerBatch
           << " degree";
      if (1.0 < fDegreesPerBatch)
	cout << 's';
      cout << ".\n" << endl;
    }
  else 
    {
      // Try to figure out the best degrees per batch.  The minimum
      // fDegreesPerBatch is the m_fRotIncrement, but try to have
      // at least m_nMinRefsPerBatch reflns per batch

      int nRefPerInc;
      nRefPerInc = nint((float)oReflnlist.nGetNumReflns()
			 / max(1.0, (fRotMax - fRotMin)));
      if (1 > nRefPerInc) nRefPerInc = 1;

      fDegreesPerBatch = m_fRotIncrement;
      nTemp            = nRefPerInc;
      while (   (m_nMinRefsPerBatch >  nTemp) 
	     && (fDegreesPerBatch < (fRotMax - fRotMin)) )
	{
	  nTemp            += nRefPerInc;
	  fDegreesPerBatch += m_fRotIncrement;
	}
      cout << "\nScaling batch ids will be every " << fDegreesPerBatch
           << " degree";
      if (1.0 < fDegreesPerBatch)
	cout << 's';
      cout << ",\n   so that there will be about " << ((nTemp + 49) / 50) * 50
           << " reflections per batch.\n" << endl;
    }

  fRotMax = m_fOverallRotStart + fDegreesPerBatch;

  int *pnNumRefsPerBatch;
  pnNumRefsPerBatch = new int [10000];
  for (i = 0; i < 10000; i++)
    pnNumRefsPerBatch[i] = -1;
  int nBatchCount      = 1;
  pnNumRefsPerBatch[0] = 0;              // Note: pnNumRefsPerBatch[0] is unused
  pnNumRefsPerBatch[nBatchCount] = 0;
  for (i = 0; i < oReflnlist.nGetNumReflns(); i++)
    {
      poRefln   = oReflnlist.poGetRefln(pnIndex[i]);
      if (poRefln->fGetField(oReflnlist.m_nFI_fObsRotMid) > fRotMax)
	{
	  // Increment sBatchMin somehow

	  if (1000 > nBatchMin)
	    sprintf(a255cNum, "%s%03d", m_sBatchPrefix.string(), nBatchMin+nBatchCount);
	  else
	    sprintf(a255cNum, "%s%d", m_sBatchPrefix.string(), nBatchMin+nBatchCount);
	  if (3 < m_nVerbose)
	    {
	      cout << "Numrefs in batch: " << nBatchCount << ", " 
		   << pnNumRefsPerBatch[nBatchCount] << endl;
	    }
	  nBatchCount++;
	  if (10000 <= nBatchCount)
	    {
	      cout << "ERROR too many batches!\n" << flush;
#ifdef SSI_PC
	      return (3);
#else
	      exit (3);
#endif
	    }

	  sBatchMin = (Cstring)a255cNum;
	  fRotMax = m_fOverallRotStart + (float)nBatchCount * fDegreesPerBatch;
	  //	  cout << "New batchname: " << sBatchMin << " for rot < " 
	  //	       << fRotMax << endl;
	  pnNumRefsPerBatch[nBatchCount] = 0;
	}
      poRefln->vSetField(oReflnlist.m_nFI_sBatch, sBatchMin);
      pnNumRefsPerBatch[nBatchCount]++;
    }

  // There are nBatch's, so look if the first and last batch have 
  // too few reflns.  If so, rename them

  // Remember pnNumRefsPerBatch[1] has the FIRST batch
  // Remember pnNumRefsPerBatch[nBatchCount] is the LAST batch
  // Average the number of reflns in batches 2 through (nBatchCount-1)

  fTemp = 0.0;
  for (i = 2; i < nBatchCount; i++)
    {
      fTemp = fTemp + pnNumRefsPerBatch[i];
    }

  if (nBatchCount > 2)
    fTemp = fTemp / (float)(nBatchCount - 2);
  else if (2 == nBatchCount)
    fTemp = (pnNumRefsPerBatch[1] + pnNumRefsPerBatch[2]) * 0.5;
  else
    fTemp = pnNumRefsPerBatch[1];
  
  cout << "...done.\n\n"
       << "Average number of reflns per batch is " << nint(fTemp) 
       << " for " << nBatchCount << " batches.\n\n";

  if ( (fTemp / 3.0) > pnNumRefsPerBatch[1])
    {
      poRefln  = oReflnlist.poGetRefln(pnIndex[0]);
      sTemp    = poRefln->sGetField(oReflnlist.m_nFI_sBatch);
      cout << "WARNING first batch (" << sTemp
	   << ") has too few reflections ( " << pnNumRefsPerBatch[1]
	   << " ),\n";
      if (m_bRebatch)
	{
	  // First batch is lite, so re-batch it.

	  cout << "  so first batch combined with next batch (";
	  poRefln   = oReflnlist.poGetRefln(pnIndex[pnNumRefsPerBatch[1]]);
	  sTemp     = poRefln->sGetField(oReflnlist.m_nFI_sBatch);
	  cout << sTemp << ")!" << endl;
	  for (i = 0; i < pnNumRefsPerBatch[1]; i++)
	    {
	      poRefln   = oReflnlist.poGetRefln(pnIndex[i]);
	      poRefln->vSetField(oReflnlist.m_nFI_sBatch, sTemp);
	    }
	}
      else
	{
	  cout << "  BUT NOT COMBINED with next batch!\n" << endl;
	}
    }

  if ( (fTemp / 3.0) > pnNumRefsPerBatch[nBatchCount])
    {
      // Last batch is lite, so re-batch it.

      poRefln  = oReflnlist.poGetRefln(pnIndex[oReflnlist.nGetNumReflns()-1]);
      sTemp    = poRefln->sGetField(oReflnlist.m_nFI_sBatch);
      cout << "WARNING last batch (" << sTemp
           << ") has too few reflections ( " << pnNumRefsPerBatch[nBatchCount]
	   << " ),\n";
      if (m_bRebatch)
	{
	  cout << "  so last batch combined with previous batch (";
	  j = oReflnlist.nGetNumReflns() - 1 - pnNumRefsPerBatch[nBatchCount];
	  poRefln   = oReflnlist.poGetRefln(pnIndex[j]);
	  sTemp     = poRefln->sGetField(oReflnlist.m_nFI_sBatch);
	  cout << sTemp << ")!" << endl;
	  for (i = 0; i < pnNumRefsPerBatch[nBatchCount]; i++)
	    {
	      j = oReflnlist.nGetNumReflns() - 1 - i;
	      poRefln   = oReflnlist.poGetRefln(pnIndex[j]);
	      poRefln->vSetField(oReflnlist.m_nFI_sBatch, sTemp);
	    }
	}
      else
	{
	  cout << "  BUT NOT COMBINED with previous batch!\n" << endl;
	}
    }

  delete [] pnNumRefsPerBatch;

  nStat = oReflnlist.nWrite(sTransSymbol(sReflnFile));
  if (0 == nStat)
    {
      cout << "...done ";
    }
  else
    {
      cout << "ERROR! ";
    }
  cout << "writing reflnlist file: " << sReflnFile << '\n' << flush;

  // Print out the statistics and results

  j = 0;
  printf ("\nInt/SigmaI vs Average correlation of"
          "\n   observed to reference profiles"
          "\n=====================================");
  printf ("\nSigma range     Avg.Corr.  Num.Refln.");
  printf ("\n-------------------------------------\n");
  for (i = 0; i < 10; i++)
    {
      printf("%2d ... %2d         ", j, j+3);
      if (0.0 < a10fNumRefln[i])
	{
	  a10fCorrSig[i] = a10fCorrSig[i] / a10fNumRefln[i];  // Avg correlation
	  printf("%6.3f",  a10fCorrSig[i]);
	}
      else
	{
	  printf("   -  ");
	}
      printf(" %8d\n",  (int) a10fNumRefln[i]);
      j = j + 3;
    }
  printf ("-------------------------------------\n");
  printf("\nCorrelation range vs"
         "\n number of reflections"
         "\n=========================");
  printf("\nCorr.range     Num.Refln.");
  printf("\n------------------------\n");
  for (i = 0; i < 10; i++)
    {
      fCorr = float(i) * 0.1f;
      printf("%3.1f ... %3.1f    %8.0f\n", fCorr, fCorr + 0.1, a10nCorrHist[i]);
    }
  printf("------------------------\n");
  cout << "Number of reflections written: " << nNumWritten << endl << flush;

  if (0 < m_nVerbose)
    {
      // Do some things with oZoneReflnlist

      if (0 >= poZoneReflnlist->nGetNumReflns())
	{
	  printf("\nNo axial reflections are available for listing.\n");
	}
      else
	{
	  Crefln *poRefln;
	  int nPack;
	  int *pnIndex = NULL;

	  // Pack HKL for sorting for output below

	  if (0 > nFI_nSortFlag)
	    {
	      cout << "WARNING nSortFlag field missing!\n" << flush;
	      nFI_nSortFlag = 0;
	    }
	  for (i = 0; i < poZoneReflnlist->nGetNumReflns(); i++)
	    {
	      poRefln = poZoneReflnlist->poGetRefln(i);
	      nPack   = poRefln->nPackHKL();
	      poRefln->vSetField(nFI_nSortFlag, nPack);
	    }
  
	  poZoneReflnlist->vSort(eReflnField_int_type, nFI_nSortFlag, NULL);

	  pnIndex = poZoneReflnlist->pnGetSortIndex();
	  poZoneReflnlist->nWrite(sDtrekGetPrefix()+"zone.ref");
	  cout << "\n...done writing reflnlist file: "
               << sDtrekGetPrefix() << "zone.ref\n" << flush;
	  printf("\nh00, 0k0, 00l reflections"
	         "\n--------------------------------------------------------------"
	         "\n    h     k     l Intensity SigmaInt I/sigI  Pix0  Pix1  Angle"
//              12345 12345 12345 123456789 12345678 123456 12345 12345 12345 
	        "\n--------------------------------------------------------------\n");
	  for (i = 0; i < poZoneReflnlist->nGetNumReflns(); i++)
	    {
	      poRefln = poZoneReflnlist->poGetRefln(pnIndex[i]);
	      printf("%5d %5d %5d %9.0f %8.0f %6.1f %5.0f %5.0f %6.2f\n",
		     poRefln->nGetH(),
		     poRefln->nGetK(),
		     poRefln->nGetL(),
		     poRefln->fGetIntensity(),
		     poRefln->fGetSigmaI(),
		     poRefln->fGetIntensity() / poRefln->fGetSigmaI(),
		     poRefln->fGetField(poZoneReflnlist->m_nFI_fObsPx0),
		     poRefln->fGetField(poZoneReflnlist->m_nFI_fObsPx1),
		     poRefln->fGetField(poZoneReflnlist->m_nFI_fObsRotMid));
	    }
	}
    }

  // Free allocated space

  for (i = 0; i < nNumProfiles; i++)   // NOTE: <=
    {
      if (NULL != ppo3DReference[i])
	{
	  delete ppo3DReference[i];
	  ppo3DReference[i] = NULL;
	}
      if (NULL != ppo3DVarReference[i])
	{
	  delete ppo3DVarReference[i];
	  ppo3DVarReference[i] = NULL;
	}
      if (NULL != ppo3DNumContrib[i])
	{
	  delete ppo3DNumContrib[i];
	  ppo3DNumContrib[i] = NULL;
	}
      if (NULL != ppo3DReferenceB[i])
	{
	  delete ppo3DReferenceB[i];
	  ppo3DReferenceB[i] = NULL;
	}
      if (NULL != ppo3DVarReferenceB[i])
	{
	  delete ppo3DVarReferenceB[i];
	  ppo3DVarReferenceB[i] = NULL;
	}
      if (NULL != ppo3DNumContribB[i])
	{
	  delete ppo3DNumContribB[i];
	  ppo3DNumContribB[i] = NULL;
	}
    }

  delete po3DBoxProfit;
  delete po3DBoxVarProfit;
  delete [] ppo3DReference;
  delete [] ppo3DVarReference;
  delete [] ppo3DNumContrib;
  delete [] ppo3DReferenceB;
  delete [] ppo3DVarReferenceB;
  delete [] ppo3DNumContribB;
  delete [] pfWeightRef;
  delete [] pfSumRef;
  delete [] pfNumReflns;
  delete [] pfNumReflnsB;
  delete [] pbUseSecondary;
  delete [] psProfilesIn;

  cout << "\ndtprofit: Done.\n" << flush;

  return (nStat);
}

void vError(const int nErrorNum, const Cstring& sMessage)
{
  if (0 != nErrorNum)
    {
      cerr << sMessage << '\n';
    }
  cout << "\ndtprofit - Usage:\n"
       << "dtprofit  [options]\n\n"
       << "Options:\n\n"
       << "-kabsch    Use W. Kabsch profile analysis method\n\n"
       << "-var       Use variance weighted profile fitting method (default)\n\n"
       << "-unit      Use unit weighted profile fitting method\n\n"
       << "-pmin n    Minimum reference profile value in peak. Default: 0.\n\n"
       << "-kmin n    Minimum reference profile value in Kabsch signal area.\n"
       << "             (Used only if -kabsch option used.)  Default: 1. \n\n"
       << "-dbatch fDeg Degrees per scaling batch.  Reflections will be divided\n"
       << "             into scaling batches every fDeg degrees.  If not set\n"
       << "             degrees per batch will be set by the -refsbatch option,\n"
       << "             but will not be less than the degrees per image.\n\n"
       << "-refsbatch nRefs  Set  minimum number of reflns per batch. Ignored\n"
       << "             if -dbatch option is used.  Default is 100.\n\n"
       << "-norebatch Turn off rebatching.  By default if either the first\n"
       << "             or last batch have less than one-third the average\n"
       << "             number of reflns in the other batches, they are combined\n"
       << "             with either the next or previous batch, respectively.\n\n"
       << "-min  n    Minimum required contributors to a reference profile. Default: 50.\n\n"
	    << flush;
#ifndef SSI_PC
  exit (nErrorNum);
#endif
}

int nDecompress(const int nArraySizeCompressed,
		const int nArraySizeUncompressed,
		const int *pnMask, float *pfArray1, float *pfArray2)
{
  // Decompress a profile and its variance that was compressed by
  // Cintegrate::nDoKabsch.
  //
  // Compression was simple: did not write out grid points with values of 0.
  // The *pnMask is an array of bits, one bit for each pixel in the original
  // uncompressed array.  If the bit is 0, then the pixel is not in the
  // compressed array and the pixel has a value of 0.
  // If the bit is 1, then the pixel is in the compressed array.
  // The input compressed arrays *pfArray1 and *pfArray2 are uncompressed
  // in place.
  // They should have enough space to hold the entire uncompressed array.

  int    i;
  int    nStat;
  int    nIndex, nBit;
  float *pfTemp1;
  float *pfTemp1A;
  float *pfTemp2;
  float *pfTemp2A;

  // In order to uncompress in place, work our way backwards through the arrays

  pfTemp1A = pfArray1 + nArraySizeCompressed   - 1;
  pfTemp1  = pfArray1 + nArraySizeUncompressed - 1;
  pfTemp2A = pfArray2 + nArraySizeCompressed   - 1;
  pfTemp2  = pfArray2 + nArraySizeUncompressed - 1;

  for (i = nArraySizeUncompressed-1; i >=0; i--)
    {
      nIndex =  i / (sizeof(int) * 8);
      nBit   =  i % (sizeof(int) * 8);
      if (0 != (pnMask[nIndex] & (1 << nBit)))
	{
	  // Bit set, so value is in compressed array

	  *pfTemp1-- = *pfTemp1A--;
	  *pfTemp2-- = *pfTemp2A--;
	}
      else
	{
	  // Bit not set, so put a zero in the uncompressed array

	  *pfTemp1-- = 0.0;
	  *pfTemp2-- = 0.0;
	}
    }

  // Double check that we have used all the values

  nStat = 0;
  if ((pfTemp1+1) != pfArray1)
    {
      cout << "Trouble in nDecompress!\n" << flush;
      nStat = -1;
    }
  return (nStat);
}
