//
// README: Portions of this file are merged at file generation
// time. Edits can be made *only* in between specified code blocks, look
// for keywords <Begin user code> and <End user code>.
//
/////////////////////////////////////////////////////////////
//
// Source file for CUIheaderEdit
//
//    Created by Builder Xcessory Version 5.0.
//    Generated by Code Generator Xcessory 5.0 (05/22/98) .
//
//    This class is a user interface "component", as described
//    in "Object-Oriented Programming with C++ and OSF/Motif",
//    by Douglas Young, Prentice Hall, 1992. ISBN 0-13-630252-1
//
/////////////////////////////////////////////////////////////


// Begin user code block <file_comments>

//
// Copyright (c) 1997 Molecular Structure Corporation
//
// RESTRICTED RIGHTS NOTICE SHORT FORM (JUNE 1987)
//
// Use, reproduction, or disclosure is subject to restrictions set
// forth in Contract No. W-31-109-ENG-38 and Contract No. 
// 943072401 with the University of Chicago, Operator of
// Argonne National Laboratory.
//
// CUIheaderEdit.cc  Initial author: T.L. Hendrixson          10-Apr-1997
//    This file implements the class for CUIheaderEdit which
//    implements a header edit dialog for dtprocess.
/*
 *
 * Copyright (C) 2014 Rigaku Americas Corporation
 *                    9009 New Trails Drive
 *                    The Woodlands, TX, USA  77381
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *    * Redistributions of source code must retain the above copyright
 *      notice(s), this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above copyright
 *      notice(s), this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 *    * Neither the name of the Rigaku Americas Corporation nor the 
 *      names of its contributors may be used to endorse or promote products
 *      derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL RIGAKU AMERICAS CORPORATION BE LIABLE 
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA OR PROFITS; OR BUSINESS INTERUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
 * DAMAGE.
 *
 */


// End user code block <file_comments>

#include <X11/StringDefs.h>
#include <Xm/SelectioB.h>
#include <Xm/DialogS.h>
#include <Xm/MwmUtil.h>
#include <Xm/MessageB.h>
#include <Xm/Form.h>
#include <Xm/Label.h>
#include <Xm/PushB.h>
#include <Xm/ScrolledW.h>
#include <Xm/Text.h>
#include <Xm/TextF.h>
#include <Xm/Separator.h>
#include <Xm/List.h>
#include <Xm/Frame.h>
#include <Xm/RowColumn.h>
#include "CUIheaderEdit.h"

//
// Convenience functions from utilities file.
//
extern void RegisterBxConverters(XtAppContext);
extern XtPointer BX_CONVERT(Widget, char *, char *, int, Boolean *);
extern XtPointer BX_DOUBLE(double);
extern XtPointer BX_SINGLE(float);
extern void BX_MENU_POST(Widget, XtPointer, XEvent *, Boolean *);
extern Pixmap XPM_PIXMAP(Widget, char **);
extern void BX_SET_BACKGROUND_COLOR(Widget, ArgList, Cardinal *, Pixel);


// Begin user code block <head>

#include "Dtrek.h"
#include "dtrekdefs.h"
Cstring CUIheaderEdit::ms_sCrystComment          = D_K_Comment;
Cstring CUIheaderEdit::ms_sCrystMosaicity        = D_K_CrystalPrefix D_K_CrystalXMosaicity;
Cstring CUIheaderEdit::ms_sCrystOrient           = D_K_CrystalPrefix D_K_CrystalXOrientAngles;
Cstring CUIheaderEdit::ms_sCrystSpaceGroupNumber = D_K_CrystalPrefix D_K_CrystalXSpacegroup;
Cstring CUIheaderEdit::ms_sCrystUnitCell         = D_K_CrystalPrefix D_K_CrystalXUnitCell;
Cstring CUIheaderEdit::ms_sDetDimensions         = D_K_DetectorDimensions;
Cstring CUIheaderEdit::ms_sDetGonio              = D_K_GonioValues;
Cstring CUIheaderEdit::ms_sDetGonioNames         = D_K_GonioNames;
Cstring CUIheaderEdit::ms_sDetNames              = D_K_DetectorNames;
Cstring CUIheaderEdit::ms_sSourceRot             = D_K_SourceValues;
Cstring CUIheaderEdit::ms_sSourceWavelength      = D_K_SourcePrefix D_K_Wavelength;

// End user code block <head>

//
// This table is used to define class resources that are placed
// in app-defaults. This table is necessary so each instance
// of this class has the proper default resource values set.
// This eliminates the need for each instance to have
// its own app-defaults values. This table must be NULL terminated.
//
#if defined(cxx_bx_compat)

Boolean CUIheaderEdit::_initAppDefaults = True;
UIAppDefault  CUIheaderEdit::_appDefaults[] = {
    {"mdGetValueError", NULL, "dialogTitle", NULL},
    {"mdGetValueError", NULL, "messageString", NULL},
    {"mdValueError", NULL, "dialogTitle", NULL},
    {"mdValueError", NULL, "messageString", NULL},
    {"mdReplaceValueError", NULL, "dialogTitle", NULL},
    {"mdReplaceValueError", NULL, "messageString", NULL},
    {"mdAddKeywordError", NULL, "dialogTitle", NULL},
    {"mdAddKeywordError", NULL, "messageString", NULL},
    {"mdDeleteKeywordError", NULL, "dialogTitle", NULL},
    {"mdDeleteKeywordError", NULL, "messageString", NULL},
    {"mdKeywordLengthError", NULL, "dialogTitle", NULL},
    {"mdKeywordLengthError", NULL, "messageString", NULL},
    {"mdKeywordCharacterError", NULL, "dialogTitle", NULL},
    {"mdKeywordCharacterError", NULL, "messageString", NULL},
    {"mdProtectedKeywordWarning", NULL, "dialogTitle", NULL},
    {"mdProtectedKeywordWarning", NULL, "messageString", NULL},
    {"pbDeleteKeyword", NULL, "labelString", NULL},
    {"pbReplaceValue", NULL, "labelString", NULL},
    {"pbAddKeyword", NULL, "labelString", NULL},
    {"lValue", NULL, "labelString", NULL},
    {"lHeader", NULL, "labelString", NULL},
    {"lKeyword", NULL, "labelString", NULL},
    {"lCrystSpaceGroup", NULL, "labelString", NULL},
    {"lCrystSpaceGroupName", NULL, "labelString", NULL},
    {"lCrystSpaceGroupNumber", NULL, "labelString", NULL},
    {"lCrystMosaicity", NULL, "labelString", NULL},
    {"lCrystOrient", NULL, "labelString", NULL},
    {"lCrystOrient1", NULL, "labelString", NULL},
    {"lCrystOrient2", NULL, "labelString", NULL},
    {"lCrystUnitCell", NULL, "labelString", NULL},
    {"lCrystUnitCellA", NULL, "labelString", NULL},
    {"lCrystUnitCellB", NULL, "labelString", NULL},
    {"lCrystUnitCellC", NULL, "labelString", NULL},
    {"lCrystUnitCellAlpha", NULL, "fontList", NULL},
    {"lCrystUnitCellAlpha", NULL, "labelString", NULL},
    {"lCrystUnitCellBeta", NULL, "fontList", NULL},
    {"lCrystUnitCellBeta", NULL, "labelString", NULL},
    {"lCrystUnitCellGamma", NULL, "fontList", NULL},
    {"lCrystUnitCellGamma", NULL, "labelString", NULL},
    {"lDetDirectBeamX", NULL, "labelString", NULL},
    {"lDetDirectBeamY", NULL, "labelString", NULL},
    {"lDetDirectBeam", NULL, "fontList", NULL},
    {"lDetDirectBeam", NULL, "labelString", NULL},
    {"lDetRot1", NULL, "labelString", NULL},
    {"lDetRot2", NULL, "labelString", NULL},
    {"lDetRot3", NULL, "labelString", NULL},
    {"lDetRot", NULL, "labelString", NULL},
    {"lDetTrans1", NULL, "labelString", NULL},
    {"lDetTrans2", NULL, "labelString", NULL},
    {"lDetTrans3", NULL, "labelString", NULL},
    {"lDetTrans", NULL, "labelString", NULL},
    {"lSourceRot", NULL, "labelString", NULL},
    {"lSourceWavelength", NULL, "labelString", NULL},
    {"pbPageMisc", NULL, "labelString", NULL},
    {"pbPageCryst", NULL, "labelString", NULL},
    {"pbPageDet", NULL, "labelString", NULL},
    {"pbPageSource", NULL, "labelString", NULL},
    {NULL, NULL, NULL, NULL}
};
#endif

// These are default resources for widgets in objects of this class
// All resources will be prepended by *<name> at instantiation,
// where <name> is the name of the specific instance, as well as the
// name of the baseWidget. These are only defaults, and may be overriden
// in a resource file by providing a more specific resource name

String  CUIheaderEdit::_defaultCUIheaderEditResources[] = {
        NULL
};

//
// Old style constructor, for compatibility only.
//
CUIheaderEdit::CUIheaderEdit(const char *name, Widget parent) : 
    UIComponent(name)

// Begin user code block <alt_superclass>
// End user code block <alt_superclass>
{
    
    // Begin user code block <alt_constructor>
    // End user code block <alt_constructor>
    create(parent);
}

//
// Class Constructor.
//
CUIheaderEdit::CUIheaderEdit(const char *name) : UIComponent(name)

// Begin user code block <superclass>
// End user code block <superclass>
{
    
    // Begin user code block <constructor>

   int i;

   m_pObj = NULL;
   m_prvHeaderModNotifyCallback = NULL;

   m_bHeaderHasChanged = false;

   for(i = 0; i < 2; i++){
      m_axsAddKeywordError[i] = NULL;
      m_axsDeleteKeywordError[i] = NULL;
      m_axsGetValueError[i] = NULL;
      m_axsKeywordCharacterError[i] = NULL;
      m_axsKeywordLengthError[i] = NULL;
      m_axsReplaceValueError[i] = NULL;
      m_axsValueError[i] = NULL;
   }

    // End user code block <constructor>
}


//
// Minimal Destructor. Base class destroys widgets.
//
CUIheaderEdit::~CUIheaderEdit() 
{
    
    // Begin user code block <destructor>
    // End user code block <destructor>
    delete []  _clientDataStructs;
}

//
// Handle creation of all widgets in the class.
//
void CUIheaderEdit::create(Widget parent) 
{
    Cardinal ac = 0;
    Arg      args[256];
    Cardinal cdc = 0;
    Boolean  argok = False;
    
    _clientDataStructs = new UICallbackStruct[61];
    
    //
    // Load any class-defaulted resources for this object.
    //
    setDefaultResources(parent, _defaultCUIheaderEditResources);
    
#if defined(cxx_bx_compat)
    //
    // Setup app-defaults fallback table if not already done.
    //
    if (_initAppDefaults)
    {
        initAppDefaults(parent, "CUIheaderEdit", _appDefaults);
        _initAppDefaults = False;
    }
    //
    // Now set the app-defaults for this instance.
    //
    setAppDefaults(parent, _appDefaults, _name, False);
#endif
    
    //
    // Register the converters for the widgets.
    //
    RegisterBxConverters(XtWidgetToApplicationContext(parent));
    XtInitializeWidgetClass((WidgetClass)xmSelectionBoxWidgetClass);
    XtInitializeWidgetClass((WidgetClass)xmDialogShellWidgetClass);
    XtInitializeWidgetClass((WidgetClass)xmMessageBoxWidgetClass);
    XtInitializeWidgetClass((WidgetClass)xmFormWidgetClass);
    XtInitializeWidgetClass((WidgetClass)xmLabelWidgetClass);
    XtInitializeWidgetClass((WidgetClass)xmPushButtonWidgetClass);
    XtInitializeWidgetClass((WidgetClass)xmScrolledWindowWidgetClass);
    XtInitializeWidgetClass((WidgetClass)xmTextWidgetClass);
    XtInitializeWidgetClass((WidgetClass)xmTextFieldWidgetClass);
    XtInitializeWidgetClass((WidgetClass)xmSeparatorWidgetClass);
    XtInitializeWidgetClass((WidgetClass)xmListWidgetClass);
    XtInitializeWidgetClass((WidgetClass)xmFrameWidgetClass);
    XtInitializeWidgetClass((WidgetClass)xmRowColumnWidgetClass);
    
    //
    // Create an unmanaged widget as the top of the hierarchy.
    //
    
    ac = 0;
    XtSetArg(args[ac], XmNdialogType, XmDIALOG_PROMPT); ac++;
    XtSetArg(args[ac], XmNchildPlacement, XmPLACE_TOP); ac++;
    XtSetArg(args[ac], XmNresizePolicy, XmRESIZE_NONE); ac++;
    _CUIheaderEdit = XmCreateSelectionBox(parent,
        _name,
        args, 
        ac);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_CUIheaderEdit,
        XmNhelpCallback,
        CUIheaderEdit::ClassHelpCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)"ok";
    XtAddCallback(_CUIheaderEdit,
        XmNokCallback,
        CUIheaderEdit::ChangeHeaderCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)"cancel";
    XtAddCallback(_CUIheaderEdit,
        XmNcancelCallback,
        CUIheaderEdit::ChangeHeaderCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)"apply";
    XtAddCallback(_CUIheaderEdit,
        XmNapplyCallback,
        CUIheaderEdit::ChangeHeaderCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    XtUnmanageChild(XmSelectionBoxGetChild(_CUIheaderEdit, XmDIALOG_SELECTION_LABEL));
    XtUnmanageChild(XmSelectionBoxGetChild(_CUIheaderEdit, XmDIALOG_TEXT));
    
    _w = _CUIheaderEdit;
    //
    // Add a callback to guard against widget destruction..
    //
    installDestroyHandler();
    
    ac = 0;
    XtSetArg(args[ac], XmNx, 715); ac++;
    XtSetArg(args[ac], XmNy, 803); ac++;
    XtSetArg(args[ac], XmNwidth, 44); ac++;
    XtSetArg(args[ac], XmNheight, 146); ac++;
    _dsGetValueError = XtCreatePopupShell("dsGetValueError",
        xmDialogShellWidgetClass,
        _CUIheaderEdit,
        args, 
        ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNdialogStyle, XmDIALOG_FULL_APPLICATION_MODAL); ac++;
    XtSetArg(args[ac], XmNdialogType, XmDIALOG_ERROR); ac++;
    _mdGetValueError = XmCreateMessageBox(_dsGetValueError,
        "mdGetValueError",
        args, 
        ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNx, 715); ac++;
    XtSetArg(args[ac], XmNy, 803); ac++;
    XtSetArg(args[ac], XmNwidth, 44); ac++;
    XtSetArg(args[ac], XmNheight, 163); ac++;
    _dsValueError = XtCreatePopupShell("dsValueError",
        xmDialogShellWidgetClass,
        _CUIheaderEdit,
        args, 
        ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNdialogStyle, XmDIALOG_FULL_APPLICATION_MODAL); ac++;
    XtSetArg(args[ac], XmNdialogType, XmDIALOG_ERROR); ac++;
    _mdValueError = XmCreateMessageBox(_dsValueError,
        "mdValueError",
        args, 
        ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNx, 715); ac++;
    XtSetArg(args[ac], XmNy, 803); ac++;
    XtSetArg(args[ac], XmNwidth, 44); ac++;
    XtSetArg(args[ac], XmNheight, 163); ac++;
    _dsReplaceValueError = XtCreatePopupShell("dsReplaceValueError",
        xmDialogShellWidgetClass,
        _CUIheaderEdit,
        args, 
        ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNdialogStyle, XmDIALOG_FULL_APPLICATION_MODAL); ac++;
    XtSetArg(args[ac], XmNdialogType, XmDIALOG_ERROR); ac++;
    _mdReplaceValueError = XmCreateMessageBox(_dsReplaceValueError,
        "mdReplaceValueError",
        args, 
        ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNx, 715); ac++;
    XtSetArg(args[ac], XmNy, 803); ac++;
    XtSetArg(args[ac], XmNwidth, 44); ac++;
    XtSetArg(args[ac], XmNheight, 163); ac++;
    _dsAddKeywordError = XtCreatePopupShell("dsAddKeywordError",
        xmDialogShellWidgetClass,
        _CUIheaderEdit,
        args, 
        ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNdialogStyle, XmDIALOG_FULL_APPLICATION_MODAL); ac++;
    XtSetArg(args[ac], XmNdialogType, XmDIALOG_ERROR); ac++;
    _mdAddKeywordError = XmCreateMessageBox(_dsAddKeywordError,
        "mdAddKeywordError",
        args, 
        ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNx, 715); ac++;
    XtSetArg(args[ac], XmNy, 803); ac++;
    XtSetArg(args[ac], XmNwidth, 44); ac++;
    XtSetArg(args[ac], XmNheight, 146); ac++;
    _dsDeleteKeywordError = XtCreatePopupShell("dsDeleteKeywordError",
        xmDialogShellWidgetClass,
        _CUIheaderEdit,
        args, 
        ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNdialogStyle, XmDIALOG_FULL_APPLICATION_MODAL); ac++;
    XtSetArg(args[ac], XmNdialogType, XmDIALOG_ERROR); ac++;
    _mdDeleteKeywordError = XmCreateMessageBox(_dsDeleteKeywordError,
        "mdDeleteKeywordError",
        args, 
        ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNx, 715); ac++;
    XtSetArg(args[ac], XmNy, 803); ac++;
    XtSetArg(args[ac], XmNwidth, 44); ac++;
    XtSetArg(args[ac], XmNheight, 146); ac++;
    _dsKeywordLengthError = XtCreatePopupShell("dsKeywordLengthError",
        xmDialogShellWidgetClass,
        _CUIheaderEdit,
        args, 
        ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNdialogStyle, XmDIALOG_FULL_APPLICATION_MODAL); ac++;
    XtSetArg(args[ac], XmNdialogType, XmDIALOG_ERROR); ac++;
    _mdKeywordLengthError = XmCreateMessageBox(_dsKeywordLengthError,
        "mdKeywordLengthError",
        args, 
        ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNx, 715); ac++;
    XtSetArg(args[ac], XmNy, 803); ac++;
    XtSetArg(args[ac], XmNwidth, 44); ac++;
    XtSetArg(args[ac], XmNheight, 1); ac++;
    _dsKeywordCharacterError = XtCreatePopupShell("dsKeywordCharacterError",
        xmDialogShellWidgetClass,
        _CUIheaderEdit,
        args, 
        ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNdialogStyle, XmDIALOG_FULL_APPLICATION_MODAL); ac++;
    XtSetArg(args[ac], XmNdialogType, XmDIALOG_ERROR); ac++;
    _mdKeywordCharacterError = XmCreateMessageBox(_dsKeywordCharacterError,
        "mdKeywordCharacterError",
        args, 
        ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNx, 373); ac++;
    XtSetArg(args[ac], XmNy, 714); ac++;
    XtSetArg(args[ac], XmNwidth, 685); ac++;
    XtSetArg(args[ac], XmNheight, 180); ac++;
    _dsProtectedKeywordWarning = XtCreatePopupShell("dsProtectedKeywordWarning",
        xmDialogShellWidgetClass,
        _CUIheaderEdit,
        args, 
        ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNdialogStyle, XmDIALOG_FULL_APPLICATION_MODAL); ac++;
    XtSetArg(args[ac], XmNdialogType, XmDIALOG_WARNING); ac++;
    _mdProtectedKeywordWarning = XmCreateMessageBox(_dsProtectedKeywordWarning,
        "mdProtectedKeywordWarning",
        args, 
        ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNresizePolicy, XmRESIZE_NONE); ac++;
    _foEdit = XmCreateForm(_CUIheaderEdit,
        "foEdit",
        args, 
        ac);
    XtManageChild(_foEdit);
    
    ac = 0;
    XtSetArg(args[ac], XmNlabelString, 
        BX_CONVERT(_foEdit, " ", 
        XmRXmString, 0, &argok)); if (argok) ac++;
    _lTab = XmCreateLabel(_foEdit,
        "lTab",
        args, 
        ac);
    XtManageChild(_lTab);
    
    ac = 0;
    XtSetArg(args[ac], XmNverticalSpacing, 10); ac++;
    XtSetArg(args[ac], XmNhorizontalSpacing, 655360); ac++;
    XtSetArg(args[ac], XmNshadowType, XmSHADOW_IN); ac++;
    XtSetArg(args[ac], XmNshadowThickness, 1); ac++;
    XtSetArg(args[ac], XmNy, 0); ac++;
    _foPageMisc = XmCreateForm(_foEdit,
        "foPageMisc",
        args, 
        ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNx, 453); ac++;
    XtSetArg(args[ac], XmNy, 418); ac++;
    XtSetArg(args[ac], XmNwidth, 93); ac++;
    _pbDeleteKeyword = XmCreatePushButton(_foPageMisc,
        "pbDeleteKeyword",
        args, 
        ac);
    XtManageChild(_pbDeleteKeyword);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbDeleteKeyword,
        XmNactivateCallback,
        CUIheaderEdit::DeleteKeywordCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    XtSetArg(args[ac], XmNx, 267); ac++;
    XtSetArg(args[ac], XmNy, 418); ac++;
    XtSetArg(args[ac], XmNwidth, 93); ac++;
    _pbReplaceValue = XmCreatePushButton(_foPageMisc,
        "pbReplaceValue",
        args, 
        ac);
    XtManageChild(_pbReplaceValue);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbReplaceValue,
        XmNactivateCallback,
        CUIheaderEdit::ReplaceValueCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    XtSetArg(args[ac], XmNx, 81); ac++;
    XtSetArg(args[ac], XmNy, 418); ac++;
    XtSetArg(args[ac], XmNwidth, 93); ac++;
    _pbAddKeyword = XmCreatePushButton(_foPageMisc,
        "pbAddKeyword",
        args, 
        ac);
    XtManageChild(_pbAddKeyword);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbAddKeyword,
        XmNactivateCallback,
        CUIheaderEdit::AddKeywordCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    _lValue = XmCreateLabel(_foPageMisc,
        "lValue",
        args, 
        ac);
    XtManageChild(_lValue);
    
    ac = 0;
    XtSetArg(args[ac], XmNscrollingPolicy, XmAPPLICATION_DEFINED); ac++;
    _swValue = XmCreateScrolledWindow(_foPageMisc,
        "swValue",
        args, 
        ac);
    XtManageChild(_swValue);
    
    ac = 0;
    XtSetArg(args[ac], XmNeditMode, XmMULTI_LINE_EDIT); ac++;
    XtSetArg(args[ac], XmNrows, 15); ac++;
    _tValue = XmCreateText(_swValue,
        "tValue",
        args, 
        ac);
    XtManageChild(_tValue);
    
    ac = 0;
    _lHeader = XmCreateLabel(_foPageMisc,
        "lHeader",
        args, 
        ac);
    XtManageChild(_lHeader);
    
    ac = 0;
    XtSetArg(args[ac], XmNcolumns, 32); ac++;
    _tfKeyword = XmCreateTextField(_foPageMisc,
        "tfKeyword",
        args, 
        ac);
    XtManageChild(_tfKeyword);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tfKeyword,
        XmNvalueChangedCallback,
        CUIheaderEdit::KeywordChangedCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tfKeyword,
        XmNactivateCallback,
        CUIheaderEdit::KeywordChangedCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    _seMain = XmCreateSeparator(_foPageMisc,
        "seMain",
        args, 
        ac);
    XtManageChild(_seMain);
    
    ac = 0;
    _lKeyword = XmCreateLabel(_foPageMisc,
        "lKeyword",
        args, 
        ac);
    XtManageChild(_lKeyword);
    
    ac = 0;
    XtSetArg(args[ac], XmNscrollingPolicy, XmAPPLICATION_DEFINED); ac++;
    _swHeader = XmCreateScrolledWindow(_foPageMisc,
        "swHeader",
        args, 
        ac);
    XtManageChild(_swHeader);
    
    ac = 0;
    XtSetArg(args[ac], XmNvisibleItemCount, 18); ac++;
    XtSetArg(args[ac], XmNselectionPolicy, XmBROWSE_SELECT); ac++;
    XtSetArg(args[ac], XmNlistSizePolicy, XmCONSTANT); ac++;
    _liHeader = XmCreateList(_swHeader,
        "liHeader",
        args, 
        ac);
    XtManageChild(_liHeader);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_liHeader,
        XmNbrowseSelectionCallback,
        CUIheaderEdit::KeywordSelectedCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    XtSetArg(args[ac], XmNverticalSpacing, 10); ac++;
    XtSetArg(args[ac], XmNhorizontalSpacing, 655360); ac++;
    XtSetArg(args[ac], XmNshadowType, XmSHADOW_IN); ac++;
    XtSetArg(args[ac], XmNshadowThickness, 1); ac++;
    XtSetArg(args[ac], XmNresizePolicy, XmRESIZE_ANY); ac++;
    XtSetArg(args[ac], XmNx, 10); ac++;
    XtSetArg(args[ac], XmNy, 37); ac++;
    _foPageCryst = XmCreateForm(_foEdit,
        "foPageCryst",
        args, 
        ac);
    XtManageChild(_foPageCryst);
    
    ac = 0;
    XtSetArg(args[ac], XmNheight, 145); ac++;
    _frCrystComment = XmCreateFrame(_foPageCryst,
        "frCrystComment",
        args, 
        ac);
    XtManageChild(_frCrystComment);
    
    ac = 0;
    XtSetArg(args[ac], XmNlabelString, 
        BX_CONVERT(_frCrystComment, "Comment", 
        XmRXmString, 0, &argok)); if (argok) ac++;
    XtSetArg(args[ac], XmNchildType, XmFRAME_TITLE_CHILD); ac++;
    XtSetArg(args[ac], XmNx, 13); ac++;
    XtSetArg(args[ac], XmNy, 0); ac++;
    _lCrystComment = XmCreateLabel(_frCrystComment,
        "lCrystComment",
        args, 
        ac);
    XtManageChild(_lCrystComment);
    
    ac = 0;
    XtSetArg(args[ac], XmNscrollingPolicy, XmAPPLICATION_DEFINED); ac++;
    XtSetArg(args[ac], XmNx, 3); ac++;
    XtSetArg(args[ac], XmNy, 25); ac++;
    XtSetArg(args[ac], XmNwidth, 419); ac++;
    XtSetArg(args[ac], XmNheight, 117); ac++;
    _swCrystComment = XmCreateScrolledWindow(_frCrystComment,
        "swCrystComment",
        args, 
        ac);
    XtManageChild(_swCrystComment);
    
    ac = 0;
    XtSetArg(args[ac], XmNeditMode, XmMULTI_LINE_EDIT); ac++;
    XtSetArg(args[ac], XmNrows, 4); ac++;
    _tCrystComment = XmCreateText(_swCrystComment,
        "tCrystComment",
        args, 
        ac);
    XtManageChild(_tCrystComment);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)"losing";
    XtAddCallback(_tCrystComment,
        XmNlosingFocusCallback,
        CUIheaderEdit::ChangeCommentCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    _frCrystSpaceGroup = XmCreateFrame(_foPageCryst,
        "frCrystSpaceGroup",
        args, 
        ac);
    XtManageChild(_frCrystSpaceGroup);
    
    ac = 0;
    XtSetArg(args[ac], XmNchildType, XmFRAME_TITLE_CHILD); ac++;
    XtSetArg(args[ac], XmNx, 13); ac++;
    XtSetArg(args[ac], XmNy, 0); ac++;
    _lCrystSpaceGroup = XmCreateLabel(_frCrystSpaceGroup,
        "lCrystSpaceGroup",
        args, 
        ac);
    XtManageChild(_lCrystSpaceGroup);
    
    ac = 0;
    XtSetArg(args[ac], XmNnumColumns, 1); ac++;
    XtSetArg(args[ac], XmNpacking, XmPACK_TIGHT); ac++;
    XtSetArg(args[ac], XmNorientation, XmHORIZONTAL); ac++;
    XtSetArg(args[ac], XmNx, 3); ac++;
    XtSetArg(args[ac], XmNy, 25); ac++;
    _rcCrystSpaceGroup = XmCreateRowColumn(_frCrystSpaceGroup,
        "rcCrystSpaceGroup",
        args, 
        ac);
    XtManageChild(_rcCrystSpaceGroup);
    
    ac = 0;
    _lCrystSpaceGroupName = XmCreateLabel(_rcCrystSpaceGroup,
        "lCrystSpaceGroupName",
        args, 
        ac);
    XtManageChild(_lCrystSpaceGroupName);
    
    ac = 0;
    XtSetArg(args[ac], XmNcolumns, 8); ac++;
    _tfCrystSpaceGroupName = XmCreateTextField(_rcCrystSpaceGroup,
        "tfCrystSpaceGroupName",
        args, 
        ac);
    XtManageChild(_tfCrystSpaceGroupName);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tfCrystSpaceGroupName,
        XmNlosingFocusCallback,
        CUIheaderEdit::ChangeCrystSpaceGroupCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tfCrystSpaceGroupName,
        XmNactivateCallback,
        CUIheaderEdit::ChangeCrystSpaceGroupCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    _lCrystSpaceGroupNumber = XmCreateLabel(_rcCrystSpaceGroup,
        "lCrystSpaceGroupNumber",
        args, 
        ac);
    XtManageChild(_lCrystSpaceGroupNumber);
    
    ac = 0;
    XtSetArg(args[ac], XmNcolumns, 4); ac++;
    _tfCrystSpaceGroupNumber = XmCreateTextField(_rcCrystSpaceGroup,
        "tfCrystSpaceGroupNumber",
        args, 
        ac);
    XtManageChild(_tfCrystSpaceGroupNumber);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tfCrystSpaceGroupNumber,
        XmNlosingFocusCallback,
        CUIheaderEdit::ChangeCrystSpaceGroupCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tfCrystSpaceGroupNumber,
        XmNactivateCallback,
        CUIheaderEdit::ChangeCrystSpaceGroupCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    _frCrystMosaicity = XmCreateFrame(_foPageCryst,
        "frCrystMosaicity",
        args, 
        ac);
    XtManageChild(_frCrystMosaicity);
    
    ac = 0;
    XtSetArg(args[ac], XmNchildType, XmFRAME_TITLE_CHILD); ac++;
    XtSetArg(args[ac], XmNx, 13); ac++;
    XtSetArg(args[ac], XmNy, 0); ac++;
    _lCrystMosaicity = XmCreateLabel(_frCrystMosaicity,
        "lCrystMosaicity",
        args, 
        ac);
    XtManageChild(_lCrystMosaicity);
    
    ac = 0;
    XtSetArg(args[ac], XmNcolumns, 8); ac++;
    XtSetArg(args[ac], XmNx, 3); ac++;
    XtSetArg(args[ac], XmNy, 25); ac++;
    _tfCrystMosaicity = XmCreateTextField(_frCrystMosaicity,
        "tfCrystMosaicity",
        args, 
        ac);
    XtManageChild(_tfCrystMosaicity);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tfCrystMosaicity,
        XmNlosingFocusCallback,
        CUIheaderEdit::ChangeCrystMosaicityCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tfCrystMosaicity,
        XmNactivateCallback,
        CUIheaderEdit::ChangeCrystMosaicityCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    _frCrystOrient = XmCreateFrame(_foPageCryst,
        "frCrystOrient",
        args, 
        ac);
    XtManageChild(_frCrystOrient);
    
    ac = 0;
    XtSetArg(args[ac], XmNchildType, XmFRAME_TITLE_CHILD); ac++;
    XtSetArg(args[ac], XmNx, 13); ac++;
    XtSetArg(args[ac], XmNy, 0); ac++;
    _lCrystOrient = XmCreateLabel(_frCrystOrient,
        "lCrystOrient",
        args, 
        ac);
    XtManageChild(_lCrystOrient);
    
    ac = 0;
    XtSetArg(args[ac], XmNnumColumns, 2); ac++;
    XtSetArg(args[ac], XmNentryAlignment, XmALIGNMENT_CENTER); ac++;
    XtSetArg(args[ac], XmNpacking, XmPACK_COLUMN); ac++;
    XtSetArg(args[ac], XmNorientation, XmHORIZONTAL); ac++;
    XtSetArg(args[ac], XmNx, 3); ac++;
    XtSetArg(args[ac], XmNy, 25); ac++;
    _rcCrystOrient = XmCreateRowColumn(_frCrystOrient,
        "rcCrystOrient",
        args, 
        ac);
    XtManageChild(_rcCrystOrient);
    
    ac = 0;
    XtSetArg(args[ac], XmNalignment, XmALIGNMENT_CENTER); ac++;
    _lCrystOrient1 = XmCreateLabel(_rcCrystOrient,
        "lCrystOrient1",
        args, 
        ac);
    XtManageChild(_lCrystOrient1);
    
    ac = 0;
    XtSetArg(args[ac], XmNalignment, XmALIGNMENT_CENTER); ac++;
    _lCrystOrient2 = XmCreateLabel(_rcCrystOrient,
        "lCrystOrient2",
        args, 
        ac);
    XtManageChild(_lCrystOrient2);
    
    ac = 0;
    XtSetArg(args[ac], XmNalignment, XmALIGNMENT_CENTER); ac++;
    XtSetArg(args[ac], XmNlabelString, 
        BX_CONVERT(_rcCrystOrient, "Rot3", 
        XmRXmString, 0, &argok)); if (argok) ac++;
    _lCrystOrient3 = XmCreateLabel(_rcCrystOrient,
        "lCrystOrient3",
        args, 
        ac);
    XtManageChild(_lCrystOrient3);
    
    ac = 0;
    XtSetArg(args[ac], XmNcolumns, 8); ac++;
    _tfCrystOrient1 = XmCreateTextField(_rcCrystOrient,
        "tfCrystOrient1",
        args, 
        ac);
    XtManageChild(_tfCrystOrient1);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tfCrystOrient1,
        XmNlosingFocusCallback,
        CUIheaderEdit::ChangeCrystOrientCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tfCrystOrient1,
        XmNactivateCallback,
        CUIheaderEdit::ChangeCrystOrientCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    XtSetArg(args[ac], XmNcolumns, 8); ac++;
    _tfCrystOrient2 = XmCreateTextField(_rcCrystOrient,
        "tfCrystOrient2",
        args, 
        ac);
    XtManageChild(_tfCrystOrient2);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tfCrystOrient2,
        XmNlosingFocusCallback,
        CUIheaderEdit::ChangeCrystOrientCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tfCrystOrient2,
        XmNactivateCallback,
        CUIheaderEdit::ChangeCrystOrientCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    XtSetArg(args[ac], XmNcolumns, 8); ac++;
    _tfCrystOrient3 = XmCreateTextField(_rcCrystOrient,
        "tfCrystOrient3",
        args, 
        ac);
    XtManageChild(_tfCrystOrient3);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tfCrystOrient3,
        XmNlosingFocusCallback,
        CUIheaderEdit::ChangeCrystOrientCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tfCrystOrient3,
        XmNactivateCallback,
        CUIheaderEdit::ChangeCrystOrientCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    _frUnitCell = XmCreateFrame(_foPageCryst,
        "frUnitCell",
        args, 
        ac);
    XtManageChild(_frUnitCell);
    
    ac = 0;
    XtSetArg(args[ac], XmNchildType, XmFRAME_TITLE_CHILD); ac++;
    XtSetArg(args[ac], XmNx, 13); ac++;
    XtSetArg(args[ac], XmNy, 0); ac++;
    _lCrystUnitCell = XmCreateLabel(_frUnitCell,
        "lCrystUnitCell",
        args, 
        ac);
    XtManageChild(_lCrystUnitCell);
    
    ac = 0;
    XtSetArg(args[ac], XmNnumColumns, 4); ac++;
    XtSetArg(args[ac], XmNentryAlignment, XmALIGNMENT_CENTER); ac++;
    XtSetArg(args[ac], XmNpacking, XmPACK_COLUMN); ac++;
    XtSetArg(args[ac], XmNorientation, XmHORIZONTAL); ac++;
    XtSetArg(args[ac], XmNx, 3); ac++;
    XtSetArg(args[ac], XmNy, 25); ac++;
    _rcCrystUnitCell = XmCreateRowColumn(_frUnitCell,
        "rcCrystUnitCell",
        args, 
        ac);
    XtManageChild(_rcCrystUnitCell);
    
    ac = 0;
    XtSetArg(args[ac], XmNalignment, XmALIGNMENT_CENTER); ac++;
    _lCrystUnitCellA = XmCreateLabel(_rcCrystUnitCell,
        "lCrystUnitCellA",
        args, 
        ac);
    XtManageChild(_lCrystUnitCellA);
    
    ac = 0;
    XtSetArg(args[ac], XmNalignment, XmALIGNMENT_CENTER); ac++;
    _lCrystUnitCellB = XmCreateLabel(_rcCrystUnitCell,
        "lCrystUnitCellB",
        args, 
        ac);
    XtManageChild(_lCrystUnitCellB);
    
    ac = 0;
    XtSetArg(args[ac], XmNalignment, XmALIGNMENT_CENTER); ac++;
    _lCrystUnitCellC = XmCreateLabel(_rcCrystUnitCell,
        "lCrystUnitCellC",
        args, 
        ac);
    XtManageChild(_lCrystUnitCellC);
    
    ac = 0;
    XtSetArg(args[ac], XmNcolumns, 8); ac++;
    _tfCrystUnitCellA = XmCreateTextField(_rcCrystUnitCell,
        "tfCrystUnitCellA",
        args, 
        ac);
    XtManageChild(_tfCrystUnitCellA);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tfCrystUnitCellA,
        XmNlosingFocusCallback,
        CUIheaderEdit::ChangeUnitCellCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tfCrystUnitCellA,
        XmNactivateCallback,
        CUIheaderEdit::ChangeUnitCellCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    XtSetArg(args[ac], XmNcolumns, 8); ac++;
    _tfCrystUnitCellB = XmCreateTextField(_rcCrystUnitCell,
        "tfCrystUnitCellB",
        args, 
        ac);
    XtManageChild(_tfCrystUnitCellB);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tfCrystUnitCellB,
        XmNlosingFocusCallback,
        CUIheaderEdit::ChangeUnitCellCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tfCrystUnitCellB,
        XmNactivateCallback,
        CUIheaderEdit::ChangeUnitCellCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    XtSetArg(args[ac], XmNcolumns, 8); ac++;
    _tfCrystUnitCellC = XmCreateTextField(_rcCrystUnitCell,
        "tfCrystUnitCellC",
        args, 
        ac);
    XtManageChild(_tfCrystUnitCellC);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tfCrystUnitCellC,
        XmNlosingFocusCallback,
        CUIheaderEdit::ChangeUnitCellCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tfCrystUnitCellC,
        XmNactivateCallback,
        CUIheaderEdit::ChangeUnitCellCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    XtSetArg(args[ac], XmNalignment, XmALIGNMENT_CENTER); ac++;
    _lCrystUnitCellAlpha = XmCreateLabel(_rcCrystUnitCell,
        "lCrystUnitCellAlpha",
        args, 
        ac);
    XtManageChild(_lCrystUnitCellAlpha);
    
    ac = 0;
    XtSetArg(args[ac], XmNalignment, XmALIGNMENT_CENTER); ac++;
    _lCrystUnitCellBeta = XmCreateLabel(_rcCrystUnitCell,
        "lCrystUnitCellBeta",
        args, 
        ac);
    XtManageChild(_lCrystUnitCellBeta);
    
    ac = 0;
    XtSetArg(args[ac], XmNalignment, XmALIGNMENT_CENTER); ac++;
    _lCrystUnitCellGamma = XmCreateLabel(_rcCrystUnitCell,
        "lCrystUnitCellGamma",
        args, 
        ac);
    XtManageChild(_lCrystUnitCellGamma);
    
    ac = 0;
    XtSetArg(args[ac], XmNcolumns, 8); ac++;
    _tfCrystUnitCellAlpha = XmCreateTextField(_rcCrystUnitCell,
        "tfCrystUnitCellAlpha",
        args, 
        ac);
    XtManageChild(_tfCrystUnitCellAlpha);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tfCrystUnitCellAlpha,
        XmNlosingFocusCallback,
        CUIheaderEdit::ChangeUnitCellCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tfCrystUnitCellAlpha,
        XmNactivateCallback,
        CUIheaderEdit::ChangeUnitCellCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    XtSetArg(args[ac], XmNcolumns, 8); ac++;
    _tfCrystUnitCellBeta = XmCreateTextField(_rcCrystUnitCell,
        "tfCrystUnitCellBeta",
        args, 
        ac);
    XtManageChild(_tfCrystUnitCellBeta);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tfCrystUnitCellBeta,
        XmNlosingFocusCallback,
        CUIheaderEdit::ChangeUnitCellCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tfCrystUnitCellBeta,
        XmNactivateCallback,
        CUIheaderEdit::ChangeUnitCellCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    XtSetArg(args[ac], XmNcolumns, 8); ac++;
    _tfCrystUnitCellGamma = XmCreateTextField(_rcCrystUnitCell,
        "tfCrystUnitCellGamma",
        args, 
        ac);
    XtManageChild(_tfCrystUnitCellGamma);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tfCrystUnitCellGamma,
        XmNlosingFocusCallback,
        CUIheaderEdit::ChangeUnitCellCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tfCrystUnitCellGamma,
        XmNactivateCallback,
        CUIheaderEdit::ChangeUnitCellCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    XtSetArg(args[ac], XmNshadowType, XmSHADOW_IN); ac++;
    XtSetArg(args[ac], XmNshadowThickness, 1); ac++;
    _foPageDet = XmCreateForm(_foEdit,
        "foPageDet",
        args, 
        ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNheight, 65); ac++;
    _frDetDirectBeam = XmCreateFrame(_foPageDet,
        "frDetDirectBeam",
        args, 
        ac);
    XtManageChild(_frDetDirectBeam);
    
    ac = 0;
    XtSetArg(args[ac], XmNorientation, XmHORIZONTAL); ac++;
    XtSetArg(args[ac], XmNchildType, XmFRAME_WORKAREA_CHILD); ac++;
    XtSetArg(args[ac], XmNx, 3); ac++;
    XtSetArg(args[ac], XmNy, 26); ac++;
    XtSetArg(args[ac], XmNwidth, 307); ac++;
    XtSetArg(args[ac], XmNheight, 36); ac++;
    _rcDetDirectBeam = XmCreateRowColumn(_frDetDirectBeam,
        "rcDetDirectBeam",
        args, 
        ac);
    XtManageChild(_rcDetDirectBeam);
    
    ac = 0;
    XtSetArg(args[ac], XmNwidth, 32); ac++;
    XtSetArg(args[ac], XmNheight, 30); ac++;
    _lDetDirectBeamX = XmCreateLabel(_rcDetDirectBeam,
        "lDetDirectBeamX",
        args, 
        ac);
    XtManageChild(_lDetDirectBeamX);
    
    ac = 0;
    XtSetArg(args[ac], XmNcolumns, 8); ac++;
    XtSetArg(args[ac], XmNheight, 30); ac++;
    _tfDetDirectBeamX = XmCreateTextField(_rcDetDirectBeam,
        "tfDetDirectBeamX",
        args, 
        ac);
    XtManageChild(_tfDetDirectBeamX);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tfDetDirectBeamX,
        XmNlosingFocusCallback,
        CUIheaderEdit::ChangeDirectBeamCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tfDetDirectBeamX,
        XmNactivateCallback,
        CUIheaderEdit::ChangeDirectBeamCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    XtSetArg(args[ac], XmNwidth, 32); ac++;
    XtSetArg(args[ac], XmNheight, 30); ac++;
    _lDetDirectBeamY = XmCreateLabel(_rcDetDirectBeam,
        "lDetDirectBeamY",
        args, 
        ac);
    XtManageChild(_lDetDirectBeamY);
    
    ac = 0;
    XtSetArg(args[ac], XmNcolumns, 8); ac++;
    _tfDetDirectBeamY = XmCreateTextField(_rcDetDirectBeam,
        "tfDetDirectBeamY",
        args, 
        ac);
    XtManageChild(_tfDetDirectBeamY);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tfDetDirectBeamY,
        XmNlosingFocusCallback,
        CUIheaderEdit::ChangeDirectBeamCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tfDetDirectBeamY,
        XmNactivateCallback,
        CUIheaderEdit::ChangeDirectBeamCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    XtSetArg(args[ac], XmNchildType, XmFRAME_TITLE_CHILD); ac++;
    XtSetArg(args[ac], XmNx, 13); ac++;
    XtSetArg(args[ac], XmNy, 0); ac++;
    XtSetArg(args[ac], XmNwidth, 154); ac++;
    XtSetArg(args[ac], XmNheight, 26); ac++;
    _lDetDirectBeam = XmCreateLabel(_frDetDirectBeam,
        "lDetDirectBeam",
        args, 
        ac);
    XtManageChild(_lDetDirectBeam);
    
    ac = 0;
    _frDetRot = XmCreateFrame(_foPageDet,
        "frDetRot",
        args, 
        ac);
    XtManageChild(_frDetRot);
    
    ac = 0;
    XtSetArg(args[ac], XmNnumColumns, 2); ac++;
    XtSetArg(args[ac], XmNentryAlignment, XmALIGNMENT_CENTER); ac++;
    XtSetArg(args[ac], XmNpacking, XmPACK_COLUMN); ac++;
    XtSetArg(args[ac], XmNorientation, XmHORIZONTAL); ac++;
    XtSetArg(args[ac], XmNx, 3); ac++;
    XtSetArg(args[ac], XmNy, 25); ac++;
    _rcDetRot = XmCreateRowColumn(_frDetRot,
        "rcDetRot",
        args, 
        ac);
    XtManageChild(_rcDetRot);
    
    ac = 0;
    XtSetArg(args[ac], XmNalignment, XmALIGNMENT_CENTER); ac++;
    _lDetRot1 = XmCreateLabel(_rcDetRot,
        "lDetRot1",
        args, 
        ac);
    XtManageChild(_lDetRot1);
    
    ac = 0;
    XtSetArg(args[ac], XmNalignment, XmALIGNMENT_CENTER); ac++;
    _lDetRot2 = XmCreateLabel(_rcDetRot,
        "lDetRot2",
        args, 
        ac);
    XtManageChild(_lDetRot2);
    
    ac = 0;
    XtSetArg(args[ac], XmNalignment, XmALIGNMENT_CENTER); ac++;
    _lDetRot3 = XmCreateLabel(_rcDetRot,
        "lDetRot3",
        args, 
        ac);
    XtManageChild(_lDetRot3);
    
    ac = 0;
    XtSetArg(args[ac], XmNcolumns, 8); ac++;
    _tfDetRot1 = XmCreateTextField(_rcDetRot,
        "tfDetRot1",
        args, 
        ac);
    XtManageChild(_tfDetRot1);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tfDetRot1,
        XmNlosingFocusCallback,
        CUIheaderEdit::ChangeDetGonioCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tfDetRot1,
        XmNactivateCallback,
        CUIheaderEdit::ChangeDetGonioCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    XtSetArg(args[ac], XmNcolumns, 8); ac++;
    _tfDetRot2 = XmCreateTextField(_rcDetRot,
        "tfDetRot2",
        args, 
        ac);
    XtManageChild(_tfDetRot2);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tfDetRot2,
        XmNlosingFocusCallback,
        CUIheaderEdit::ChangeDetGonioCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tfDetRot2,
        XmNactivateCallback,
        CUIheaderEdit::ChangeDetGonioCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    XtSetArg(args[ac], XmNcolumns, 8); ac++;
    _tfDetRot3 = XmCreateTextField(_rcDetRot,
        "tfDetRot3",
        args, 
        ac);
    XtManageChild(_tfDetRot3);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tfDetRot3,
        XmNlosingFocusCallback,
        CUIheaderEdit::ChangeDetGonioCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tfDetRot3,
        XmNactivateCallback,
        CUIheaderEdit::ChangeDetGonioCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    XtSetArg(args[ac], XmNchildType, XmFRAME_TITLE_CHILD); ac++;
    XtSetArg(args[ac], XmNx, 13); ac++;
    XtSetArg(args[ac], XmNy, 0); ac++;
    _lDetRot = XmCreateLabel(_frDetRot,
        "lDetRot",
        args, 
        ac);
    XtManageChild(_lDetRot);
    
    ac = 0;
    _frDetTrans = XmCreateFrame(_foPageDet,
        "frDetTrans",
        args, 
        ac);
    XtManageChild(_frDetTrans);
    
    ac = 0;
    XtSetArg(args[ac], XmNnumColumns, 2); ac++;
    XtSetArg(args[ac], XmNentryAlignment, XmALIGNMENT_CENTER); ac++;
    XtSetArg(args[ac], XmNpacking, XmPACK_COLUMN); ac++;
    XtSetArg(args[ac], XmNorientation, XmHORIZONTAL); ac++;
    XtSetArg(args[ac], XmNx, 3); ac++;
    XtSetArg(args[ac], XmNy, 25); ac++;
    _rcDetTrans = XmCreateRowColumn(_frDetTrans,
        "rcDetTrans",
        args, 
        ac);
    XtManageChild(_rcDetTrans);
    
    ac = 0;
    XtSetArg(args[ac], XmNalignment, XmALIGNMENT_CENTER); ac++;
    _lDetTrans1 = XmCreateLabel(_rcDetTrans,
        "lDetTrans1",
        args, 
        ac);
    XtManageChild(_lDetTrans1);
    
    ac = 0;
    XtSetArg(args[ac], XmNalignment, XmALIGNMENT_CENTER); ac++;
    _lDetTrans2 = XmCreateLabel(_rcDetTrans,
        "lDetTrans2",
        args, 
        ac);
    XtManageChild(_lDetTrans2);
    
    ac = 0;
    XtSetArg(args[ac], XmNalignment, XmALIGNMENT_CENTER); ac++;
    _lDetTrans3 = XmCreateLabel(_rcDetTrans,
        "lDetTrans3",
        args, 
        ac);
    XtManageChild(_lDetTrans3);
    
    ac = 0;
    XtSetArg(args[ac], XmNcolumns, 8); ac++;
    _tfDetTrans1 = XmCreateTextField(_rcDetTrans,
        "tfDetTrans1",
        args, 
        ac);
    XtManageChild(_tfDetTrans1);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tfDetTrans1,
        XmNlosingFocusCallback,
        CUIheaderEdit::ChangeDetGonioCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tfDetTrans1,
        XmNactivateCallback,
        CUIheaderEdit::ChangeDetGonioCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    XtSetArg(args[ac], XmNcolumns, 8); ac++;
    _tfDetTrans2 = XmCreateTextField(_rcDetTrans,
        "tfDetTrans2",
        args, 
        ac);
    XtManageChild(_tfDetTrans2);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tfDetTrans2,
        XmNlosingFocusCallback,
        CUIheaderEdit::ChangeDetGonioCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tfDetTrans2,
        XmNactivateCallback,
        CUIheaderEdit::ChangeDetGonioCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    XtSetArg(args[ac], XmNcolumns, 8); ac++;
    _tfDetTrans3 = XmCreateTextField(_rcDetTrans,
        "tfDetTrans3",
        args, 
        ac);
    XtManageChild(_tfDetTrans3);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tfDetTrans3,
        XmNlosingFocusCallback,
        CUIheaderEdit::ChangeDetGonioCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tfDetTrans3,
        XmNactivateCallback,
        CUIheaderEdit::ChangeDetGonioCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    XtSetArg(args[ac], XmNchildType, XmFRAME_TITLE_CHILD); ac++;
    XtSetArg(args[ac], XmNx, 13); ac++;
    XtSetArg(args[ac], XmNy, 0); ac++;
    _lDetTrans = XmCreateLabel(_frDetTrans,
        "lDetTrans",
        args, 
        ac);
    XtManageChild(_lDetTrans);
    
    ac = 0;
    XtSetArg(args[ac], XmNshadowType, XmSHADOW_IN); ac++;
    XtSetArg(args[ac], XmNshadowThickness, 1); ac++;
    _foPageSource = XmCreateForm(_foEdit,
        "foPageSource",
        args, 
        ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNheight, 69); ac++;
    _frSourceRot = XmCreateFrame(_foPageSource,
        "frSourceRot",
        args, 
        ac);
    XtManageChild(_frSourceRot);
    
    ac = 0;
    XtSetArg(args[ac], XmNchildType, XmFRAME_TITLE_CHILD); ac++;
    XtSetArg(args[ac], XmNx, 13); ac++;
    XtSetArg(args[ac], XmNy, 0); ac++;
    _lSourceRot = XmCreateLabel(_frSourceRot,
        "lSourceRot",
        args, 
        ac);
    XtManageChild(_lSourceRot);
    
    ac = 0;
    XtSetArg(args[ac], XmNorientation, XmHORIZONTAL); ac++;
    XtSetArg(args[ac], XmNx, 3); ac++;
    XtSetArg(args[ac], XmNy, 25); ac++;
    XtSetArg(args[ac], XmNwidth, 237); ac++;
    XtSetArg(args[ac], XmNheight, 41); ac++;
    _rcSourceRot = XmCreateRowColumn(_frSourceRot,
        "rcSourceRot",
        args, 
        ac);
    XtManageChild(_rcSourceRot);
    
    ac = 0;
    XtSetArg(args[ac], XmNcolumns, 8); ac++;
    _tfSourceRot1 = XmCreateTextField(_rcSourceRot,
        "tfSourceRot1",
        args, 
        ac);
    XtManageChild(_tfSourceRot1);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tfSourceRot1,
        XmNlosingFocusCallback,
        CUIheaderEdit::ChangeSourceRotCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tfSourceRot1,
        XmNactivateCallback,
        CUIheaderEdit::ChangeSourceRotCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    XtSetArg(args[ac], XmNcolumns, 8); ac++;
    _tfSourceRot2 = XmCreateTextField(_rcSourceRot,
        "tfSourceRot2",
        args, 
        ac);
    XtManageChild(_tfSourceRot2);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tfSourceRot2,
        XmNlosingFocusCallback,
        CUIheaderEdit::ChangeSourceRotCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tfSourceRot2,
        XmNactivateCallback,
        CUIheaderEdit::ChangeSourceRotCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    _frSourceWavelength = XmCreateFrame(_foPageSource,
        "frSourceWavelength",
        args, 
        ac);
    XtManageChild(_frSourceWavelength);
    
    ac = 0;
    XtSetArg(args[ac], XmNchildType, XmFRAME_TITLE_CHILD); ac++;
    XtSetArg(args[ac], XmNx, 13); ac++;
    XtSetArg(args[ac], XmNy, 0); ac++;
    _lSourceWavelength = XmCreateLabel(_frSourceWavelength,
        "lSourceWavelength",
        args, 
        ac);
    XtManageChild(_lSourceWavelength);
    
    ac = 0;
    XtSetArg(args[ac], XmNcolumns, 8); ac++;
    XtSetArg(args[ac], XmNx, 3); ac++;
    XtSetArg(args[ac], XmNy, 25); ac++;
    _tfSourceWavelength = XmCreateTextField(_frSourceWavelength,
        "tfSourceWavelength",
        args, 
        ac);
    XtManageChild(_tfSourceWavelength);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tfSourceWavelength,
        XmNlosingFocusCallback,
        CUIheaderEdit::ChangeSourceWavelengthCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tfSourceWavelength,
        XmNactivateCallback,
        CUIheaderEdit::ChangeSourceWavelengthCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    XtSetArg(args[ac], XmNshadowThickness, 1); ac++;
    XtSetArg(args[ac], XmNx, 416); ac++;
    XtSetArg(args[ac], XmNy, 0); ac++;
    _pbPageMisc = XmCreatePushButton(_foEdit,
        "pbPageMisc",
        args, 
        ac);
    XtManageChild(_pbPageMisc);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbPageMisc,
        XmNactivateCallback,
        CUIheaderEdit::ChangeMenuCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    XtSetArg(args[ac], XmNshadowThickness, 1); ac++;
    XtSetArg(args[ac], XmNhighlightThickness, 0); ac++;
    XtSetArg(args[ac], XmNx, 30); ac++;
    XtSetArg(args[ac], XmNy, 0); ac++;
    _pbPageCryst = XmCreatePushButton(_foEdit,
        "pbPageCryst",
        args, 
        ac);
    XtManageChild(_pbPageCryst);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbPageCryst,
        XmNactivateCallback,
        CUIheaderEdit::ChangeMenuCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    XtSetArg(args[ac], XmNshadowThickness, 1); ac++;
    XtSetArg(args[ac], XmNx, 156); ac++;
    XtSetArg(args[ac], XmNy, 0); ac++;
    _pbPageDet = XmCreatePushButton(_foEdit,
        "pbPageDet",
        args, 
        ac);
    XtManageChild(_pbPageDet);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbPageDet,
        XmNactivateCallback,
        CUIheaderEdit::ChangeMenuCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    XtSetArg(args[ac], XmNshadowThickness, 1); ac++;
    XtSetArg(args[ac], XmNx, 286); ac++;
    XtSetArg(args[ac], XmNy, 0); ac++;
    _pbPageSource = XmCreatePushButton(_foEdit,
        "pbPageSource",
        args, 
        ac);
    XtManageChild(_pbPageSource);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbPageSource,
        XmNactivateCallback,
        CUIheaderEdit::ChangeMenuCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    ac = 0;
    XtSetArg(args[ac], XmNtopAttachment, XmATTACH_WIDGET); ac++;
    XtSetArg(args[ac], XmNrightAttachment, XmATTACH_OPPOSITE_WIDGET); ac++;
    XtSetArg(args[ac], XmNleftAttachment, XmATTACH_OPPOSITE_WIDGET); ac++;
    XtSetArg(args[ac], XmNbottomAttachment, XmATTACH_OPPOSITE_WIDGET); ac++;
    XtSetArg(args[ac], XmNbottomOffset, 0); ac++;
    XtSetArg(args[ac], XmNbottomWidget, _pbPageCryst); ac++;
    XtSetArg(args[ac], XmNleftOffset, 0); ac++;
    XtSetArg(args[ac], XmNrightOffset, 0); ac++;
    XtSetArg(args[ac], XmNtopOffset, -3); ac++;
    XtSetArg(args[ac], XmNleftWidget, _pbPageCryst); ac++;
    XtSetArg(args[ac], XmNrightWidget, _pbPageCryst); ac++;
    XtSetArg(args[ac], XmNtopWidget, _pbPageCryst); ac++;
    XtSetValues(_lTab, args, ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNtopAttachment, XmATTACH_WIDGET); ac++;
    XtSetArg(args[ac], XmNrightAttachment, XmATTACH_FORM); ac++;
    XtSetArg(args[ac], XmNleftAttachment, XmATTACH_FORM); ac++;
    XtSetArg(args[ac], XmNbottomAttachment, XmATTACH_FORM); ac++;
    XtSetArg(args[ac], XmNbottomOffset, 0); ac++;
    XtSetArg(args[ac], XmNleftOffset, 10); ac++;
    XtSetArg(args[ac], XmNrightOffset, 10); ac++;
    XtSetArg(args[ac], XmNtopOffset, -3); ac++;
    XtSetArg(args[ac], XmNtopWidget, _pbPageCryst); ac++;
    XtSetValues(_foPageMisc, args, ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNtopAttachment, XmATTACH_NONE); ac++;
    XtSetArg(args[ac], XmNrightAttachment, XmATTACH_POSITION); ac++;
    XtSetArg(args[ac], XmNleftAttachment, XmATTACH_POSITION); ac++;
    XtSetArg(args[ac], XmNbottomAttachment, XmATTACH_FORM); ac++;
    XtSetArg(args[ac], XmNbottomOffset, 5); ac++;
    XtSetArg(args[ac], XmNrightPosition, 88); ac++;
    XtSetArg(args[ac], XmNleftPosition, 73); ac++;
    XtSetArg(args[ac], XmNrightOffset, 0); ac++;
    XtSetValues(_pbDeleteKeyword, args, ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNtopAttachment, XmATTACH_NONE); ac++;
    XtSetArg(args[ac], XmNrightAttachment, XmATTACH_POSITION); ac++;
    XtSetArg(args[ac], XmNleftAttachment, XmATTACH_POSITION); ac++;
    XtSetArg(args[ac], XmNbottomAttachment, XmATTACH_FORM); ac++;
    XtSetArg(args[ac], XmNbottomOffset, 5); ac++;
    XtSetArg(args[ac], XmNrightPosition, 58); ac++;
    XtSetArg(args[ac], XmNleftPosition, 43); ac++;
    XtSetArg(args[ac], XmNrightOffset, 0); ac++;
    XtSetValues(_pbReplaceValue, args, ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNtopAttachment, XmATTACH_NONE); ac++;
    XtSetArg(args[ac], XmNrightAttachment, XmATTACH_POSITION); ac++;
    XtSetArg(args[ac], XmNleftAttachment, XmATTACH_POSITION); ac++;
    XtSetArg(args[ac], XmNbottomAttachment, XmATTACH_FORM); ac++;
    XtSetArg(args[ac], XmNbottomOffset, 5); ac++;
    XtSetArg(args[ac], XmNrightPosition, 28); ac++;
    XtSetArg(args[ac], XmNleftPosition, 13); ac++;
    XtSetArg(args[ac], XmNrightOffset, 0); ac++;
    XtSetValues(_pbAddKeyword, args, ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNtopAttachment, XmATTACH_WIDGET); ac++;
    XtSetArg(args[ac], XmNrightAttachment, XmATTACH_NONE); ac++;
    XtSetArg(args[ac], XmNleftAttachment, XmATTACH_OPPOSITE_WIDGET); ac++;
    XtSetArg(args[ac], XmNbottomAttachment, XmATTACH_NONE); ac++;
    XtSetArg(args[ac], XmNleftOffset, 0); ac++;
    XtSetArg(args[ac], XmNtopOffset, 10); ac++;
    XtSetArg(args[ac], XmNleftWidget, _lKeyword); ac++;
    XtSetArg(args[ac], XmNtopWidget, _tfKeyword); ac++;
    XtSetValues(_lValue, args, ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNtopAttachment, XmATTACH_WIDGET); ac++;
    XtSetArg(args[ac], XmNrightAttachment, XmATTACH_OPPOSITE_WIDGET); ac++;
    XtSetArg(args[ac], XmNleftAttachment, XmATTACH_OPPOSITE_WIDGET); ac++;
    XtSetArg(args[ac], XmNbottomAttachment, XmATTACH_OPPOSITE_WIDGET); ac++;
    XtSetArg(args[ac], XmNbottomOffset, 0); ac++;
    XtSetArg(args[ac], XmNbottomWidget, _swHeader); ac++;
    XtSetArg(args[ac], XmNleftOffset, 0); ac++;
    XtSetArg(args[ac], XmNrightOffset, 0); ac++;
    XtSetArg(args[ac], XmNtopOffset, 0); ac++;
    XtSetArg(args[ac], XmNleftWidget, _tfKeyword); ac++;
    XtSetArg(args[ac], XmNrightWidget, _tfKeyword); ac++;
    XtSetArg(args[ac], XmNtopWidget, _lValue); ac++;
    XtSetValues(_swValue, args, ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNtopAttachment, XmATTACH_FORM); ac++;
    XtSetArg(args[ac], XmNleftAttachment, XmATTACH_FORM); ac++;
    XtSetArg(args[ac], XmNleftOffset, 10); ac++;
    XtSetArg(args[ac], XmNtopOffset, 10); ac++;
    XtSetValues(_lHeader, args, ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNtopAttachment, XmATTACH_WIDGET); ac++;
    XtSetArg(args[ac], XmNrightAttachment, XmATTACH_FORM); ac++;
    XtSetArg(args[ac], XmNleftAttachment, XmATTACH_OPPOSITE_WIDGET); ac++;
    XtSetArg(args[ac], XmNbottomAttachment, XmATTACH_NONE); ac++;
    XtSetArg(args[ac], XmNleftOffset, 0); ac++;
    XtSetArg(args[ac], XmNrightOffset, 10); ac++;
    XtSetArg(args[ac], XmNtopOffset, -1); ac++;
    XtSetArg(args[ac], XmNleftWidget, _lKeyword); ac++;
    XtSetArg(args[ac], XmNtopWidget, _lKeyword); ac++;
    XtSetValues(_tfKeyword, args, ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNtopAttachment, XmATTACH_NONE); ac++;
    XtSetArg(args[ac], XmNrightAttachment, XmATTACH_FORM); ac++;
    XtSetArg(args[ac], XmNleftAttachment, XmATTACH_FORM); ac++;
    XtSetArg(args[ac], XmNbottomAttachment, XmATTACH_WIDGET); ac++;
    XtSetArg(args[ac], XmNbottomOffset, 5); ac++;
    XtSetArg(args[ac], XmNbottomWidget, _pbReplaceValue); ac++;
    XtSetArg(args[ac], XmNleftOffset, 0); ac++;
    XtSetArg(args[ac], XmNrightOffset, 0); ac++;
    XtSetValues(_seMain, args, ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNtopAttachment, XmATTACH_OPPOSITE_WIDGET); ac++;
    XtSetArg(args[ac], XmNrightAttachment, XmATTACH_NONE); ac++;
    XtSetArg(args[ac], XmNleftAttachment, XmATTACH_WIDGET); ac++;
    XtSetArg(args[ac], XmNbottomAttachment, XmATTACH_NONE); ac++;
    XtSetArg(args[ac], XmNleftOffset, 10); ac++;
    XtSetArg(args[ac], XmNtopOffset, 0); ac++;
    XtSetArg(args[ac], XmNleftWidget, _swHeader); ac++;
    XtSetArg(args[ac], XmNtopWidget, _lHeader); ac++;
    XtSetValues(_lKeyword, args, ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNtopAttachment, XmATTACH_WIDGET); ac++;
    XtSetArg(args[ac], XmNrightAttachment, XmATTACH_POSITION); ac++;
    XtSetArg(args[ac], XmNleftAttachment, XmATTACH_OPPOSITE_WIDGET); ac++;
    XtSetArg(args[ac], XmNbottomAttachment, XmATTACH_WIDGET); ac++;
    XtSetArg(args[ac], XmNbottomOffset, 5); ac++;
    XtSetArg(args[ac], XmNbottomWidget, _seMain); ac++;
    XtSetArg(args[ac], XmNrightPosition, 50); ac++;
    XtSetArg(args[ac], XmNleftOffset, 0); ac++;
    XtSetArg(args[ac], XmNtopOffset, 0); ac++;
    XtSetArg(args[ac], XmNleftWidget, _lHeader); ac++;
    XtSetArg(args[ac], XmNtopWidget, _lHeader); ac++;
    XtSetValues(_swHeader, args, ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNtopAttachment, XmATTACH_WIDGET); ac++;
    XtSetArg(args[ac], XmNrightAttachment, XmATTACH_FORM); ac++;
    XtSetArg(args[ac], XmNleftAttachment, XmATTACH_FORM); ac++;
    XtSetArg(args[ac], XmNbottomAttachment, XmATTACH_FORM); ac++;
    XtSetArg(args[ac], XmNbottomOffset, 0); ac++;
    XtSetArg(args[ac], XmNleftOffset, 10); ac++;
    XtSetArg(args[ac], XmNrightOffset, 10); ac++;
    XtSetArg(args[ac], XmNtopOffset, -3); ac++;
    XtSetArg(args[ac], XmNtopWidget, _pbPageCryst); ac++;
    XtSetValues(_foPageCryst, args, ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNtopAttachment, XmATTACH_WIDGET); ac++;
    XtSetArg(args[ac], XmNrightAttachment, XmATTACH_OPPOSITE_WIDGET); ac++;
    XtSetArg(args[ac], XmNleftAttachment, XmATTACH_OPPOSITE_WIDGET); ac++;
    XtSetArg(args[ac], XmNbottomAttachment, XmATTACH_OPPOSITE_WIDGET); ac++;
    XtSetArg(args[ac], XmNbottomOffset, 0); ac++;
    XtSetArg(args[ac], XmNbottomWidget, _frCrystSpaceGroup); ac++;
    XtSetArg(args[ac], XmNleftOffset, 0); ac++;
    XtSetArg(args[ac], XmNrightOffset, 0); ac++;
    XtSetArg(args[ac], XmNtopOffset, 10); ac++;
    XtSetArg(args[ac], XmNleftWidget, _frCrystOrient); ac++;
    XtSetArg(args[ac], XmNrightWidget, _frCrystOrient); ac++;
    XtSetArg(args[ac], XmNtopWidget, _frCrystOrient); ac++;
    XtSetValues(_frCrystComment, args, ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNtopAttachment, XmATTACH_WIDGET); ac++;
    XtSetArg(args[ac], XmNrightAttachment, XmATTACH_OPPOSITE_WIDGET); ac++;
    XtSetArg(args[ac], XmNleftAttachment, XmATTACH_OPPOSITE_WIDGET); ac++;
    XtSetArg(args[ac], XmNbottomAttachment, XmATTACH_NONE); ac++;
    XtSetArg(args[ac], XmNbottomOffset, 0); ac++;
    XtSetArg(args[ac], XmNleftOffset, 0); ac++;
    XtSetArg(args[ac], XmNrightOffset, 0); ac++;
    XtSetArg(args[ac], XmNtopOffset, 10); ac++;
    XtSetArg(args[ac], XmNleftWidget, _frUnitCell); ac++;
    XtSetArg(args[ac], XmNrightWidget, _frUnitCell); ac++;
    XtSetArg(args[ac], XmNtopWidget, _frUnitCell); ac++;
    XtSetValues(_frCrystSpaceGroup, args, ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNtopAttachment, XmATTACH_WIDGET); ac++;
    XtSetArg(args[ac], XmNrightAttachment, XmATTACH_NONE); ac++;
    XtSetArg(args[ac], XmNleftAttachment, XmATTACH_OPPOSITE_WIDGET); ac++;
    XtSetArg(args[ac], XmNbottomAttachment, XmATTACH_FORM); ac++;
    XtSetArg(args[ac], XmNbottomOffset, 0); ac++;
    XtSetArg(args[ac], XmNleftOffset, 0); ac++;
    XtSetArg(args[ac], XmNrightOffset, 0); ac++;
    XtSetArg(args[ac], XmNtopOffset, 10); ac++;
    XtSetArg(args[ac], XmNleftWidget, _frCrystSpaceGroup); ac++;
    XtSetArg(args[ac], XmNtopWidget, _frCrystSpaceGroup); ac++;
    XtSetValues(_frCrystMosaicity, args, ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNtopAttachment, XmATTACH_OPPOSITE_WIDGET); ac++;
    XtSetArg(args[ac], XmNrightAttachment, XmATTACH_FORM); ac++;
    XtSetArg(args[ac], XmNleftAttachment, XmATTACH_WIDGET); ac++;
    XtSetArg(args[ac], XmNbottomAttachment, XmATTACH_NONE); ac++;
    XtSetArg(args[ac], XmNbottomOffset, 0); ac++;
    XtSetArg(args[ac], XmNleftOffset, 10); ac++;
    XtSetArg(args[ac], XmNrightOffset, 10); ac++;
    XtSetArg(args[ac], XmNtopOffset, 0); ac++;
    XtSetArg(args[ac], XmNleftWidget, _frUnitCell); ac++;
    XtSetArg(args[ac], XmNtopWidget, _frUnitCell); ac++;
    XtSetValues(_frCrystOrient, args, ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNtopAttachment, XmATTACH_FORM); ac++;
    XtSetArg(args[ac], XmNleftAttachment, XmATTACH_FORM); ac++;
    XtSetArg(args[ac], XmNleftOffset, 10); ac++;
    XtSetArg(args[ac], XmNtopOffset, 10); ac++;
    XtSetValues(_frUnitCell, args, ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNtopAttachment, XmATTACH_WIDGET); ac++;
    XtSetArg(args[ac], XmNrightAttachment, XmATTACH_FORM); ac++;
    XtSetArg(args[ac], XmNleftAttachment, XmATTACH_FORM); ac++;
    XtSetArg(args[ac], XmNbottomAttachment, XmATTACH_FORM); ac++;
    XtSetArg(args[ac], XmNbottomOffset, 0); ac++;
    XtSetArg(args[ac], XmNleftOffset, 10); ac++;
    XtSetArg(args[ac], XmNrightOffset, 10); ac++;
    XtSetArg(args[ac], XmNtopOffset, -3); ac++;
    XtSetArg(args[ac], XmNtopWidget, _pbPageDet); ac++;
    XtSetValues(_foPageDet, args, ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNtopAttachment, XmATTACH_OPPOSITE_WIDGET); ac++;
    XtSetArg(args[ac], XmNrightAttachment, XmATTACH_NONE); ac++;
    XtSetArg(args[ac], XmNleftAttachment, XmATTACH_WIDGET); ac++;
    XtSetArg(args[ac], XmNbottomAttachment, XmATTACH_NONE); ac++;
    XtSetArg(args[ac], XmNbottomOffset, 0); ac++;
    XtSetArg(args[ac], XmNleftOffset, 10); ac++;
    XtSetArg(args[ac], XmNrightOffset, 0); ac++;
    XtSetArg(args[ac], XmNtopOffset, 0); ac++;
    XtSetArg(args[ac], XmNleftWidget, _frDetRot); ac++;
    XtSetArg(args[ac], XmNtopWidget, _frDetRot); ac++;
    XtSetValues(_frDetDirectBeam, args, ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNtopAttachment, XmATTACH_FORM); ac++;
    XtSetArg(args[ac], XmNleftAttachment, XmATTACH_FORM); ac++;
    XtSetArg(args[ac], XmNleftOffset, 10); ac++;
    XtSetArg(args[ac], XmNtopOffset, 10); ac++;
    XtSetValues(_frDetRot, args, ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNtopAttachment, XmATTACH_WIDGET); ac++;
    XtSetArg(args[ac], XmNrightAttachment, XmATTACH_NONE); ac++;
    XtSetArg(args[ac], XmNleftAttachment, XmATTACH_OPPOSITE_WIDGET); ac++;
    XtSetArg(args[ac], XmNbottomAttachment, XmATTACH_NONE); ac++;
    XtSetArg(args[ac], XmNbottomOffset, 0); ac++;
    XtSetArg(args[ac], XmNleftOffset, 0); ac++;
    XtSetArg(args[ac], XmNrightOffset, 0); ac++;
    XtSetArg(args[ac], XmNtopOffset, 10); ac++;
    XtSetArg(args[ac], XmNleftWidget, _frDetRot); ac++;
    XtSetArg(args[ac], XmNtopWidget, _frDetRot); ac++;
    XtSetValues(_frDetTrans, args, ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNtopAttachment, XmATTACH_WIDGET); ac++;
    XtSetArg(args[ac], XmNrightAttachment, XmATTACH_FORM); ac++;
    XtSetArg(args[ac], XmNleftAttachment, XmATTACH_FORM); ac++;
    XtSetArg(args[ac], XmNbottomAttachment, XmATTACH_FORM); ac++;
    XtSetArg(args[ac], XmNbottomOffset, 0); ac++;
    XtSetArg(args[ac], XmNleftOffset, 10); ac++;
    XtSetArg(args[ac], XmNrightOffset, 10); ac++;
    XtSetArg(args[ac], XmNtopOffset, -3); ac++;
    XtSetArg(args[ac], XmNtopWidget, _pbPageSource); ac++;
    XtSetValues(_foPageSource, args, ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNtopAttachment, XmATTACH_WIDGET); ac++;
    XtSetArg(args[ac], XmNrightAttachment, XmATTACH_NONE); ac++;
    XtSetArg(args[ac], XmNleftAttachment, XmATTACH_OPPOSITE_WIDGET); ac++;
    XtSetArg(args[ac], XmNbottomAttachment, XmATTACH_NONE); ac++;
    XtSetArg(args[ac], XmNbottomOffset, 0); ac++;
    XtSetArg(args[ac], XmNleftOffset, 0); ac++;
    XtSetArg(args[ac], XmNrightOffset, 0); ac++;
    XtSetArg(args[ac], XmNtopOffset, 10); ac++;
    XtSetArg(args[ac], XmNleftWidget, _frSourceWavelength); ac++;
    XtSetArg(args[ac], XmNtopWidget, _frSourceWavelength); ac++;
    XtSetValues(_frSourceRot, args, ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNtopAttachment, XmATTACH_FORM); ac++;
    XtSetArg(args[ac], XmNleftAttachment, XmATTACH_FORM); ac++;
    XtSetArg(args[ac], XmNleftOffset, 10); ac++;
    XtSetArg(args[ac], XmNtopOffset, 10); ac++;
    XtSetValues(_frSourceWavelength, args, ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNtopAttachment, XmATTACH_OPPOSITE_WIDGET); ac++;
    XtSetArg(args[ac], XmNrightAttachment, XmATTACH_NONE); ac++;
    XtSetArg(args[ac], XmNleftAttachment, XmATTACH_WIDGET); ac++;
    XtSetArg(args[ac], XmNbottomAttachment, XmATTACH_OPPOSITE_WIDGET); ac++;
    XtSetArg(args[ac], XmNbottomOffset, 0); ac++;
    XtSetArg(args[ac], XmNbottomWidget, _pbPageCryst); ac++;
    XtSetArg(args[ac], XmNleftOffset, 0); ac++;
    XtSetArg(args[ac], XmNrightOffset, 0); ac++;
    XtSetArg(args[ac], XmNtopOffset, 0); ac++;
    XtSetArg(args[ac], XmNleftWidget, _pbPageSource); ac++;
    XtSetArg(args[ac], XmNtopWidget, _pbPageCryst); ac++;
    XtSetValues(_pbPageMisc, args, ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNtopAttachment, XmATTACH_FORM); ac++;
    XtSetArg(args[ac], XmNleftAttachment, XmATTACH_FORM); ac++;
    XtSetArg(args[ac], XmNleftOffset, 30); ac++;
    XtSetArg(args[ac], XmNtopOffset, 0); ac++;
    XtSetValues(_pbPageCryst, args, ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNtopAttachment, XmATTACH_OPPOSITE_WIDGET); ac++;
    XtSetArg(args[ac], XmNrightAttachment, XmATTACH_NONE); ac++;
    XtSetArg(args[ac], XmNleftAttachment, XmATTACH_WIDGET); ac++;
    XtSetArg(args[ac], XmNbottomAttachment, XmATTACH_OPPOSITE_WIDGET); ac++;
    XtSetArg(args[ac], XmNbottomOffset, 0); ac++;
    XtSetArg(args[ac], XmNbottomWidget, _pbPageCryst); ac++;
    XtSetArg(args[ac], XmNleftOffset, 0); ac++;
    XtSetArg(args[ac], XmNrightOffset, 0); ac++;
    XtSetArg(args[ac], XmNtopOffset, 0); ac++;
    XtSetArg(args[ac], XmNleftWidget, _pbPageCryst); ac++;
    XtSetArg(args[ac], XmNtopWidget, _pbPageCryst); ac++;
    XtSetValues(_pbPageDet, args, ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNtopAttachment, XmATTACH_OPPOSITE_WIDGET); ac++;
    XtSetArg(args[ac], XmNrightAttachment, XmATTACH_NONE); ac++;
    XtSetArg(args[ac], XmNleftAttachment, XmATTACH_WIDGET); ac++;
    XtSetArg(args[ac], XmNbottomAttachment, XmATTACH_OPPOSITE_WIDGET); ac++;
    XtSetArg(args[ac], XmNbottomOffset, 0); ac++;
    XtSetArg(args[ac], XmNbottomWidget, _pbPageCryst); ac++;
    XtSetArg(args[ac], XmNleftOffset, 0); ac++;
    XtSetArg(args[ac], XmNrightOffset, 0); ac++;
    XtSetArg(args[ac], XmNtopOffset, 0); ac++;
    XtSetArg(args[ac], XmNleftWidget, _pbPageDet); ac++;
    XtSetArg(args[ac], XmNtopWidget, _pbPageCryst); ac++;
    XtSetValues(_pbPageSource, args, ac);
    
    
    // Begin user code block <endcreate>

   Cstring sToken;
   Pixel oBackground;
   XmString xs,xsSpace;

/*
 * Create a XmString containing a space for use in several places.
 */
   xsSpace = XmStringCreate(" ","roman");

/*
 * Manage and unmanage parts of the main selection dialog.
 */
   XtUnmanageChild(XmSelectionBoxGetChild(_CUIheaderEdit,XmDIALOG_TEXT));
   XtUnmanageChild(XmSelectionBoxGetChild(_CUIheaderEdit,
                                          XmDIALOG_SELECTION_LABEL));

   XtManageChild(XmSelectionBoxGetChild(_CUIheaderEdit,XmDIALOG_APPLY_BUTTON));
   XtSetSensitive(XmSelectionBoxGetChild(_CUIheaderEdit,XmDIALOG_APPLY_BUTTON),
                  False);
   XtSetSensitive(XmSelectionBoxGetChild(_CUIheaderEdit,XmDIALOG_HELP_BUTTON),
                  False);
   if(!XtIsShell(XtParent(_CUIheaderEdit))){
      XtUnmanageChild(XmSelectionBoxGetChild(_CUIheaderEdit,
                                             XmDIALOG_OK_BUTTON));
      XtSetSensitive(XmSelectionBoxGetChild(_CUIheaderEdit,
                     XmDIALOG_CANCEL_BUTTON),False);
   }

   XtVaSetValues(_CUIheaderEdit,XmNdefaultButton,XmDIALOG_NONE,NULL);

/*
 * Unmanage some extraneous widgets on some of the dialogs.
 */
   XtUnmanageChild(XmMessageBoxGetChild(_mdAddKeywordError,
                                        XmDIALOG_CANCEL_BUTTON));
   XtUnmanageChild(XmMessageBoxGetChild(_mdDeleteKeywordError,
                                        XmDIALOG_CANCEL_BUTTON));
   XtUnmanageChild(XmMessageBoxGetChild(_mdGetValueError,
                                        XmDIALOG_CANCEL_BUTTON));
   XtUnmanageChild(XmMessageBoxGetChild(_mdKeywordCharacterError,
                                        XmDIALOG_CANCEL_BUTTON));
   XtUnmanageChild(XmMessageBoxGetChild(_mdKeywordLengthError,
                                        XmDIALOG_CANCEL_BUTTON));
   XtUnmanageChild(XmMessageBoxGetChild(_mdReplaceValueError,
                                        XmDIALOG_CANCEL_BUTTON));
   XtUnmanageChild(XmMessageBoxGetChild(_mdValueError,
                                        XmDIALOG_CANCEL_BUTTON));
   XtUnmanageChild(XmMessageBoxGetChild(_mdProtectedKeywordWarning,
                                        XmDIALOG_CANCEL_BUTTON));

   XtUnmanageChild(XmMessageBoxGetChild(_mdAddKeywordError,
                                        XmDIALOG_HELP_BUTTON));
   XtUnmanageChild(XmMessageBoxGetChild(_mdDeleteKeywordError,
                                        XmDIALOG_HELP_BUTTON));
   XtUnmanageChild(XmMessageBoxGetChild(_mdGetValueError,
                                        XmDIALOG_HELP_BUTTON));
   XtUnmanageChild(XmMessageBoxGetChild(_mdKeywordCharacterError,
                                        XmDIALOG_HELP_BUTTON));
   XtUnmanageChild(XmMessageBoxGetChild(_mdKeywordLengthError,
                                        XmDIALOG_HELP_BUTTON));
   XtUnmanageChild(XmMessageBoxGetChild(_mdReplaceValueError,
                                        XmDIALOG_HELP_BUTTON));
   XtUnmanageChild(XmMessageBoxGetChild(_mdValueError,
                                        XmDIALOG_HELP_BUTTON));
   XtUnmanageChild(XmMessageBoxGetChild(_mdProtectedKeywordWarning,
                                        XmDIALOG_HELP_BUTTON));

/*
 * Store some unchanging parts of dialog messages.
 */
   sToken = "%s";

   XtVaGetValues(_mdAddKeywordError,XmNmessageString,&xs,NULL);
   XmStringSplit(xs,sToken,2,m_axsAddKeywordError);
   XmStringFree(xs);

   XtVaGetValues(_mdDeleteKeywordError,XmNmessageString,&xs,NULL);
   XmStringSplit(xs,sToken,2,m_axsDeleteKeywordError);
   XmStringFree(xs);
   XtVaGetValues(_mdGetValueError,XmNmessageString,&xs,NULL);
   XmStringSplit(xs,sToken,2,m_axsGetValueError);
   XmStringFree(xs);

   XtVaGetValues(_mdKeywordCharacterError,XmNmessageString,&xs,NULL);
   XmStringSplit(xs,sToken,2,m_axsKeywordCharacterError);
   XmStringFree(xs);

   XtVaGetValues(_mdKeywordLengthError,XmNmessageString,&xs,NULL);
   XmStringSplit(xs,sToken,2,m_axsKeywordLengthError);
   XmStringFree(xs);
   xs = m_axsKeywordLengthError[1];
   m_axsKeywordLengthError[1] = XmStringConcat(xs,xsSpace);
   XmStringFree(xs);

   XtVaGetValues(_mdReplaceValueError,XmNmessageString,&xs,NULL);
   XmStringSplit(xs,sToken,2,m_axsReplaceValueError);
   XmStringFree(xs);

   XtVaGetValues(_mdValueError,XmNmessageString,&xs,NULL);
   XmStringSplit(xs,sToken,2,m_axsValueError);
   XmStringFree(xs);

/*
 * space group number label
 */
   XtVaGetValues(_lCrystSpaceGroupNumber,XmNlabelString,&xs,NULL);
   m_xsCrystSpaceGroupNumber = XmStringConcat(xs,xsSpace);
   XmStringFree(xs);

/*
 * default detector goniometer names
 */
   
   
/*
 * Free up strings used for formatting
 */
   XmStringFree(xsSpace);

/*
 * Initialize the widget arrays
 */
   m_awCrystUnitCell[0] = _tfCrystUnitCellA;
   m_awCrystUnitCell[1] = _tfCrystUnitCellB;
   m_awCrystUnitCell[2] = _tfCrystUnitCellC;
   m_awCrystUnitCell[3] = _tfCrystUnitCellAlpha;
   m_awCrystUnitCell[4] = _tfCrystUnitCellBeta;
   m_awCrystUnitCell[5] = _tfCrystUnitCellGamma;

   m_awCrystOrient[0] = _tfCrystOrient1;
   m_awCrystOrient[1] = _tfCrystOrient2;
   m_awCrystOrient[2] = _tfCrystOrient3;

   m_awDetGonio[0] = _tfDetRot1;
   m_awDetGonio[1] = _tfDetRot2;
   m_awDetGonio[2] = _tfDetRot3;
   m_awDetGonio[3] = _tfDetTrans1;
   m_awDetGonio[4] = _tfDetTrans2;
   m_awDetGonio[5] = _tfDetTrans3;

   m_awDetGonioNames[0] = _lDetRot1;
   m_awDetGonioNames[1] = _lDetRot2;
   m_awDetGonioNames[2] = _lDetRot3;
   m_awDetGonioNames[3] = _lDetTrans1;
   m_awDetGonioNames[4] = _lDetTrans2;
   m_awDetGonioNames[5] = _lDetTrans3;

   m_awDetDirectBeam[0] = _tfDetDirectBeamX;
   m_awDetDirectBeam[1] = _tfDetDirectBeamY;

   m_awSourceRot[0] = _tfSourceRot1;
   m_awSourceRot[1] = _tfSourceRot2;

/*
 * Disable the push button widgets on the Misc form until something is selected
 */
   vSetKeywordButtons();

/*
 * Set header changed flag to false.  I know this was done in constructor,
 * but doing it via the routine will also set the sensitivity of the
 * File->Save widget correctly.
 */
   vHeaderHasChanged(false,NULL);

/*
 * Get background color of menu, then set the color of the "file folder"
 * buttons to be the same.
 */
   XtVaGetValues(_foEdit,XmNbackground,&oBackground,NULL);
   XtVaSetValues(_pbPageCryst,XmNbackground,oBackground,NULL);
   XtVaSetValues(_pbPageDet,XmNbackground,oBackground,NULL);
   XtVaSetValues(_pbPageMisc,XmNbackground,oBackground,NULL);
   XtVaSetValues(_pbPageSource,XmNbackground,oBackground,NULL);

/*
 * Make sure the displayed page is updated
 */
   vUpdateDisplayedPage();

    // End user code block <endcreate>
}

//
// Classname access.
//
const char *const CUIheaderEdit::className()
{
    return ("CUIheaderEdit");
}

void CUIheaderEdit::ClassHelpCBCallback(Widget w, 
    XtPointer clientData, XtPointer callData)
{
    UICallbackStruct *data = (UICallbackStruct *) clientData;
    CUIheaderEdit *obj = (CUIheaderEdit *)data->object;
    obj->ClassHelpCB(w, (XtPointer) data->client_data, callData);
}

void CUIheaderEdit::ClassHelpCB(Widget w, XtPointer clientData, XtPointer callData)
{
    
    // Begin user code block <ClassHelpCB>
//cout << "ClassHelpCB called\n";
    // End user code block <ClassHelpCB>
}

void CUIheaderEdit::ChangeHeaderCBCallback(Widget w, 
    XtPointer clientData, XtPointer callData)
{
    UICallbackStruct *data = (UICallbackStruct *) clientData;
    CUIheaderEdit *obj = (CUIheaderEdit *)data->object;
    obj->ChangeHeaderCB(w, (XtPointer) data->client_data, callData);
}

void CUIheaderEdit::ChangeHeaderCB(Widget w, XtPointer clientData, XtPointer callData)
{
    
    // Begin user code block <ChangeHeaderCB>

   Cstring s = (char *)clientData;

   if("apply" == s || "ok" == s){
      m_oHeader = m_oWorkingHeader;
      vHeaderHasChanged(true,callData);
   }
   else if("cancel" == s){
      m_oWorkingHeader = m_oHeader;
   }
   else
      return;

   if(!XtIsManaged(XmSelectionBoxGetChild(_CUIheaderEdit,XmDIALOG_OK_BUTTON)))
      XtSetSensitive(XmSelectionBoxGetChild(_CUIheaderEdit,
                     XmDIALOG_CANCEL_BUTTON),False);
   if(XtIsSensitive(XmSelectionBoxGetChild(_CUIheaderEdit,
   XmDIALOG_APPLY_BUTTON)))
      XtSetSensitive(XmSelectionBoxGetChild(_CUIheaderEdit,
                     XmDIALOG_APPLY_BUTTON),False);

   vUpdateDisplayedPage();

    // End user code block <ChangeHeaderCB>
}

void CUIheaderEdit::DeleteKeywordCBCallback(Widget w, 
    XtPointer clientData, XtPointer callData)
{
    UICallbackStruct *data = (UICallbackStruct *) clientData;
    CUIheaderEdit *obj = (CUIheaderEdit *)data->object;
    obj->DeleteKeywordCB(w, (XtPointer) data->client_data, callData);
}

void CUIheaderEdit::DeleteKeywordCB(Widget w, XtPointer clientData, XtPointer callData)
{
    
    // Begin user code block <DeleteKeywordCB>

   int n;
   char *pc;
   Cstring sKeyword,sValue;

   pc = XmTextFieldGetString(_tfKeyword);
   sKeyword = pc;
   XtFree(pc);
   if(!m_oWorkingHeader.bIsKeywordValid(sKeyword)){
      vKeywordError(sKeyword);
      return;
   }

   if(bKeywordProtected(sKeyword))
      vDeleteKeywordError(sKeyword);
   else
      n = nChangeWorkingHeader(eKeywordAction_Delete,sKeyword);

    // End user code block <DeleteKeywordCB>
}

void CUIheaderEdit::ReplaceValueCBCallback(Widget w, 
    XtPointer clientData, XtPointer callData)
{
    UICallbackStruct *data = (UICallbackStruct *) clientData;
    CUIheaderEdit *obj = (CUIheaderEdit *)data->object;
    obj->ReplaceValueCB(w, (XtPointer) data->client_data, callData);
}

void CUIheaderEdit::ReplaceValueCB(Widget w, XtPointer clientData, XtPointer callData)
{
    
    // Begin user code block <ReplaceValueCB>

   int n;
   char *pc;
   Cstring sKeyword,sValue;

   pc = XmTextFieldGetString(_tfKeyword);
   sKeyword = pc;
   XtFree(pc);
   if(!m_oWorkingHeader.bIsKeywordValid(sKeyword)){
      vKeywordError(sKeyword);
      return;
   }

   pc = XmTextGetString(_tValue);
   sValue = pc;
   XtFree(pc);
   if(!m_oWorkingHeader.bIsValueValid(sValue)){
      vValueError(sKeyword);
      return;
   }

   if(bKeywordProtected(sKeyword))
      vReplaceValueError(sKeyword);
   else
      n = nChangeWorkingHeader(eKeywordAction_Replace,sKeyword,sValue);

    // End user code block <ReplaceValueCB>
}

void CUIheaderEdit::AddKeywordCBCallback(Widget w, 
    XtPointer clientData, XtPointer callData)
{
    UICallbackStruct *data = (UICallbackStruct *) clientData;
    CUIheaderEdit *obj = (CUIheaderEdit *)data->object;
    obj->AddKeywordCB(w, (XtPointer) data->client_data, callData);
}

void CUIheaderEdit::AddKeywordCB(Widget w, XtPointer clientData, XtPointer callData)
{
    
    // Begin user code block <AddKeywordCB>

   int n;
   char *pc;
   Cstring sKeyword,sValue;

   pc = XmTextFieldGetString(_tfKeyword);
   sKeyword = pc;
   XtFree(pc);
   if(!m_oWorkingHeader.bIsKeywordValid(sKeyword)){
      vKeywordError(sKeyword);
      return;
   }

   pc = XmTextGetString(_tValue);
   sValue = pc;
   XtFree(pc);
   if(!m_oWorkingHeader.bIsValueValid(sValue)){
      vValueError(sKeyword);
      return;
   }

   n = nChangeWorkingHeader(eKeywordAction_Add,sKeyword,sValue);

    // End user code block <AddKeywordCB>
}

void CUIheaderEdit::KeywordChangedCBCallback(Widget w, 
    XtPointer clientData, XtPointer callData)
{
    UICallbackStruct *data = (UICallbackStruct *) clientData;
    CUIheaderEdit *obj = (CUIheaderEdit *)data->object;
    obj->KeywordChangedCB(w, (XtPointer) data->client_data, callData);
}

void CUIheaderEdit::KeywordChangedCB(Widget w, XtPointer clientData, XtPointer callData)
{
    
    // Begin user code block <KeywordChangedCB>

   char *pc;
   Cstring s;
   XmListCallbackStruct *poCBS = (XmListCallbackStruct *)callData;

   if(XmCR_ACTIVATE == poCBS->reason){
      pc = XmTextFieldGetString(_tfKeyword);
      s = pc;
      XtFree(pc);
      if(!m_oWorkingHeader.bIsKeywordValid(s)){
         vKeywordError(s);
         return;
      }
      vFillKeyword(s);
   }
   vSetKeywordButtons();

    // End user code block <KeywordChangedCB>
}

void CUIheaderEdit::KeywordSelectedCBCallback(Widget w, 
    XtPointer clientData, XtPointer callData)
{
    UICallbackStruct *data = (UICallbackStruct *) clientData;
    CUIheaderEdit *obj = (CUIheaderEdit *)data->object;
    obj->KeywordSelectedCB(w, (XtPointer) data->client_data, callData);
}

void CUIheaderEdit::KeywordSelectedCB(Widget w, XtPointer clientData, XtPointer callData)
{
    
    // Begin user code block <KeywordSelectedCB>

   Cstring sKeyword,sValue;
   XmListCallbackStruct *poCBS = (XmListCallbackStruct *)callData;

   if(poCBS->reason != XmCR_BROWSE_SELECT)
      return;
/*
 * Put the selected keyword in the "Keyword" text field
 */
   sKeyword = XmStringGetCstring(poCBS->item);
   XmTextFieldSetString(_tfKeyword,sKeyword.string());

/*
 * Now put the value in the "Value" text widget
 */
   m_oWorkingHeader.nGetValue(sKeyword,&sValue);
   XmTextSetString(_tValue,sValue.string());

/*
 * Set sensitivity of the push button actions
 */
   vSetKeywordButtons();

    // End user code block <KeywordSelectedCB>
}

void CUIheaderEdit::ChangeCommentCBCallback(Widget w, 
    XtPointer clientData, XtPointer callData)
{
    UICallbackStruct *data = (UICallbackStruct *) clientData;
    CUIheaderEdit *obj = (CUIheaderEdit *)data->object;
    obj->ChangeCommentCB(w, (XtPointer) data->client_data, callData);
}

void CUIheaderEdit::ChangeCommentCB(Widget w, XtPointer clientData, XtPointer callData)
{
    
    // Begin user code block <ChangeCommentCB>

   char *pc;
   Cstring s;

   if(_tCrystComment != w)
      return;

   pc = XmTextGetString(w);
   s = pc;
   XtFree(pc);

   if(!m_oWorkingHeader.bIsValueValid(s))
      vValueError(ms_sCrystComment);
   else
      nChangeWorkingHeader(eKeywordAction_Replace,ms_sCrystComment,s);

    // End user code block <ChangeCommentCB>
}

void CUIheaderEdit::ChangeCrystSpaceGroupCallback(Widget w, 
    XtPointer clientData, XtPointer callData)
{
    UICallbackStruct *data = (UICallbackStruct *) clientData;
    CUIheaderEdit *obj = (CUIheaderEdit *)data->object;
    obj->ChangeCrystSpaceGroup(w, (XtPointer) data->client_data, callData);
}

void CUIheaderEdit::ChangeCrystSpaceGroup(Widget w, XtPointer clientData, XtPointer callData)
{
    
    // Begin user code block <ChangeCrystSpaceGroup>

   char *pc;
   int n;
   Cstring s,ss;
   
   if(_tfCrystSpaceGroupName != w && _tfCrystSpaceGroupNumber != w)
      return;

// Get the value from the textfield

   pc = XmTextFieldGetString(w);
   s = pc;
   XtFree(pc);

// find space group number 
   if(_tfCrystSpaceGroupName == w){
      m_oSpaceGroup.vSet(s);
      n = m_oSpaceGroup.nNumberFromName();
   }
   else{
      sscanf(s.string(),"%d",&n);
      m_oSpaceGroup.vSet(n);
   }

// If this is not a recognizable name/number, then try to return to what 
// was previously entered (i.e., currently in the header).  If there is no
// keyword, then set to unknown.

   if(0 >= n){ 
      if(0 != m_oWorkingHeader.nGetValue(ms_sCrystSpaceGroupNumber,&n))
         n = 0;
      m_oSpaceGroup.vSet(n);
      ss = m_oSpaceGroup.sNameFromNumber();
      if(s != ss)
         XtVaSetValues(w,XmNvalue,ss.string(),NULL);
   }

// If the space group is unknown, then remove it from the header, else
// replace current header value with the new one.

   if(0 == n)
      nChangeWorkingHeader(eKeywordAction_Delete,ms_sCrystSpaceGroupNumber);
   else
      nChangeWorkingHeader(eKeywordAction_Replace,ms_sCrystSpaceGroupNumber,n);

// Update the space group number on the display

   s = n;
   XmTextFieldSetString(_tfCrystSpaceGroupNumber,s.string());
   s = m_oSpaceGroup.sNameFromNumber();
   XmTextFieldSetString(_tfCrystSpaceGroupName,s.string());
   
    // End user code block <ChangeCrystSpaceGroup>
}

void CUIheaderEdit::ChangeCrystMosaicityCBCallback(Widget w, 
    XtPointer clientData, XtPointer callData)
{
    UICallbackStruct *data = (UICallbackStruct *) clientData;
    CUIheaderEdit *obj = (CUIheaderEdit *)data->object;
    obj->ChangeCrystMosaicityCB(w, (XtPointer) data->client_data, callData);
}

void CUIheaderEdit::ChangeCrystMosaicityCB(Widget w, XtPointer clientData, XtPointer callData)
{
    
    // Begin user code block <ChangeCrystMosaicityCB>

   char *pc;
   int n;
   float f;
   Cstring s;
   
   if(_tfCrystMosaicity != w)
      return;

// Get the value from the widget

   pc = XmTextFieldGetString(w);
   s = pc;
   XtFree(pc);
   
// Make sure that the value is "reasonable"
// If there is no number on the line, put the current value back in.

   n = sscanf(s.string(),"%f",&f);
   if(1 != n){
      if(0 != m_oWorkingHeader.nGetValue(ms_sCrystMosaicity,&f))
         f = 0.0;
   }
   else if(0 >= f)
      f = 0.0;

   nChangeWorkingHeader(eKeywordAction_Replace,ms_sCrystMosaicity,f);
   
// Put the value back on the widget

   s = f;
   XmTextFieldSetString(w,s.string());

    // End user code block <ChangeCrystMosaicityCB>
}

void CUIheaderEdit::ChangeCrystOrientCBCallback(Widget w, 
    XtPointer clientData, XtPointer callData)
{
    UICallbackStruct *data = (UICallbackStruct *) clientData;
    CUIheaderEdit *obj = (CUIheaderEdit *)data->object;
    obj->ChangeCrystOrientCB(w, (XtPointer) data->client_data, callData);
}

void CUIheaderEdit::ChangeCrystOrientCB(Widget w, XtPointer clientData, XtPointer callData)
{
    
    // Begin user code block <ChangeCrystOrientCB>

   char *pc;
   int i,n;
   float f,af[3];
   Cstring s;

// Make sure the widget is one we are interested in.

   for(n = 0; n < 3; n++){
      if(m_awCrystOrient[n] == w)
         break;
   }
   if(3 <= n)
      return;
    
// Get the value of the string from the widget.

   pc = XmTextFieldGetString(w);
   s = pc;
   XtFree(pc);

// Get the current orientation angles

   if(0 != m_oWorkingHeader.nGetValue(ms_sCrystOrient,3,af)){
      for(i = 0; i < 3; i++)
         af[i] = 0.0;
   }

// If there is no number on the line, use the current value.

   if(1 == sscanf(s.string(),"%f",&f))
      af[n] = f;

   nChangeWorkingHeader(eKeywordAction_Replace,ms_sCrystOrient,3,af);

// Put the value back in the widget

   s = af[n];
   XtVaSetValues(w,XmNvalue,s.string(),NULL);

    // End user code block <ChangeCrystOrientCB>
}

void CUIheaderEdit::ChangeUnitCellCBCallback(Widget w, 
    XtPointer clientData, XtPointer callData)
{
    UICallbackStruct *data = (UICallbackStruct *) clientData;
    CUIheaderEdit *obj = (CUIheaderEdit *)data->object;
    obj->ChangeUnitCellCB(w, (XtPointer) data->client_data, callData);
}

void CUIheaderEdit::ChangeUnitCellCB(Widget w, XtPointer clientData, XtPointer callData)
{
    
    // Begin user code block <ChangeUnitCellCB>
 
   char *pc;
   int i,n;
   float f,af[6];
   Cstring s;
   
// Make sure the widget is one we are interested in.

   for(n = 0; n < 6; n++){
      if(m_awCrystUnitCell[n] == w)
         break;
   }
   if(6 <= n)
      return;
    
// Get the value of the string from the widget.

   pc = XmTextFieldGetString(w);
   s = pc;
   XtFree(pc);

// Get the current unit cell lengths and angles

   if(0 != m_oWorkingHeader.nGetValue(ms_sCrystUnitCell,6,af)){
      for(i = 0; i < 6; i++)
         af[i] = 0.0;
   }

// If there is no number on the line, use the current value.

   if(1 == sscanf(s.string(),"%f",&f))
      af[n] = f;

   nChangeWorkingHeader(eKeywordAction_Replace,ms_sCrystUnitCell,6,af);

// Put the value back in the widget 

   s = af[n];
   XtVaSetValues(w,XmNvalue,s.string(),NULL);

    // End user code block <ChangeUnitCellCB>
}

void CUIheaderEdit::ChangeDirectBeamCBCallback(Widget w, 
    XtPointer clientData, XtPointer callData)
{
    UICallbackStruct *data = (UICallbackStruct *) clientData;
    CUIheaderEdit *obj = (CUIheaderEdit *)data->object;
    obj->ChangeDirectBeamCB(w, (XtPointer) data->client_data, callData);
}

void CUIheaderEdit::ChangeDirectBeamCB(Widget w, XtPointer clientData, XtPointer callData)
{
    
    // Begin user code block <ChangeDirectBeamCB>

   char *pc;
   int nBeam;
   float fmax,f,af[4],afDim[2],afSize[2];
   float factor;
   Cstring s,sPrefix,sKey;
   
// make sure the widget is one we are interested in

   for(nBeam = 0; nBeam < 2; nBeam++){
      if(m_awDetDirectBeam[nBeam] == w)
         break;
   }
   if(2 <= nBeam)
      return;

// Get the prefix for the name of the detector

   sPrefix = sGetDetectorPrefix();

// Get the string value from the widget

   pc = XmTextFieldGetString(w);
   f = (float)atof(pc);
   XtFree(pc);

// Make sure it is a valid number.  If not, put the original # back in the
// widget

   if(0.0 >= f){
      vGetDirectBeamPosition(sPrefix,af);
      s = af[nBeam];
      XtVaSetValues(w,XmNvalue,s.string(),NULL);
      return;
   }

// Figure out the maximum value the direct beam position can have.  While 
// we're at it, figure out the binning factor to use later.

   sKey = sPrefix;
   sKey += D_K_UnbinnedDimensions;
   if(0 == m_oWorkingHeader.nGetValue(sKey,2,af))
      factor = af[nBeam];
   else
      factor = 0.0;

   sKey = sPrefix;
   sKey += D_K_DetectorDimensions;
   if(0 == m_oWorkingHeader.nGetValue(sKey,2,afDim)){
      fmax = afDim[nBeam];
      factor /= fmax;
   }
   else if(0.0 != factor){
      fmax = factor;
      afDim[0] = 1024.0;
      afDim[1] = 1024.0;
      factor = 1;
   }
   else
//      fmax = HUGE; // def'd in <math.h>, use if no det dimensions
      fmax = 99999.0;

// Get the spatial distortion info.  If not there, build it if we can

   sKey = sPrefix;
   sKey += D_K_SpatialDistortionInfo;
   if(0 != m_oWorkingHeader.nGetValue(sKey,4,af))
     {
       af[0] = af[1] = 0.0;
       af[2] = af[3] = 0.100;
       sKey = sPrefix;
       sKey += D_K_DetectorSize;
       if (0 == m_oWorkingHeader.nGetValue(sKey, 2, afSize))
	 {
	   af[2] = afSize[0] / afDim[0];
	   af[3] = afSize[1] / afDim[1];
	 }
     }
      
// Get the values of the direct beam position.

   vGetDirectBeamPosition(sPrefix,af);

// make sure that the value entered into the widget is "reasonable"

   if(f < fmax)
      af[nBeam] = f;
   else 
      af[nBeam] = fmax;

// Put the value back in the widget

   s = af[nBeam];
   XtVaSetValues(w,XmNvalue,s.string(),NULL);

// Update the new value of the spatial beam position

   sKey = sPrefix;
   sKey += D_K_SpatialBeamPosn;
   if(m_oWorkingHeader.bKeywordExists(sKey))
      nChangeWorkingHeader(eKeywordAction_Replace,sKey,2,af);
   else
      nChangeWorkingHeader(eKeywordAction_Add,sKey,2,af);

//+JWP 15-June-2000
   // Update ONLY in the case where
   // SpatialDistortionType is Simple_spatial! (or it is missing!)

   if (0 == m_oWorkingHeader.nGetValue(D_K_SpatialDistortionInfo, &sKey))
     {
       if (sKey == D_K_SpatialTypeSimple)
	 {
	   // Now the spatial distortion info

	   sKey = sPrefix;
	   sKey += D_K_SpatialDistortionInfo;
	   if(m_oWorkingHeader.bKeywordExists(sKey))
	     nChangeWorkingHeader(eKeywordAction_Replace,sKey,4,af);
	   else
	     nChangeWorkingHeader(eKeywordAction_Add,sKey,4,af);
	 }
     }
   else
     {
       // Keyword did not exist, so ADD it

       m_oWorkingHeader.nReplaceValue(D_K_SpatialDistortionType, 
				      D_K_SpatialTypeSimple);
       m_oWorkingHeader.nReplaceValue(D_K_SpatialDistortionInfo, 4, af);
     }
//-JWP 15-June-2000

// Put the value into the unbinned beam position

   if(0.0 != factor){
      af[0] *= factor;
      af[1] *= factor;
      sKey = sPrefix;
      sKey += D_K_UnbinnedBeamPosition;
      if(m_oWorkingHeader.bKeywordExists(sKey))
         nChangeWorkingHeader(eKeywordAction_Replace,sKey,2,af);
      else
         nChangeWorkingHeader(eKeywordAction_Add,sKey,2,af);
   }

    // End user code block <ChangeDirectBeamCB>
}

void CUIheaderEdit::ChangeDetGonioCBCallback(Widget w, 
    XtPointer clientData, XtPointer callData)
{
    UICallbackStruct *data = (UICallbackStruct *) clientData;
    CUIheaderEdit *obj = (CUIheaderEdit *)data->object;
    obj->ChangeDetGonioCB(w, (XtPointer) data->client_data, callData);
}

void CUIheaderEdit::ChangeDetGonioCB(Widget w, XtPointer clientData, XtPointer callData)
{
    
    // Begin user code block <ChangeDetGonioCB>

   char *pc;
   int i,n;
   float f,af[6];
   Cstring s,sPrefix,sKey;

// Make sure the widget is one we are interested in.

   for(n = 0; n < 6; n++){
      if(m_awDetGonio[n] == w)
         break;
   }
   if(6 <= n)
      return;
    
// Get the value of the string from the widget.

   pc = XmTextFieldGetString(w);
   s = pc;
   XtFree(pc);

// Get the current detector gonio values

   sPrefix = sGetDetectorPrefix();
   sKey = sPrefix;
   sKey += ms_sDetGonio;
   if(0 != m_oWorkingHeader.nGetValue(sKey,6,af)){
      for(i = 0; i < 6; i++)
         af[i] = 0.0;
   }

// If there is no number on the line, use the current value.

   if(1 == sscanf(s.string(),"%f",&f))
      af[n] = f;

   nChangeWorkingHeader(eKeywordAction_Replace,sKey,6,af);

// Put the value back in the widget
   s = af[n];
   XtVaSetValues(w,XmNvalue,s.string(),NULL);

    // End user code block <ChangeDetGonioCB>
}

void CUIheaderEdit::ChangeSourceRotCBCallback(Widget w, 
    XtPointer clientData, XtPointer callData)
{
    UICallbackStruct *data = (UICallbackStruct *) clientData;
    CUIheaderEdit *obj = (CUIheaderEdit *)data->object;
    obj->ChangeSourceRotCB(w, (XtPointer) data->client_data, callData);
}

void CUIheaderEdit::ChangeSourceRotCB(Widget w, XtPointer clientData, XtPointer callData)
{
    
    // Begin user code block <ChangeSourceRotCB>

   char *pc;
   int i,n;
   float f,af[3];
   Cstring s;

// Make sure the widget is one we are interested in.

   for(n = 0; n < 2; n++){
      if(m_awSourceRot[n] == w)
         break;
   }
   if(2 <= n)
      return;
    
// Get the value of the string from the widget.

   pc = XmTextFieldGetString(w);
   s = pc;
   XtFree(pc);

// Get the current orientation angles

   if(0 != m_oWorkingHeader.nGetValue(ms_sSourceRot,2,af)){
      for(i = 0; i < 2; i++)
         af[i] = 0.0;
   }

// If there is no number on the line, use the current value.

   if(1 == sscanf(s.string(),"%f",&f))
      af[n] = f;

   nChangeWorkingHeader(eKeywordAction_Replace,ms_sSourceRot,2,af);

// Put the value back in the widget

   s = af[n];
   XtVaSetValues(w,XmNvalue,s.string(),NULL);

    // End user code block <ChangeSourceRotCB>
}

void CUIheaderEdit::ChangeSourceWavelengthCBCallback(Widget w, 
    XtPointer clientData, XtPointer callData)
{
    UICallbackStruct *data = (UICallbackStruct *) clientData;
    CUIheaderEdit *obj = (CUIheaderEdit *)data->object;
    obj->ChangeSourceWavelengthCB(w, (XtPointer) data->client_data, callData);
}

void CUIheaderEdit::ChangeSourceWavelengthCB(Widget w, XtPointer clientData, XtPointer callData)
{
    
    // Begin user code block <ChangeSourceWavelengthCB>

   char *pc;
   float f,af[2];
   Cstring s;

// Make sure the widget is one we are interested in.

   if(_tfSourceWavelength != w)
      return;
    
// Get the value of the string from the widget.

   pc = XmTextFieldGetString(w);
   s = pc;
   XtFree(pc);

// Get the current wavelength

   if(0 != m_oWorkingHeader.nGetValue(ms_sSourceWavelength,2,af)){
      af[0] = 1.0;
      af[1] = 0.0;
   }

// If there is no number on the line, use the current value.

   if(1 == sscanf(s.string(),"%f",&f))
      af[1] = f;

   nChangeWorkingHeader(eKeywordAction_Replace,ms_sSourceWavelength,2,af);

// Put the value back in the widget

   s = af[1];
   XtVaSetValues(w,XmNvalue,s.string(),NULL);

    // End user code block <ChangeSourceWavelengthCB>
}

void CUIheaderEdit::ChangeMenuCBCallback(Widget w, 
    XtPointer clientData, XtPointer callData)
{
    UICallbackStruct *data = (UICallbackStruct *) clientData;
    CUIheaderEdit *obj = (CUIheaderEdit *)data->object;
    obj->ChangeMenuCB(w, (XtPointer) data->client_data, callData);
}

void CUIheaderEdit::ChangeMenuCB(Widget w, XtPointer clientData, XtPointer callData)
{
    
    // Begin user code block <ChangeMenuCB>

   Widget wMenu,wOldMenu,wOldButton;

   if(_pbPageMisc == w){
      wMenu = _foPageMisc;
   }
   else if(_pbPageSource == w){
      wMenu = _foPageSource;
   }
   else if(_pbPageDet == w){
      wMenu = _foPageDet;
   }
   else if(_pbPageCryst == w){
      wMenu = _foPageCryst;
   }

   if(XtIsManaged(_foPageMisc)){
      wOldButton = _pbPageMisc;
      wOldMenu = _foPageMisc;
   }
   else if(XtIsManaged(_foPageSource)){
      wOldButton = _pbPageSource;
      wOldMenu = _foPageSource;
   }
   else if(XtIsManaged(_foPageDet)){
      wOldButton = _pbPageDet;
      wOldMenu = _foPageDet;
   }
   else if(XtIsManaged(_foPageCryst)){
      wOldButton = _pbPageCryst;
      wOldMenu = _foPageCryst;
   }
   else
      wOldButton = w;

   if(w != wOldButton){
      XtUnmanageChild(wOldMenu);
      XtManageChild(wMenu);
      vUpdateDisplayedPage();
      XRaiseWindow(XtDisplay(wMenu),XtWindow(wMenu));
      XtVaSetValues(_lTab,XmNleftWidget,w,XmNrightWidget,w,XmNtopWidget,w,
                    XmNbottomWidget,w,NULL);
      if(!XtIsManaged(_lTab))
         XtManageChild(_lTab);
      XRaiseWindow(XtDisplay(_lTab),XtWindow(_lTab));
   }
   else{
      if(!XtIsManaged(wMenu)){
         XtManageChild(wMenu);
         XRaiseWindow(XtDisplay(wMenu),XtWindow(wMenu));
      }
      if(!XtIsManaged(_lTab))
         XtManageChild(_lTab);
      XRaiseWindow(XtDisplay(_lTab),XtWindow(_lTab));
   }

    // End user code block <ChangeMenuCB>
}
void
CUIheaderEdit::set_lcrystorient3_labelString(String value)
{
    Arg	args[10];
    Cardinal ac = 0;
    Boolean argok = True;
    
    XtSetArg(args[ac], XmNlabelString, 
        BX_CONVERT(_lCrystOrient3, value, 
        XmRXmString, 0, &argok)); if (argok) ac++;
    XtSetValues(_lCrystOrient3, args, ac);
    
    // Begin user code block <set_lcrystorient3_labelString(String)>
    // End user code block <set_lcrystorient3_labelString(String)>
}

// Begin user code block <tail>

bool bKeywordProtected(const Cstring &sKeyword)
{
  if(D_K_HeaderBytes == sKeyword || D_K_ByteOrder == sKeyword || 
     D_K_Compression == sKeyword || D_K_DataType == sKeyword || 
     D_K_Dim == sKeyword || D_K_Filename == sKeyword || 
     D_K_Size1 == sKeyword || D_K_Size2 == sKeyword || D_K_Type == sKeyword)
     return true;
  else
     return false;
}

void
CUIheaderEdit::vSetHeaderModNotifyCallback(XtPointer pClass,
                                         void (*function)(XtPointer,Widget,
                                                          XtPointer,XtPointer))
{
   m_pObj = pClass;
   m_prvHeaderModNotifyCallback = function;
   return;
}

void
CUIheaderEdit::vUpdatePageCryst(void)
{
   int i,n;
   float f,af[6];
   Cstring s;
   
   // space group

   if(0 != m_oWorkingHeader.nGetValue(ms_sCrystSpaceGroupNumber,&n))
      n = 0;
   m_oSpaceGroup.vSet(n);
   s = m_oSpaceGroup.sNameFromNumber();
   XmTextFieldSetString(_tfCrystSpaceGroupName,s.string());
   s = n;
   XmTextFieldSetString(_tfCrystSpaceGroupNumber,s.string());
   
   // mosaicity

   if(0 != m_oWorkingHeader.nGetValue(ms_sCrystMosaicity,&f))
      f = 0.0;
   s = f;
   XtVaSetValues(_tfCrystMosaicity,XmNvalue,s.string(),NULL);
   
   // comment
   if(0 != m_oWorkingHeader.nGetValue(ms_sCrystComment,&s))
      s = "";
   XmTextSetString(_tCrystComment,s.string());
   
   // unitcell
   if(0 != m_oWorkingHeader.nGetValue(ms_sCrystUnitCell,6,af)){
      for(i = 0; i < 6; i++)
         af[i] = 0.0;
   }
   for(i = 0; i < 6; i++){
      s = af[i];
      XtVaSetValues(m_awCrystUnitCell[i],XmNvalue,s.string(),NULL);
   }
   
   // orientations
   if(0 != m_oWorkingHeader.nGetValue(ms_sCrystOrient,3,af)){
      for(i = 0; i < 3; i++)
         af[i] = 0.0;
   }
   for(i = 0; i < 3; i++){
      s = af[i];
      XtVaSetValues(m_awCrystOrient[i],XmNvalue,s.string(),NULL);
   }
  
   return;
}

void
CUIheaderEdit::vUpdatePageDet(void)
{
   int i;
   float af[6];
   Cstring s,sPrefix,sKey;
   Cstring asNames[6];

   sPrefix = sGetDetectorPrefix();

// gonio (rot+trans)

   sKey = sPrefix;
   sKey += ms_sDetGonio;
   if(0 != m_oWorkingHeader.nGetValue(sKey,6,af)){
      for(i = 0; i < 6; i++)
         af[i] = 0.0;
   }
   for(i = 0; i < 6; i++){
      s = af[i];
      XtVaSetValues(m_awDetGonio[i],XmNvalue,s.string(),NULL);
   }
   
// direct beam

   vGetDirectBeamPosition(sPrefix,af);
   for(i = 0; i < 2; i++){
      s = af[i];
      XtVaSetValues(m_awDetDirectBeam[i],XmNvalue,s.string(),NULL);
   }

// names of gonio elements

   sKey = sPrefix;
   sKey += ms_sDetGonioNames;
   if(0 == m_oWorkingHeader.nGetValue(sKey,6,asNames)){
      for(i = 0; i < 6; i++)
         XmLabelSetString(m_awDetGonioNames[i],asNames[i]);
   }
   else{
      for(i = 0; i < 6; i++)
         XtVaSetValues(m_awDetGonioNames[i],XmNvalue,
                       m_axsDefaultDetGonioNames[i],NULL);
   }
   return;
}

void
CUIheaderEdit::vUpdatePageSource(void)
{
   int i;
   float af[2];
   Cstring s;

// rot

   if(0 != m_oWorkingHeader.nGetValue(ms_sSourceRot,2,af)){
      for(i = 0; i < 2; i++)
         af[i] = 0.0;
   }
   for(i = 0; i < 2; i++){
      s = af[i];
      XtVaSetValues(m_awSourceRot[i],XmNvalue,s.string(),NULL);
   }
   
// wavelength

   if(0 != m_oWorkingHeader.nGetValue(ms_sSourceWavelength,2,af))
      af[1] = 0.0;
   s = af[1];
   XmTextFieldSetString(_tfSourceWavelength,s.string());

   return;
}

void
CUIheaderEdit::vUpdatePageMisc(void)
{
   int i,n;
   int nTop;
   int *pnPos,nCount;
   Cstring s,sNextKey;
   Cstring *psSelected;
   XmString *pxs;
   XmStringTable xst;

// Count the number of keywords in the header.

   std::vector<Cstring>asKeywords;
   m_oWorkingHeader.nFindKeywordMask(Cstring('*'), asKeywords);
   n = asKeywords.size();

// If no keywords, clear the list and other text fields
   if(0 == n){
      XmListDeleteAllItems(_liHeader);
      XmTextFieldSetString(_tfKeyword,"");
      XmTextSetString(_tValue,"");
      return;
   }

   XtVaGetValues(_liHeader,XmNitems,&xst,XmNtopItemPosition,&nTop,NULL);
   pnPos = NULL;
   if(XmListGetSelectedPos(_liHeader,&pnPos,&nCount)){
      psSelected = new Cstring [nCount];
      for(i = 0; i < nCount; i++)
         psSelected[i] = XmStringGetCstring(xst[pnPos[i]]);
      XtFree((char *)pnPos);
   }
   else
      nCount = 0;

   XmListDeleteAllItems(_liHeader);
   XmTextFieldSetString(_tfKeyword,"");
   XmTextSetString(_tValue,"");

// Build an array of XmStrings, which contain the keywords.
   pxs = new XmString [n];

   for(i = 0; i < n; i++){
     sNextKey = asKeywords[i];
      if(bKeywordProtected(sNextKey)){
         pxs[i] = XmStringCreate(sNextKey.string(),"keyword_italics");
      }
      else{
         pxs[i] = XmStringCreate(sNextKey.string(),"keyword_roman");
      }
   }

// Rebuild the keyword list
   XmListAddItems(_liHeader,pxs,n,0);
   XmListSetPos(_liHeader,nTop);

// Free the XmString array
   for(i = 0; i < n; i++)
      XmStringFree(pxs[i]);
   delete [] pxs;

// Reselect what was selected
   if(0 != nCount){
      for(n = 0; n < nCount; n++){
         i = nSearchAlphaList(_liHeader,psSelected[n]);
         if(0 < i)
            XmListSelectPos(_liHeader,i,True);
      }
      delete [] psSelected;
   }

   return;
}

void
CUIheaderEdit::vUpdateDisplayedPage()
{
   if(XtIsManaged(_foPageMisc))
      vUpdatePageMisc();
   else if(XtIsManaged(_foPageCryst))
      vUpdatePageCryst();
   else if(XtIsManaged(_foPageDet))
      vUpdatePageDet();
   else if(XtIsManaged(_foPageSource))
      vUpdatePageSource();

   return;
}

/****************************************************************************
 * The following are convenience functions ala XmWidgetSetValue().          *
 * At some point, these may/should be moved from the class into a library.  *
 ****************************************************************************/

/****************************************************************************
 *                                  Labels                                  *
 ****************************************************************************/

/****************************************************************************
 ****************************************************************************/
void 
CUIheaderEdit::XmLabelSetString(Widget w,
                                char *pc)
{
   Cardinal ac;
   Arg args[10];
   XmString xstr;

   xstr = XmStringCreate(pc,"roman");
   if(NULL != xstr){
      ac = 0;
      XtSetArg(args[ac],XmNlabelString,xstr); ac++;
      XtSetValues(w,args,ac);
      XmStringFree(xstr);
   }

   return;
}

/****************************************************************************
 ****************************************************************************/
void 
CUIheaderEdit::XmLabelSetString(Widget w, 
                                Cstring &s)
{
   XmLabelSetString(w,s.string());
   return;
}

/****************************************************************************
 *                             Compound Strings                             *
 ****************************************************************************/

/****************************************************************************
 ****************************************************************************/
Cstring 
CUIheaderEdit::XmStringGetCstring(XmString xsString)
{
   Boolean bSeparator;   // must be Boolean and not bool
   char *pcText;
   Cstring s;
   XmStringContext oContext;
   XmStringCharSet oCharset;
   XmStringDirection oDirection;

   s = "";

   if(!XmStringInitContext(&oContext,xsString))
      return s;

   while(XmStringGetNextSegment(oContext,&pcText,&oCharset,&oDirection,
   &bSeparator)){
      s += pcText;
      if(True == bSeparator)
         s += '\n';
      XtFree(pcText);
   }

   XmStringFreeContext(oContext);

   return s;
}

/****************************************************************************
 ****************************************************************************/
int 
CUIheaderEdit::XmStringSplit(XmString xsString,
                             Cstring sToken,
                             int nMaxParts,
                             XmString *xsParts)
{
   Boolean bSeparator;   // must be Boolean and not bool
   char *pcText;
   int i;
   Cstring s,sBefore;
   XmString xs,xs1,xs2;
   XmStringContext oContext;
   XmStringCharSet oCharset;
   XmStringDirection oDirection;

   if(!XmStringInitContext(&oContext,xsString))
      return 0;

   xs = xs1 = xs2 = NULL;
   i = 0;
   while(i < nMaxParts){
      if(!XmStringGetNextSegment(oContext,&pcText,&oCharset,&oDirection,
      &bSeparator)){
         xsParts[i++] = xs;
         XmStringFreeContext(oContext);
         return i;
      }
      s = pcText;
      XtFree(pcText);
      while(i < nMaxParts && -1 != s.find(sToken)){
         sBefore = s.before(sToken);
         xs2 = XmStringSegmentCreate(sBefore.string(),oCharset,oDirection,
                                     False);
         if(NULL != xs){
            xs1 = xs;
            xs = XmStringConcat(xs1,xs2);
            XmStringFree(xs1);
            XmStringFree(xs2);
         }
         else
            xs = xs2;
         xsParts[i++] = xs;
         s = s.after(sToken);
         xs = xs1 = NULL;
      }
      if(i == nMaxParts)
         break;
      xs2 = XmStringSegmentCreate(s.string(),oCharset,oDirection,bSeparator);
      if(NULL != xs){
         xs1 = xs;
         xs = XmStringConcat(xs1,xs2);
         XmStringFree(xs1);
         XmStringFree(xs2);
      }
      else
         xs = xs2;
   }
   XmStringFree(xs);
   XmStringFreeContext(oContext);

   return i;
}

void
CUIheaderEdit::vGetDirectBeamPosition(Cstring sPrefix,
                                      float af[2])
{
   int n;
   Cstring s,sKey;

// The direct beam position should be in the spatial distortion keywords, 
// so look there first

   sKey = sPrefix;
   sKey += D_K_SpatialBeamPosn;
   if(0 == m_oWorkingHeader.nGetValue(sKey,2,af))
      return;

// If the spatial distortion is "Simple_spatial", try to get it from that

   sKey = sPrefix;
   sKey += D_K_SpatialDistortionType;
   n = m_oWorkingHeader.nGetValue(sKey,&s);
   if(0 == n){
      if("Simple_spatial" == s){
         sKey = sPrefix;
         sKey += D_K_SpatialDistortionInfo;
         n = m_oWorkingHeader.nGetValue(sKey,2,af);
      }
      else
         n = 1;
   }
   if(0 == n)
      return;

// Try to get the direct beam for the unbinned image.

   sKey = sPrefix;
   sKey += D_K_UnbinnedBeamPosition;
   if(0 == m_oWorkingHeader.nGetValue(sKey,2,af))
      return;

// If that failed, as a last resort use the middle of the detector.

// detector dimensions first
   sKey = sPrefix;
   sKey += D_K_DetectorDimensions;
   if(0 == m_oWorkingHeader.nGetValue(sKey,2,af)){
      af[0] /= 2;
      af[1] /= 2;
      return;
   }

// Unbinned dimensions next
   sKey = sPrefix;
   sKey += D_K_UnbinnedDimensions;
   if(0 == m_oWorkingHeader.nGetValue(sKey,2,af)){
      af[0] /= 2;
      af[1] /= 2;
      return;
   }

// If THAT didn't work, give up

   af[0] = af[1] = 0.0;

   return;
}

int
CUIheaderEdit::nSearchAlphaList(Widget wList,
                                const Cstring &sItem)
{
   int n,nLower,nUpper;
   Cstring s;
   XmString *xsList;

/*
 * Get the number and items in the list.
 */
   XtVaGetValues(wList,XmNitemCount,&nUpper,XmNitems,&xsList,NULL);
   nUpper--;
   nLower = 0;

/*
 * Binary search on list to find position of item
 */
   while(nUpper >= nLower){
      n = nLower+(nUpper-nLower)/2;
      if("" == (s=XmStringGetCstring(xsList[n])))
         break;
      if(s == sItem)
         return n;
      else if(s > sItem)
         nUpper = n-1;
      else
         nLower = n+1;
   }

/*
 * Since sItem not in list, return the negative of the insertion position.
 * Add one since inserting after this position
 */
   nLower = -nLower-1;

   return nLower;
}


int
CUIheaderEdit::nChangeWorkingHeader(const enum eKeyword_Action eAction,
                                    const Cstring &sKeyword,
                                    const Cstring &sValue)
{
   int n;
   XmString xs;

   if(eKeywordAction_None == eAction)
      return 0;

   n = -1;
   if(eKeywordAction_Add == eAction){
      n = m_oWorkingHeader.nAddValue(sKeyword,sValue);
      if(0 != n)
         vAddKeywordError(sKeyword);
      else{
         vAddStringToList(sKeyword,_liHeader);
         if(XtIsManaged(_foPageMisc))
            vSetKeywordButtons();
      }
   }
   else if(eKeywordAction_Delete == eAction){
      n = m_oWorkingHeader.nDelete(sKeyword);
      if(0 != n)
         vDeleteKeywordError(sKeyword);
      else{
         xs = XmStringCreate(sKeyword.string(),"keyword_roman");
         XmListDeleteItem(_liHeader,xs);
         XmStringFree(xs);
         if(XtIsManaged(_foPageMisc))
            vSetKeywordButtons();
      }
   }
   else if(eKeywordAction_Replace == eAction){
      n = m_oWorkingHeader.nReplaceValue(sKeyword,sValue);
      if(0 != n)
         vReplaceValueError(sKeyword);
   }

   if(0 == n){
      if(!XtIsSensitive(XmSelectionBoxGetChild(_CUIheaderEdit,
      XmDIALOG_APPLY_BUTTON)))
         XtSetSensitive(XmSelectionBoxGetChild(_CUIheaderEdit,
                        XmDIALOG_APPLY_BUTTON),True);
      if(!XtIsSensitive(XmSelectionBoxGetChild(_CUIheaderEdit,
      XmDIALOG_CANCEL_BUTTON)))
         XtSetSensitive(XmSelectionBoxGetChild(_CUIheaderEdit,
                        XmDIALOG_CANCEL_BUTTON),True);
   }

   return n;
}

int
CUIheaderEdit::nChangeWorkingHeader(const enum eKeyword_Action eAction,
                                    const Cstring &sKeyword,
                                    const int nNumValues,
                                    const float *pfValue)
{
   int i;
   Cstring sValue;

   if(eKeywordAction_None == eAction)
      return 0;

   sValue = "";
   for(i = 0; i < nNumValues; i++){
      if(0 != i)
         sValue += ' ';
      sValue += pfValue[i];
   }

   return (nChangeWorkingHeader(eAction,sKeyword,sValue));
}

int
CUIheaderEdit::nChangeWorkingHeader(const enum eKeyword_Action eAction,
                                    const Cstring &sKeyword,
                                    const float fValue)
{
   Cstring sValue;

   if(eKeywordAction_None == eAction)
      return 0;

   sValue = fValue;

   return (nChangeWorkingHeader(eAction,sKeyword,sValue));
}

int
CUIheaderEdit::nChangeWorkingHeader(const enum eKeyword_Action eAction,
                                    const Cstring &sKeyword,
                                    const int nValue)
{
   Cstring sValue;

   if(eKeywordAction_None == eAction)
      return 0;

   sValue = nValue;

   return (nChangeWorkingHeader(eAction,sKeyword,sValue));
}

Cstring
CUIheaderEdit::sGetDetectorPrefix(void)
{
   int i,nDetectors;
   Cstring sKey,sPrefix,*psDetNames;

   sPrefix = "";
   sKey = D_K_DetectorNumber;
   i = m_oWorkingHeader.nGetValue(sKey,&nDetectors);
   if(0 == i){
      psDetNames = new Cstring [nDetectors];
      sKey = D_K_DetectorNames;
      i = m_oWorkingHeader.nGetValue(sKey,nDetectors,psDetNames);
      if(0 == i)
         sPrefix = psDetNames[0];  // for now use only the first detector name
      delete [] psDetNames;
   }

   return sPrefix;
}
void
CUIheaderEdit::vHeaderHasChanged(bool bValue , XtPointer callData)
{
    
   m_bHeaderHasChanged = bValue;
   if(NULL != m_prvHeaderModNotifyCallback){
      m_prvHeaderModNotifyCallback(m_pObj,baseWidget(),(XtPointer)&bValue,
                                   callData);
   }
   if(bValue){
      if(!XtIsSensitive(XmSelectionBoxGetChild(_CUIheaderEdit,
      XmDIALOG_APPLY_BUTTON)))
         XtSetSensitive(XmSelectionBoxGetChild(_CUIheaderEdit,
                        XmDIALOG_APPLY_BUTTON),True);
   }
   else{
      if(XtIsSensitive(XmSelectionBoxGetChild(_CUIheaderEdit,
      XmDIALOG_APPLY_BUTTON)))
         XtSetSensitive(XmSelectionBoxGetChild(_CUIheaderEdit,
                        XmDIALOG_APPLY_BUTTON),False);
   }

   return;
}

void
CUIheaderEdit::vKeywordCharacterError(const Cstring & sKeyword)
{
    
   XmString xs,xs1,xs2;

   xs = XmStringCreate(sKeyword.string(),"keyword_italics");
   xs1 = XmStringConcat(m_axsKeywordCharacterError[0],xs);
   xs2 = XmStringConcat(xs1,m_axsKeywordCharacterError[1]);
   XtVaSetValues(_mdKeywordCharacterError,XmNmessageString,xs2,NULL);
   XmStringFree(xs);
   XmStringFree(xs1);
   XmStringFree(xs2);

   XBell(XtDisplay(_CUIheaderEdit),0);
   XtManageChild(_mdKeywordCharacterError);
   return;
}

void
CUIheaderEdit::vKeywordError(const Cstring & sKeyword)
{
    
   if(32 < sKeyword.length() || 1 > sKeyword.length())
      vKeywordLengthError(sKeyword,sKeyword.length());
   else
      vKeywordCharacterError(sKeyword);

   return;
}

void
CUIheaderEdit::vKeywordLengthError(const Cstring & sKeyword , int nLength)
{
    
   Cstring s;
   XmString xs,xs1,xs2,xs3,xs4;

   xs = XmStringCreate(sKeyword.string(),"keyword_italics");
   xs1 = XmStringConcat(m_axsKeywordLengthError[0],xs);
   xs2 = XmStringConcat(xs1,m_axsKeywordLengthError[1]);
   s = nLength;
   xs3 = XmStringCreate(s.string(),"roman");
   xs4 = XmStringConcat(xs2,xs3);
   XtVaSetValues(_mdKeywordLengthError,XmNmessageString,xs4,NULL);
   XmStringFree(xs);
   XmStringFree(xs1);
   XmStringFree(xs2);
   XmStringFree(xs3);
   XmStringFree(xs4);

   XBell(XtDisplay(_CUIheaderEdit),0);
   XtManageChild(_mdKeywordLengthError);
   return;
}

void
CUIheaderEdit::vReplaceValueError(const Cstring & sKeyword)
{
    
   XmString xs,xs1,xs2;

   xs = XmStringCreate(sKeyword.string(),"keyword_italics");
   xs1 = XmStringConcat(m_axsReplaceValueError[0],xs);
   xs2 = XmStringConcat(xs1,m_axsReplaceValueError[1]);
   XtVaSetValues(_mdReplaceValueError,XmNmessageString,xs2,NULL);
   XmStringFree(xs);
   XmStringFree(xs1);
   XmStringFree(xs2);

   XBell(XtDisplay(_CUIheaderEdit),0);
   XtManageChild(_mdReplaceValueError);
   return;
}

void
CUIheaderEdit::vSetKeywordButtons()
{
   char *pc;
   Cstring s;

   pc = XmTextFieldGetString(_tfKeyword);
   if(NULL == pc){
      if(XtIsSensitive(_pbAddKeyword))
         XtSetSensitive(_pbAddKeyword,False);
      if(XtIsSensitive(_pbReplaceValue))
         XtSetSensitive(_pbReplaceValue,False);
      if(XtIsSensitive(_pbDeleteKeyword))
         XtSetSensitive(_pbDeleteKeyword,False);
      if(!XtIsSensitive(_tValue))
         XtSetSensitive(_tValue,True);
      return;
   }
   s = pc;
   XtFree(pc);

   if("" == s){
      if(XtIsSensitive(_pbAddKeyword))
         XtSetSensitive(_pbAddKeyword,False);
      if(XtIsSensitive(_pbReplaceValue))
         XtSetSensitive(_pbReplaceValue,False);
      if(XtIsSensitive(_pbDeleteKeyword))
         XtSetSensitive(_pbDeleteKeyword,False);
      if(!XtIsSensitive(_tValue))
         XtSetSensitive(_tValue,True);
      return;
   }
   else if(bKeywordProtected(s)){
      if(XtIsSensitive(_pbAddKeyword))
         XtSetSensitive(_pbAddKeyword,False);
      if(XtIsSensitive(_pbReplaceValue))
         XtSetSensitive(_pbReplaceValue,False);
      if(XtIsSensitive(_pbDeleteKeyword))
         XtSetSensitive(_pbDeleteKeyword,False);
      //if(XtIsSensitive(_tValue))
         //XtSetSensitive(_tValue,False);
      XtManageChild(_mdProtectedKeywordWarning);
   }
   else{
      if(!XtIsSensitive(_tValue))
         XtSetSensitive(_tValue,True);
      if(m_oWorkingHeader.bKeywordExists(s)){
         if(XtIsSensitive(_pbAddKeyword))
            XtSetSensitive(_pbAddKeyword,False);
         if(!XtIsSensitive(_pbReplaceValue))
            XtSetSensitive(_pbReplaceValue,True);
         if(!XtIsSensitive(_pbDeleteKeyword))
            XtSetSensitive(_pbDeleteKeyword,True);
      }
      else{
         if(!XtIsSensitive(_pbAddKeyword))
            XtSetSensitive(_pbAddKeyword,True);
         if(XtIsSensitive(_pbReplaceValue))
            XtSetSensitive(_pbReplaceValue,False);
         if(XtIsSensitive(_pbDeleteKeyword))
            XtSetSensitive(_pbDeleteKeyword,False);
      }
   }

   return;
}

void
CUIheaderEdit::vValueError(const Cstring & sValue)
{
   XmString xs,xs1,xs2;

   xs = XmStringCreate(sValue.string(),"keyword_italics");
   xs1 = XmStringConcat(m_axsValueError[0],xs);
   xs2 = XmStringConcat(xs1,m_axsValueError[1]);
   XtVaSetValues(_mdValueError,XmNmessageString,xs2,NULL);
   XmStringFree(xs);
   XmStringFree(xs1);
   XmStringFree(xs2);

   XBell(XtDisplay(_CUIheaderEdit),0);
   XtManageChild(_mdValueError);
   return;
}


void
CUIheaderEdit::vGetHeader(Cimage_header * poHeader)
{
   *poHeader = m_oHeader;
}

void
CUIheaderEdit::vSetHeader(Cimage_header * poHeader)
{
   vHeaderHasChanged(false,NULL);

   if(NULL == poHeader){
      XtSetSensitive(_tfKeyword,False);
      XtSetSensitive(_tValue,False);
      XtSetSensitive(_liHeader,False);
      m_oWorkingHeader.nEmpty();
      return;
   }
   m_oWorkingHeader = *poHeader;
   m_oHeader = m_oWorkingHeader;

   if(!XtIsSensitive(_tValue))
      XtSetSensitive(_tValue,True);
   if(!XtIsSensitive(_tfKeyword))
      XtSetSensitive(_tfKeyword,True);
   if(!XtIsSensitive(_liHeader))
      XtSetSensitive(_liHeader,True);

   vUpdateDisplayedPage();

   return;
}

void
CUIheaderEdit::vAddKeywordError(const Cstring & sKeyword)
{
   XmString xs,xs1,xs2;

   xs = XmStringCreate(sKeyword.string(),"keyword_italics");
   xs1 = XmStringConcat(m_axsAddKeywordError[0],xs);
   xs2 = XmStringConcat(xs1,m_axsAddKeywordError[1]);
   XtVaSetValues(_mdAddKeywordError,XmNmessageString,xs2,NULL);
   XmStringFree(xs);
   XmStringFree(xs1);
   XmStringFree(xs2);

   XBell(XtDisplay(_CUIheaderEdit),0);
   XtManageChild(_mdAddKeywordError);
   return;
}

void
CUIheaderEdit::vAddStringToList(const Cstring & sItem , const Widget wList)
{
   int i;
   Cstring s;
   XmString xs;

   i = nSearchAlphaList(wList,sItem);
   if(0 < i)
      return;   // Already in list
   else 
      i = -i;

/*
 * Insert into list, making it selected
 */
   s = sItem;
   if(bKeywordProtected(s))
      xs = XmStringCreate(s.string(),"keyword_italics");
   else
      xs = XmStringCreate(s.string(),"keyword_roman");
   XmListAddItemUnselected(wList,xs,i);
   XmListSelectPos(wList,i,False);
   XmStringFree(xs);

   return;
}

void
CUIheaderEdit::vDeleteKeywordError(const Cstring & sKeyword)
{
   XmString xs,xs1,xs2;

   xs = XmStringCreate(sKeyword.string(),"keyword_italics");
   xs1 = XmStringConcat(m_axsDeleteKeywordError[0],xs);
   xs2 = XmStringConcat(xs1,m_axsDeleteKeywordError[1]);
   XtVaSetValues(_mdDeleteKeywordError,XmNmessageString,xs2,NULL);
   XmStringFree(xs);
   XmStringFree(xs1);
   XmStringFree(xs2);

   XBell(XtDisplay(_CUIheaderEdit),0);
   XtManageChild(_mdDeleteKeywordError);
   return;
}

void
CUIheaderEdit::vFillKeyword(const Cstring & sKeyword)
{
   int *pnPos,nCount;
   int n,nTop,nVisible;
   XmString xs;

/*
 * If keyword doesn't exist, then erase value and deselect all in list
 */
   if(!m_oWorkingHeader.bKeywordExists(sKeyword)){
      if(XmListGetSelectedPos(_liHeader,&pnPos,&nCount)){
         for(n = 0; n < nCount; n++)
            XmListDeselectPos(_liHeader,pnPos[n]);
         XtFree((char *)pnPos);
      }
      vFillValue("");
   }

/*
 * Since keyword exists, fill the value text with its value and select
 * the appropriate element in the list
 */
   else{
      if(bKeywordProtected(sKeyword))
         xs = XmStringCreate(sKeyword.string(),"keyword_italics");
      else
         xs = XmStringCreate(sKeyword.string(),"keyword_roman");
      n = XmListItemPos(_liHeader,xs);
      if(0 != n){    // should always be true, but ...
         XmListSelectPos(_liHeader,n,False);
         XtVaGetValues(_liHeader,XmNvisibleItemCount,&nVisible,
                       XmNtopItemPosition,&nTop,NULL);
         if(n < nTop)
            XmListSetPos(_liHeader,n);
         else if(n >= nTop+nVisible)
            XmListSetBottomPos(_liHeader,n);

         vFillValue(sKeyword);
      }
      else
         vFillValue("");
   }

   return;
}

void
CUIheaderEdit::vFillValue(const Cstring & sKeyword)
{
   int n;
   Cstring sValue;

   if("" == sKeyword)
      XmTextSetString(_tValue,"");
   else{
      n = m_oWorkingHeader.nGetValue(sKeyword,&sValue);
      if(0 != n){
         XmTextSetString(_tValue,"");
         vGetValueError(sKeyword);
      }
   }
   return;
}


void
CUIheaderEdit::vGetValueError(const Cstring & sKeyword)
{
   XmString xs,xs1,xs2;

   xs = XmStringCreate(sKeyword.string(),"keyword_italics");
   xs1 = XmStringConcat(m_axsGetValueError[0],xs);
   xs2 = XmStringConcat(xs1,m_axsGetValueError[1]);
   XtVaSetValues(_mdGetValueError,XmNmessageString,xs2,NULL);
   XmStringFree(xs);
   XmStringFree(xs1);
   XmStringFree(xs2);

   XBell(XtDisplay(_CUIheaderEdit),0);
   XtManageChild(_mdGetValueError);
   return;
}

// End user code block <tail>
