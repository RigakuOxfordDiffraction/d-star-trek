//
// README: Portions of this file are merged at file generation
// time. Edits can be made *only* in between specified code blocks, look
// for keywords <Begin user code> and <End user code>.
//
/////////////////////////////////////////////////////////////
//
// Source file for MainWindow
//
//    Created by Builder Xcessory Version 5.0.
//    Generated by Code Generator Xcessory 5.0 (05/22/98) .
//
//    This class is a user interface "component", as described
//    in "Object-Oriented Programming with C++ and OSF/Motif",
//    by Douglas Young, Prentice Hall, 1992. ISBN 0-13-630252-1
//
/////////////////////////////////////////////////////////////


// Begin user code block <file_comments>
// Copyright (c) 2006 Rigaku
// Copyright (c) 1997, 1996, 1995 Molecular Structure Corporation
//
// RESTRICTED RIGHTS NOTICE SHORT FORM (JUNE 1987)
//
// Use, reproduction, or disclosure is subject to restrictions set
// forth in Contract No. W-31-109-ENG-38 and Contract No. 
// 943072401 with the University of Chicago, Operator of
// Argonne National Laboratory.
//
// MainWindow.cc           Initial author: J.W. Pflugrath           16-Dec-1995
//    This file contains the main window class for dtdisplay.
/*
 *
 * Copyright (C) 2014 Rigaku Americas Corporation
 *                    9009 New Trails Drive
 *                    The Woodlands, TX, USA  77381
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *    * Redistributions of source code must retain the above copyright
 *      notice(s), this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above copyright
 *      notice(s), this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 *    * Neither the name of the Rigaku Americas Corporation nor the 
 *      names of its contributors may be used to endorse or promote products
 *      derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL RIGAKU AMERICAS CORPORATION BE LIABLE 
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA OR PROFITS; OR BUSINESS INTERUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
 * DAMAGE.
 *
*/

// End user code block <file_comments>

#include <X11/StringDefs.h>
#include <Xm/MainW.h>
#include <Xm/DialogS.h>
#include <Xm/MwmUtil.h>
#include <Xm/FileSB.h>
#include <Xm/SelectioB.h>
#include <Xm/MessageB.h>
#include <Xm/Form.h>
#include <Xm/Scale.h>
#include <Xm/PushB.h>
#include <Xm/Separator.h>
#include <Xm/ScrolledW.h>
#include <Xm/Text.h>
#include <Xm/RowColumn.h>
#include <Xm/CascadeB.h>
#include <Xm/ToggleB.h>
#include <Xm/Frame.h>
#include <Xm/DrawingA.h>
#include <Xm/PanedW.h>
#include <Xm/Label.h>
#include <Xm/TextF.h>
#include "MainWindow.h"
#include "CUIprintSelect.h"
#include "CUIreflnfileSelect.h"
#include "CUIimageviewprops.h"
#include "CUIreflnviewprops.h"
#include "CUIimagefileSelect.h"

//
// Convenience functions from utilities file.
//
extern void RegisterBxConverters(XtAppContext);
extern XtPointer BX_CONVERT(Widget, char *, char *, int, Boolean *);
extern XtPointer BX_DOUBLE(double);
extern XtPointer BX_SINGLE(float);
extern void BX_MENU_POST(Widget, XtPointer, XEvent *, Boolean *);
extern Pixmap XPM_PIXMAP(Widget, char **);
extern void BX_SET_BACKGROUND_COLOR(Widget, ArgList, Cardinal *, Pixel);


// Begin user code block <head>

#include <Xm/Protocols.h>
#include <iomanip.h>

Cstring MainWindow::ms_sAtomNameWindowID    = "DTDISPLAY_WINDOW_ID";
Cstring MainWindow::ms_sAtomNameImageUpdate = "DTDISPLAY_IMAGE_UPDATE";
Cstring MainWindow::ms_sAtomNameReflnUpdate = "DTDISPLAY_REFLN_UPDATE";
Cstring MainWindow::ms_sAtomNameBeamCenterUpdate = "DTDISPLAY_BEAMCENTER_UPDATE";
// End user code block <head>

//
// This table is used to define class resources that are placed
// in app-defaults. This table is necessary so each instance
// of this class has the proper default resource values set.
// This eliminates the need for each instance to have
// its own app-defaults values. This table must be NULL terminated.
//
#if defined(cxx_bx_compat)

Boolean MainWindow::_initAppDefaults = True;
UIAppDefault  MainWindow::_appDefaults[] = {
    {"mbError", NULL, "dialogTitle", NULL},
    {"mbError", NULL, "cancelLabelString", NULL},
    {"mbError", NULL, "messageString", NULL},
    {"mbProgress", NULL, "dialogTitle", NULL},
    {"mbProgress", NULL, "cancelLabelString", NULL},
    {"mbProgress", NULL, "messageString", NULL},
    {"fmViewHeader", NULL, "dialogTitle", NULL},
    {"pbViewHeaderDismiss", NULL, "labelString", NULL},
    {"tfViewHeader", NULL, "scrollLeftSide", NULL},
    {"xmDialogShell3", NULL, "title", NULL},
    {"mbViewZoomPan", NULL, "dialogTitle", NULL},
    {"mbViewZoomPan", NULL, "messageString", NULL},
    {"cbFile", NULL, "labelString", NULL},
    {"cbFileNew", NULL, "labelString", NULL},
    {"pbFileNewImage", NULL, "labelString", NULL},
    {"pbFileNewScan", NULL, "labelString", NULL},
    {"pbFileNewOverlay", NULL, "labelString", NULL},
    {"pbFileNewTile", NULL, "labelString", NULL},
    {"pbFileNewUnderlay", NULL, "labelString", NULL},
    {"pbFileNewMovie", NULL, "labelString", NULL},
    {"pbFileNewAverage", NULL, "labelString", NULL},
    {"pbFileNewStats", NULL, "labelString", NULL},
    {"pbFileOpen", NULL, "labelString", NULL},
    {"pbFileSaveAs", NULL, "labelString", NULL},
    {"pbFileSaveHeader", NULL, "labelString", NULL},
    {"pbFileTemplate", NULL, "labelString", NULL},
    {"pbFileLoad", NULL, "labelString", NULL},
    {"pbFileWrite", NULL, "labelString", NULL},
    {"pbFilePrefer", NULL, "labelString", NULL},
    {"pbFilePrint", NULL, "labelString", NULL},
    {"cbFileListen", NULL, "labelString", NULL},
    {"tbFileListenIntegrate", NULL, "labelString", NULL},
    {"tbFileListenCollect", NULL, "labelString", NULL},
    {"tbFileListenOther", NULL, "labelString", NULL},
    {"pbFileExit", NULL, "labelString", NULL},
    {"cbEdit", NULL, "labelString", NULL},
    {"pbEditImage", NULL, "labelString", NULL},
    {"pbEditRefln", NULL, "labelString", NULL},
    {"pbEditClear", NULL, "labelString", NULL},
    {"pbEditDelRef", NULL, "labelString", NULL},
    {"tbEditErase", NULL, "labelString", NULL},
    {"pbEditBeam", NULL, "labelString", NULL},
    {"pbEditHeader", NULL, "labelString", NULL},
    {"cbView", NULL, "labelString", NULL},
    {"pbViewRefresh", NULL, "labelString", NULL},
    {"pbViewZoom", NULL, "labelString", NULL},
    {"pbViewUnzoom", NULL, "labelString", NULL},
    {"pbViewPan", NULL, "labelString", NULL},
    {"pbViewHeader", NULL, "labelString", NULL},
    {"tbViewCalc", NULL, "labelString", NULL},
    {"tbViewObs", NULL, "labelString", NULL},
    {"tbViewReso", NULL, "labelString", NULL},
    {"tbViewMeasure", NULL, "labelString", NULL},
    {"tbViewPlot", NULL, "labelString", NULL},
    {"tbViewPixel", NULL, "labelString", NULL},
    {"cbHelp", NULL, "labelString", NULL},
    {"pbHelpHTML", NULL, "labelString", NULL},
    {"pbHelpAbout", NULL, "labelString", NULL},
    {"pbHelpRefln", NULL, "labelString", NULL},
    {"cbUtils", NULL, "labelString", NULL},
    {"pbUtilsProcess", NULL, "labelString", NULL},
    {"pbUtilsProcessExternHKL", NULL, "labelString", NULL},
    {"pbUtilsProcessExternXDS", NULL, "labelString", NULL},
    {"pbUtilsProcessExternMOSFLM", NULL, "labelString", NULL},
    {"pbUtilsProcessExtern", NULL, "labelString", NULL},
    {"daImageSmall", NULL, "background", NULL},
    {"foMainTop", NULL, "paneMinimum", NULL},
    {"foMainTop", NULL, "paneMaximum", NULL},
    {"foMainTop", NULL, "height", NULL},
    {"tbCursorBeam", NULL, "labelString", NULL},
    {"tbCursorSpot", NULL, "labelString", NULL},
    {"tbCursorMeasure", NULL, "labelString", NULL},
    {"tbCursorRect", NULL, "labelString", NULL},
    {"lbImageNum", NULL, "labelString", NULL},
    {"pbImageNext", NULL, "labelString", NULL},
    {"pbImagePrev", NULL, "labelString", NULL},
    {"tfOutput", NULL, "value", NULL},
    {"foMainMid", NULL, "paneMinimum", NULL},
    {"foMainMid", NULL, "paneMaximum", NULL},
    {"foMainMid", NULL, "height", NULL},
    {"lbRotStart", NULL, "labelString", NULL},
    {"tfRotStart", NULL, "topOffset", NULL},
    {"lbRotEnd", NULL, "labelString", NULL},
    {"tfRotEnd", NULL, "topOffset", NULL},
    {"tfDetDist", NULL, "topOffset", NULL},
    {"lbDetDist", NULL, "labelString", NULL},
    {"lbDetSwing", NULL, "labelString", NULL},
    {"tfDetSwing", NULL, "topOffset", NULL},
    {"tfWavelength", NULL, "topOffset", NULL},
    {"lbWavelength", NULL, "labelString", NULL},
    {"daImageBig", NULL, "background", NULL},
    {NULL, NULL, NULL, NULL}
};
#endif

// These are default resources for widgets in objects of this class
// All resources will be prepended by *<name> at instantiation,
// where <name> is the name of the specific instance, as well as the
// name of the baseWidget. These are only defaults, and may be overriden
// in a resource file by providing a more specific resource name

String  MainWindow::_defaultMainWindowResources[] = {
        NULL
};

//
// Old style constructor, for compatibility only.
//
MainWindow::MainWindow(const char *name, Widget parent) : 
    UIComponent(name)

// Begin user code block <alt_superclass>
// End user code block <alt_superclass>
{
    
    // Begin user code block <alt_constructor>
    // End user code block <alt_constructor>
    create(parent);
}

//
// Class Constructor.
//
MainWindow::MainWindow(const char *name) : UIComponent(name)

// Begin user code block <superclass>
// End user code block <superclass>
{
    
    // Begin user code block <constructor>

    m_poImage        = NULL;
    m_poHeader       = NULL;
    m_poScan         = NULL;
    m_poRotation     = NULL;
    m_poDetector     = NULL;
    m_poSource       = NULL;
    m_poReflnlist    = NULL;
    m_poColormap     = NULL;
    m_poXdisplay     = NULL;
    m_poXdisplay1    = NULL;
    m_poXhelp        = NULL;
    m_poXcursor      = NULL;
    m_poXprop        = NULL;
    m_po3Ddata       = new C3Ddata(1, 1, 1, 0, 0, 0);

    m_nDefaultImageSize = (1024 * 1024 * 2) + 2048;
    m_fS0[0]         =  0.0;
    m_fS0[1]         =  0.0;
    m_fS0[2]         =  -1.0;
    m_fWavelength    = 1.0;
    m_fDetDist       = 100.00;
    m_fDetSwing      = 0.0;
    m_fPrevPoint[0]  = 0.0;      // Prev point's mm coordinate
    m_fPrevPoint[1]  = 0.0;     
    m_fPrevPoint[2]  = 99999.99; // Prev point's resolution in Angstroms
    m_fPrevPointX[0] = 0.0;      // Prev point's reciprocal lattice coordinate.
    m_fPrevPointX[1] = 0.0;
    m_fPrevPointX[2] = 0.0;

    m_sNoHeader      = "Image header unavailable.\n\nUse \"File Open...\" to get one.";
    m_sFilename      = ""; //No filename available                                ";
    m_sHeaderFilename = "dtdisplay.head";

    m_bEventHandlerInstalled = False;
    m_nEraseMode      = 0;
    m_nProgressCancel = 0;
    m_ptClientDataStructs = new UICallbackStruct[200];

    // End user code block <constructor>
}


//
// Minimal Destructor. Base class destroys widgets.
//
MainWindow::~MainWindow() 
{
    
    // Begin user code block <destructor>

  // JWP: Destructor does not seem to be called!
  // vDestroy();

  if (NULL != m_ptClientDataStructs)
    {
      delete [] m_ptClientDataStructs;
      m_ptClientDataStructs = NULL;
    }
    // End user code block <destructor>
    delete []  _clientDataStructs;
}

//
// Handle creation of all widgets in the class.
//
void MainWindow::create(Widget parent) 
{
    Cardinal ac = 0;
    Arg      args[256];
    Cardinal cdc = 0;
    Boolean  argok = False;
    
    _clientDataStructs = new UICallbackStruct[169];
    
    //
    // Load any class-defaulted resources for this object.
    //
    setDefaultResources(parent, _defaultMainWindowResources);
    
#if defined(cxx_bx_compat)
    //
    // Setup app-defaults fallback table if not already done.
    //
    if (_initAppDefaults)
    {
        initAppDefaults(parent, "MainWindow", _appDefaults);
        _initAppDefaults = False;
    }
    //
    // Now set the app-defaults for this instance.
    //
    setAppDefaults(parent, _appDefaults, _name, False);
#endif
    
    //
    // Register the converters for the widgets.
    //
    RegisterBxConverters(XtWidgetToApplicationContext(parent));
    XtInitializeWidgetClass((WidgetClass)xmMainWindowWidgetClass);
    XtInitializeWidgetClass((WidgetClass)xmDialogShellWidgetClass);
    XtInitializeWidgetClass((WidgetClass)xmFileSelectionBoxWidgetClass);
    XtInitializeWidgetClass((WidgetClass)xmSelectionBoxWidgetClass);
    XtInitializeWidgetClass((WidgetClass)xmMessageBoxWidgetClass);
    XtInitializeWidgetClass((WidgetClass)xmFormWidgetClass);
    XtInitializeWidgetClass((WidgetClass)xmScaleWidgetClass);
    XtInitializeWidgetClass((WidgetClass)xmFormWidgetClass);
    XtInitializeWidgetClass((WidgetClass)xmPushButtonWidgetClass);
    XtInitializeWidgetClass((WidgetClass)xmSeparatorWidgetClass);
    XtInitializeWidgetClass((WidgetClass)xmScrolledWindowWidgetClass);
    XtInitializeWidgetClass((WidgetClass)xmTextWidgetClass);
    XtInitializeWidgetClass((WidgetClass)xmRowColumnWidgetClass);
    XtInitializeWidgetClass((WidgetClass)xmCascadeButtonWidgetClass);
    XtInitializeWidgetClass((WidgetClass)xmRowColumnWidgetClass);
    XtInitializeWidgetClass((WidgetClass)xmToggleButtonWidgetClass);
    XtInitializeWidgetClass((WidgetClass)xmFrameWidgetClass);
    XtInitializeWidgetClass((WidgetClass)xmDrawingAreaWidgetClass);
    XtInitializeWidgetClass((WidgetClass)xmPanedWindowWidgetClass);
    XtInitializeWidgetClass((WidgetClass)xmLabelWidgetClass);
    XtInitializeWidgetClass((WidgetClass)xmTextFieldWidgetClass);
    
    //
    // Create an unmanaged widget as the top of the hierarchy.
    //
    
    ac = 0;
    XtSetArg(args[ac], XmNx, 43); ac++;
    XtSetArg(args[ac], XmNy, 511); ac++;
    XtSetArg(args[ac], XmNwidth, 1021); ac++;
    XtSetArg(args[ac], XmNheight, 751); ac++;
    _MainWindow = XmCreateMainWindow(parent,
        _name,
        args, 
        ac);
    
    _w = _MainWindow;
    //
    // Add a callback to guard against widget destruction..
    //
    installDestroyHandler();
    
    ac = 0;
    XtSetArg(args[ac], XmNwidth, 918); ac++;
    XtSetArg(args[ac], XmNheight, 684); ac++;
    _xmDialogShell6 = XtCreatePopupShell("xmDialogShell6",
        xmDialogShellWidgetClass,
        _MainWindow,
        args, 
        ac);
    
#if defined(cxx_bx_compat)
    setAppDefaults(_xmDialogShell6, _appDefaults, "cUIprintSelect", True);
#endif
    _cUIprintSelect = new CUIprintSelect("cUIprintSelect");
    
    // Begin user code block <new_cUIprintSelect>
    // End user code block <new_cUIprintSelect>
    
    _cUIprintSelect->create(_xmDialogShell6);
    
    //
    // Set exposed resources.
    //
    ac = 0;
    XtSetArg(args[ac], XmNx, 1086); ac++;
    XtSetArg(args[ac], XmNy, 632); ac++;
    XtSetArg(args[ac], XmNwidth, 918); ac++;
    XtSetArg(args[ac], XmNheight, 684); ac++;
    XtSetValues(_cUIprintSelect->baseWidget(), args, ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNwidth, 553); ac++;
    XtSetArg(args[ac], XmNheight, 424); ac++;
    _xmDialogShell5 = XtCreatePopupShell("xmDialogShell5",
        xmDialogShellWidgetClass,
        _MainWindow,
        args, 
        ac);
    
#if defined(cxx_bx_compat)
    setAppDefaults(_xmDialogShell5, _appDefaults, "cUIreflnfileSelect", True);
#endif
    _cUIreflnfileSelect = new CUIreflnfileSelect("cUIreflnfileSelect");
    
    // Begin user code block <new_cUIreflnfileSelect>
    // End user code block <new_cUIreflnfileSelect>
    
    _cUIreflnfileSelect->create(_xmDialogShell5);
    
    //
    // Set exposed resources.
    //
    ac = 0;
    XtSetArg(args[ac], XmNx, 273); ac++;
    XtSetArg(args[ac], XmNy, 32); ac++;
    XtSetArg(args[ac], XmNwidth, 553); ac++;
    XtSetArg(args[ac], XmNheight, 424); ac++;
    XtSetValues(_cUIreflnfileSelect->baseWidget(), args, ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNwidth, 391); ac++;
    XtSetArg(args[ac], XmNheight, 347); ac++;
    _xmDialogShell1 = XtCreatePopupShell("xmDialogShell1",
        xmDialogShellWidgetClass,
        _MainWindow,
        args, 
        ac);
    
#if defined(cxx_bx_compat)
    setAppDefaults(_xmDialogShell1, _appDefaults, "cUIimageviewprops", True);
#endif
    _cUIimageviewprops = new CUIimageviewprops("cUIimageviewprops");
    
    // Begin user code block <new_cUIimageviewprops>
    // End user code block <new_cUIimageviewprops>
    
    _cUIimageviewprops->create(_xmDialogShell1);
    
    //
    // Set exposed resources.
    //
    ac = 0;
    XtSetArg(args[ac], XmNx, 354); ac++;
    XtSetArg(args[ac], XmNy, 32); ac++;
    XtSetArg(args[ac], XmNwidth, 391); ac++;
    XtSetArg(args[ac], XmNheight, 347); ac++;
    XtSetValues(_cUIimageviewprops->baseWidget(), args, ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNwidth, 416); ac++;
    XtSetArg(args[ac], XmNheight, 216); ac++;
    _xmDialogShell9 = XtCreatePopupShell("xmDialogShell9",
        xmDialogShellWidgetClass,
        _MainWindow,
        args, 
        ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNdefaultButtonType, XmDIALOG_CANCEL_BUTTON); ac++;
    XtSetArg(args[ac], XmNdialogType, XmDIALOG_ERROR); ac++;
    XtSetArg(args[ac], XmNx, 341); ac++;
    XtSetArg(args[ac], XmNy, 32); ac++;
    XtSetArg(args[ac], XmNwidth, 416); ac++;
    XtSetArg(args[ac], XmNheight, 216); ac++;
    _mbError = XmCreateMessageBox(_xmDialogShell9,
        "mbError",
        args, 
        ac);
    
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_mbError,
        XmNcancelCallback,
        MainWindow::vProgressCancelCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    XtSetArg(args[ac], XmNwidth, 378); ac++;
    XtSetArg(args[ac], XmNheight, 202); ac++;
    _xmDialogShell8 = XtCreatePopupShell("xmDialogShell8",
        xmDialogShellWidgetClass,
        _MainWindow,
        args, 
        ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNx, 360); ac++;
    XtSetArg(args[ac], XmNy, 32); ac++;
    XtSetArg(args[ac], XmNwidth, 378); ac++;
    XtSetArg(args[ac], XmNheight, 202); ac++;
    _mbProgress = XmCreateMessageBox(_xmDialogShell8,
        "mbProgress",
        args, 
        ac);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_mbProgress,
        XmNcancelCallback,
        MainWindow::vProgressCancelCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    XtSetArg(args[ac], XmNresizePolicy, XmRESIZE_GROW); ac++;
    XtSetArg(args[ac], XmNx, 11); ac++;
    XtSetArg(args[ac], XmNy, 46); ac++;
    XtSetArg(args[ac], XmNwidth, 356); ac++;
    XtSetArg(args[ac], XmNheight, 74); ac++;
    _fmProgress = XmCreateForm(_mbProgress,
        "fmProgress",
        args, 
        ac);
    XtManageChild(_fmProgress);
    
    ac = 0;
    XtSetArg(args[ac], XmNscaleHeight, 50); ac++;
    XtSetArg(args[ac], XmNshowValue, True); ac++;
    XtSetArg(args[ac], XmNorientation, XmHORIZONTAL); ac++;
    XtSetArg(args[ac], XmNx, 0); ac++;
    XtSetArg(args[ac], XmNy, 0); ac++;
    XtSetArg(args[ac], XmNwidth, 356); ac++;
    XtSetArg(args[ac], XmNheight, 70); ac++;
    _scProgress = XmCreateScale(_fmProgress,
        "scProgress",
        args, 
        ac);
    XtManageChild(_scProgress);
    
    ac = 0;
    XtSetArg(args[ac], XmNwidth, 422); ac++;
    XtSetArg(args[ac], XmNheight, 439); ac++;
    _xmDialogShell2 = XtCreatePopupShell("xmDialogShell2",
        xmDialogShellWidgetClass,
        _MainWindow,
        args, 
        ac);
    
#if defined(cxx_bx_compat)
    setAppDefaults(_xmDialogShell2, _appDefaults, "cUIreflnviewprops", True);
#endif
    _cUIreflnviewprops = new CUIreflnviewprops("cUIreflnviewprops");
    
    // Begin user code block <new_cUIreflnviewprops>
    // End user code block <new_cUIreflnviewprops>
    
    _cUIreflnviewprops->create(_xmDialogShell2);
    
    //
    // Set exposed resources.
    //
    ac = 0;
    XtSetArg(args[ac], XmNx, 338); ac++;
    XtSetArg(args[ac], XmNy, 32); ac++;
    XtSetArg(args[ac], XmNwidth, 422); ac++;
    XtSetArg(args[ac], XmNheight, 439); ac++;
    XtSetValues(_cUIreflnviewprops->baseWidget(), args, ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNwidth, 636); ac++;
    XtSetArg(args[ac], XmNheight, 308); ac++;
    _xmDialogShell4 = XtCreatePopupShell("xmDialogShell4",
        xmDialogShellWidgetClass,
        _MainWindow,
        args, 
        ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNresizePolicy, XmRESIZE_GROW); ac++;
    XtSetArg(args[ac], XmNx, 986); ac++;
    XtSetArg(args[ac], XmNy, 844); ac++;
    XtSetArg(args[ac], XmNwidth, 636); ac++;
    XtSetArg(args[ac], XmNheight, 308); ac++;
    _fmViewHeader = XmCreateForm(_xmDialogShell4,
        "fmViewHeader",
        args, 
        ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNx, 260); ac++;
    XtSetArg(args[ac], XmNy, 258); ac++;
    XtSetArg(args[ac], XmNwidth, 100); ac++;
    XtSetArg(args[ac], XmNheight, 40); ac++;
    _pbViewHeaderDismiss = XmCreatePushButton(_fmViewHeader,
        "pbViewHeaderDismiss",
        args, 
        ac);
    XtManageChild(_pbViewHeaderDismiss);
    
    ac = 0;
    XtSetArg(args[ac], XmNx, 0); ac++;
    XtSetArg(args[ac], XmNy, 227); ac++;
    XtSetArg(args[ac], XmNwidth, 615); ac++;
    XtSetArg(args[ac], XmNheight, 20); ac++;
    _spViewHeader = XmCreateSeparator(_fmViewHeader,
        "spViewHeader",
        args, 
        ac);
    XtManageChild(_spViewHeader);
    
    ac = 0;
    XtSetArg(args[ac], XmNscrollingPolicy, XmAPPLICATION_DEFINED); ac++;
    XtSetArg(args[ac], XmNx, 0); ac++;
    XtSetArg(args[ac], XmNy, 0); ac++;
    XtSetArg(args[ac], XmNwidth, 636); ac++;
    XtSetArg(args[ac], XmNheight, 227); ac++;
    _swViewHeader = XmCreateScrolledWindow(_fmViewHeader,
        "swViewHeader",
        args, 
        ac);
    XtManageChild(_swViewHeader);
    
    ac = 0;
    XtSetArg(args[ac], XmNeditMode, XmMULTI_LINE_EDIT); ac++;
    _tfViewHeader = XmCreateText(_swViewHeader,
        "tfViewHeader",
        args, 
        ac);
    XtManageChild(_tfViewHeader);
    
    ac = 0;
    XtSetArg(args[ac], XmNwidth, 966); ac++;
    XtSetArg(args[ac], XmNheight, 594); ac++;
    _xmDialogShell3 = XtCreatePopupShell("xmDialogShell3",
        xmDialogShellWidgetClass,
        _MainWindow,
        args, 
        ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNx, 1074); ac++;
    XtSetArg(args[ac], XmNy, 594); ac++;
    XtSetArg(args[ac], XmNwidth, 966); ac++;
    XtSetArg(args[ac], XmNheight, 594); ac++;
    _mbViewZoomPan = XmCreateMessageBox(_xmDialogShell3,
        "mbViewZoomPan",
        args, 
        ac);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)"ViewZoom$$";
    XtAddCallback(_mbViewZoomPan,
        XmNhelpCallback,
        MainWindow::vHTMLHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    XtSetArg(args[ac], XmNwidth, 50); ac++;
    XtSetArg(args[ac], XmNheight, 432); ac++;
    _xmDialogShell = XtCreatePopupShell("xmDialogShell",
        xmDialogShellWidgetClass,
        _MainWindow,
        args, 
        ac);
    
#if defined(cxx_bx_compat)
    setAppDefaults(_xmDialogShell, _appDefaults, "cUIimagefileSelect", True);
#endif
    _cUIimagefileSelect = new CUIimagefileSelect("cUIimagefileSelect");
    
    // Begin user code block <new_cUIimagefileSelect>
    // End user code block <new_cUIimagefileSelect>
    
    _cUIimagefileSelect->create(_xmDialogShell);
    
    //
    // Set exposed resources.
    //
    
    ac = 0;
    XtSetArg(args[ac], XmNwidth, 1021); ac++;
    XtSetArg(args[ac], XmNheight, 35); ac++;
    _menuBar = XmCreateMenuBar(_MainWindow,
        "menuBar",
        args, 
        ac);
    XtManageChild(_menuBar);
    
    ac = 0;
    XtSetArg(args[ac], XmNx, 5); ac++;
    XtSetArg(args[ac], XmNy, 5); ac++;
    XtSetArg(args[ac], XmNwidth, 64); ac++;
    XtSetArg(args[ac], XmNheight, 25); ac++;
    _cbFile = XmCreateCascadeButton(_menuBar,
        "cbFile",
        args, 
        ac);
    XtManageChild(_cbFile);
    
    ac = 0;
    XtSetArg(args[ac], XmNx, 0); ac++;
    XtSetArg(args[ac], XmNy, 0); ac++;
    XtSetArg(args[ac], XmNwidth, 261); ac++;
    XtSetArg(args[ac], XmNheight, 305); ac++;
    _pmFile = XmCreatePulldownMenu(XtParent(_cbFile),
        "pmFile",
        args, 
        ac);
    
    ac = 0;
    _cbFileNew = XmCreateCascadeButton(_pmFile,
        "cbFileNew",
        args, 
        ac);
    XtManageChild(_cbFileNew);
    
    ac = 0;
    XtSetArg(args[ac], XmNx, 0); ac++;
    XtSetArg(args[ac], XmNy, 0); ac++;
    XtSetArg(args[ac], XmNwidth, 170); ac++;
    XtSetArg(args[ac], XmNheight, 222); ac++;
    _pmFileNew = XmCreatePulldownMenu(XtParent(_cbFileNew),
        "pmFileNew",
        args, 
        ac);
    
    ac = 0;
    _pbFileNewImage = XmCreatePushButton(_pmFileNew,
        "pbFileNewImage",
        args, 
        ac);
    XtManageChild(_pbFileNewImage);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbFileNewImage,
        XmNdisarmCallback,
        MainWindow::vUnpostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)"Read and display a new image file";
    XtAddCallback(_pbFileNewImage,
        XmNarmCallback,
        MainWindow::vPostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbFileNewImage,
        XmNactivateCallback,
        MainWindow::vFileSelectionPostCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    XtSetArg(args[ac], XmNsensitive, False); ac++;
    _pbFileNewScan = XmCreatePushButton(_pmFileNew,
        "pbFileNewScan",
        args, 
        ac);
    XtManageChild(_pbFileNewScan);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbFileNewScan,
        XmNdisarmCallback,
        MainWindow::vUnpostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)"Set new scan parameters for a series of images";
    XtAddCallback(_pbFileNewScan,
        XmNarmCallback,
        MainWindow::vPostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    _spFileNew1 = XmCreateSeparator(_pmFileNew,
        "spFileNew1",
        args, 
        ac);
    XtManageChild(_spFileNew1);
    
    ac = 0;
    XtSetArg(args[ac], XmNsensitive, True); ac++;
    _pbFileNewOverlay = XmCreatePushButton(_pmFileNew,
        "pbFileNewOverlay",
        args, 
        ac);
    XtManageChild(_pbFileNewOverlay);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbFileNewOverlay,
        XmNdisarmCallback,
        MainWindow::vUnpostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)"Overlay a series of images";
    XtAddCallback(_pbFileNewOverlay,
        XmNarmCallback,
        MainWindow::vPostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbFileNewOverlay,
        XmNactivateCallback,
        MainWindow::vFileSelectionPostCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    XtSetArg(args[ac], XmNsensitive, True); ac++;
    _pbFileNewTile = XmCreatePushButton(_pmFileNew,
        "pbFileNewTile",
        args, 
        ac);
    XtManageChild(_pbFileNewTile);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbFileNewTile,
        XmNdisarmCallback,
        MainWindow::vUnpostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)"Tile a series of images";
    XtAddCallback(_pbFileNewTile,
        XmNarmCallback,
        MainWindow::vPostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbFileNewTile,
        XmNactivateCallback,
        MainWindow::vFileSelectionPostCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    _pbFileNewUnderlay = XmCreatePushButton(_pmFileNew,
        "pbFileNewUnderlay",
        args, 
        ac);
    XtManageChild(_pbFileNewUnderlay);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbFileNewUnderlay,
        XmNdisarmCallback,
        MainWindow::vUnpostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)"Underlay a series of images";
    XtAddCallback(_pbFileNewUnderlay,
        XmNarmCallback,
        MainWindow::vPostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbFileNewUnderlay,
        XmNactivateCallback,
        MainWindow::vFileSelectionPostCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    _pbFileNewMovie = XmCreatePushButton(_pmFileNew,
        "pbFileNewMovie",
        args, 
        ac);
    XtManageChild(_pbFileNewMovie);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbFileNewMovie,
        XmNdisarmCallback,
        MainWindow::vUnpostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)"Make a movie of a series of images";
    XtAddCallback(_pbFileNewMovie,
        XmNarmCallback,
        MainWindow::vPostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbFileNewMovie,
        XmNactivateCallback,
        MainWindow::vFileSelectionPostCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    XtSetArg(args[ac], XmNsensitive, True); ac++;
    _pbFileNewAverage = XmCreatePushButton(_pmFileNew,
        "pbFileNewAverage",
        args, 
        ac);
    XtManageChild(_pbFileNewAverage);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbFileNewAverage,
        XmNdisarmCallback,
        MainWindow::vUnpostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)"Average a series of images";
    XtAddCallback(_pbFileNewAverage,
        XmNarmCallback,
        MainWindow::vPostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbFileNewAverage,
        XmNactivateCallback,
        MainWindow::vFileSelectionPostCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    XtSetArg(args[ac], XmNsensitive, False); ac++;
    _pbFileNewStats = XmCreatePushButton(_pmFileNew,
        "pbFileNewStats",
        args, 
        ac);
    XtManageChild(_pbFileNewStats);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbFileNewStats,
        XmNdisarmCallback,
        MainWindow::vUnpostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)"Tile a series of images";
    XtAddCallback(_pbFileNewStats,
        XmNarmCallback,
        MainWindow::vPostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbFileNewStats,
        XmNactivateCallback,
        MainWindow::vFileSelectionPostCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    XtSetArg(args[ac], XmNsubMenuId, _pmFileNew); ac++;
    XtSetValues(_cbFileNew, args, ac);
    
    ac = 0;
    _pbFileOpen = XmCreatePushButton(_pmFile,
        "pbFileOpen",
        args, 
        ac);
    XtManageChild(_pbFileOpen);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbFileOpen,
        XmNdisarmCallback,
        MainWindow::vUnpostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)"Open and read an image file";
    XtAddCallback(_pbFileOpen,
        XmNarmCallback,
        MainWindow::vPostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbFileOpen,
        XmNactivateCallback,
        MainWindow::vFileSelectionPostCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    XtSetArg(args[ac], XmNsensitive, True); ac++;
    _pbFileSaveAs = XmCreatePushButton(_pmFile,
        "pbFileSaveAs",
        args, 
        ac);
    XtManageChild(_pbFileSaveAs);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbFileSaveAs,
        XmNdisarmCallback,
        MainWindow::vUnpostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)"Save the displayed image to a new file";
    XtAddCallback(_pbFileSaveAs,
        XmNarmCallback,
        MainWindow::vPostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbFileSaveAs,
        XmNactivateCallback,
        MainWindow::vFileSelectionPostCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    XtSetArg(args[ac], XmNsensitive, True); ac++;
    _pbFileSaveHeader = XmCreatePushButton(_pmFile,
        "pbFileSaveHeader",
        args, 
        ac);
    XtManageChild(_pbFileSaveHeader);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbFileSaveHeader,
        XmNdisarmCallback,
        MainWindow::vUnpostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)"Save the header only to a new file";
    XtAddCallback(_pbFileSaveHeader,
        XmNarmCallback,
        MainWindow::vPostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbFileSaveHeader,
        XmNactivateCallback,
        MainWindow::vFileSelectionPostCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    _pbFileTemplate = XmCreatePushButton(_pmFile,
        "pbFileTemplate",
        args, 
        ac);
    XtManageChild(_pbFileTemplate);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbFileTemplate,
        XmNdisarmCallback,
        MainWindow::vUnpostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)"Set the image file template";
    XtAddCallback(_pbFileTemplate,
        XmNarmCallback,
        MainWindow::vPostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbFileTemplate,
        XmNactivateCallback,
        MainWindow::vFileSelectionPostCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    _spFile4 = XmCreateSeparator(_pmFile,
        "spFile4",
        args, 
        ac);
    XtManageChild(_spFile4);
    
    ac = 0;
    XtSetArg(args[ac], XmNsensitive, True); ac++;
    _pbFileLoad = XmCreatePushButton(_pmFile,
        "pbFileLoad",
        args, 
        ac);
    XtManageChild(_pbFileLoad);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbFileLoad,
        XmNdisarmCallback,
        MainWindow::vUnpostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)"Open and read a reflection file";
    XtAddCallback(_pbFileLoad,
        XmNarmCallback,
        MainWindow::vPostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbFileLoad,
        XmNactivateCallback,
        MainWindow::vLoadReflnCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    XtSetArg(args[ac], XmNsensitive, True); ac++;
    _pbFileWrite = XmCreatePushButton(_pmFile,
        "pbFileWrite",
        args, 
        ac);
    XtManageChild(_pbFileWrite);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbFileWrite,
        XmNdisarmCallback,
        MainWindow::vUnpostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)"Write a reflection file";
    XtAddCallback(_pbFileWrite,
        XmNarmCallback,
        MainWindow::vPostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbFileWrite,
        XmNactivateCallback,
        MainWindow::vLoadReflnCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    _spFile1 = XmCreateSeparator(_pmFile,
        "spFile1",
        args, 
        ac);
    XtManageChild(_spFile1);
    
    ac = 0;
    XtSetArg(args[ac], XmNsensitive, False); ac++;
    _pbFilePrefer = XmCreatePushButton(_pmFile,
        "pbFilePrefer",
        args, 
        ac);
    XtManageChild(_pbFilePrefer);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbFilePrefer,
        XmNdisarmCallback,
        MainWindow::vUnpostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)"Set user preferences";
    XtAddCallback(_pbFilePrefer,
        XmNarmCallback,
        MainWindow::vPostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    XtSetArg(args[ac], XmNsensitive, True); ac++;
    _pbFilePrint = XmCreatePushButton(_pmFile,
        "pbFilePrint",
        args, 
        ac);
    XtManageChild(_pbFilePrint);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbFilePrint,
        XmNdisarmCallback,
        MainWindow::vUnpostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)"Print or PostScript the displayed image";
    XtAddCallback(_pbFilePrint,
        XmNarmCallback,
        MainWindow::vPostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbFilePrint,
        XmNactivateCallback,
        MainWindow::vPostPrintCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    _spFile2 = XmCreateSeparator(_pmFile,
        "spFile2",
        args, 
        ac);
    XtManageChild(_spFile2);
    
    ac = 0;
    _cbFileListen = XmCreateCascadeButton(_pmFile,
        "cbFileListen",
        args, 
        ac);
    XtManageChild(_cbFileListen);
    
    ac = 0;
    XtSetArg(args[ac], XmNx, 0); ac++;
    XtSetArg(args[ac], XmNy, 0); ac++;
    XtSetArg(args[ac], XmNwidth, 159); ac++;
    XtSetArg(args[ac], XmNheight, 79); ac++;
    _pmFileListen = XmCreatePulldownMenu(XtParent(_cbFileListen),
        "pmFileListen",
        args, 
        ac);
    
    ac = 0;
    _tbFileListenIntegrate = XmCreateToggleButton(_pmFileListen,
        "tbFileListenIntegrate",
        args, 
        ac);
    XtManageChild(_tbFileListenIntegrate);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tbFileListenIntegrate,
        XmNvalueChangedCallback,
        MainWindow::vFileListenCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tbFileListenIntegrate,
        XmNdisarmCallback,
        MainWindow::vUnpostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)"Respond to updates from dtintegrate";
    XtAddCallback(_tbFileListenIntegrate,
        XmNarmCallback,
        MainWindow::vPostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    _tbFileListenCollect = XmCreateToggleButton(_pmFileListen,
        "tbFileListenCollect",
        args, 
        ac);
    XtManageChild(_tbFileListenCollect);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tbFileListenCollect,
        XmNvalueChangedCallback,
        MainWindow::vFileListenCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tbFileListenCollect,
        XmNdisarmCallback,
        MainWindow::vUnpostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)"Respond to updates from dtcollect";
    XtAddCallback(_tbFileListenCollect,
        XmNarmCallback,
        MainWindow::vPostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    _tbFileListenOther = XmCreateToggleButton(_pmFileListen,
        "tbFileListenOther",
        args, 
        ac);
    XtManageChild(_tbFileListenOther);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tbFileListenOther,
        XmNvalueChangedCallback,
        MainWindow::vFileListenCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tbFileListenOther,
        XmNdisarmCallback,
        MainWindow::vUnpostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)"Respond to updates from other than dtcollect";
    XtAddCallback(_tbFileListenOther,
        XmNarmCallback,
        MainWindow::vPostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    XtSetArg(args[ac], XmNsubMenuId, _pmFileListen); ac++;
    XtSetValues(_cbFileListen, args, ac);
    
    ac = 0;
    _spFile3 = XmCreateSeparator(_pmFile,
        "spFile3",
        args, 
        ac);
    XtManageChild(_spFile3);
    
    ac = 0;
    _pbFileExit = XmCreatePushButton(_pmFile,
        "pbFileExit",
        args, 
        ac);
    XtManageChild(_pbFileExit);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbFileExit,
        XmNdisarmCallback,
        MainWindow::vUnpostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)"Exit from the program";
    XtAddCallback(_pbFileExit,
        XmNarmCallback,
        MainWindow::vPostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbFileExit,
        XmNactivateCallback,
        MainWindow::vExitCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    XtSetArg(args[ac], XmNsubMenuId, _pmFile); ac++;
    XtSetValues(_cbFile, args, ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNx, 69); ac++;
    XtSetArg(args[ac], XmNy, 5); ac++;
    XtSetArg(args[ac], XmNwidth, 64); ac++;
    XtSetArg(args[ac], XmNheight, 25); ac++;
    _cbEdit = XmCreateCascadeButton(_menuBar,
        "cbEdit",
        args, 
        ac);
    XtManageChild(_cbEdit);
    
    ac = 0;
    XtSetArg(args[ac], XmNx, 0); ac++;
    XtSetArg(args[ac], XmNy, 0); ac++;
    XtSetArg(args[ac], XmNwidth, 315); ac++;
    XtSetArg(args[ac], XmNheight, 193); ac++;
    _pmEdit = XmCreatePulldownMenu(XtParent(_cbEdit),
        "pmEdit",
        args, 
        ac);
    
    ac = 0;
    _pbEditImage = XmCreatePushButton(_pmEdit,
        "pbEditImage",
        args, 
        ac);
    XtManageChild(_pbEditImage);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbEditImage,
        XmNdisarmCallback,
        MainWindow::vUnpostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)"Edit the viewing properties of the image";
    XtAddCallback(_pbEditImage,
        XmNarmCallback,
        MainWindow::vPostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbEditImage,
        XmNactivateCallback,
        MainWindow::vPopupImagePropsCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    XtSetArg(args[ac], XmNsensitive, True); ac++;
    _pbEditRefln = XmCreatePushButton(_pmEdit,
        "pbEditRefln",
        args, 
        ac);
    XtManageChild(_pbEditRefln);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbEditRefln,
        XmNdisarmCallback,
        MainWindow::vUnpostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)"Edit the viewing properties of the reflection list";
    XtAddCallback(_pbEditRefln,
        XmNarmCallback,
        MainWindow::vPostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbEditRefln,
        XmNactivateCallback,
        MainWindow::vPopupReflnPropsCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    _pbEditClear = XmCreatePushButton(_pmEdit,
        "pbEditClear",
        args, 
        ac);
    XtManageChild(_pbEditClear);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbEditClear,
        XmNdisarmCallback,
        MainWindow::vUnpostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)"Clear the selected output in the scrolled text area";
    XtAddCallback(_pbEditClear,
        XmNarmCallback,
        MainWindow::vPostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbEditClear,
        XmNactivateCallback,
        MainWindow::vClearOutputCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    _pbEditDelRef = XmCreatePushButton(_pmEdit,
        "pbEditDelRef",
        args, 
        ac);
    XtManageChild(_pbEditDelRef);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbEditDelRef,
        XmNdisarmCallback,
        MainWindow::vUnpostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)"Delete 10% least intense reflections";
    XtAddCallback(_pbEditDelRef,
        XmNarmCallback,
        MainWindow::vPostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbEditDelRef,
        XmNactivateCallback,
        MainWindow::vDeleteReflnsCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    _spEdit = XmCreateSeparator(_pmEdit,
        "spEdit",
        args, 
        ac);
    XtManageChild(_spEdit);
    
    ac = 0;
    _tbEditErase = XmCreateToggleButton(_pmEdit,
        "tbEditErase",
        args, 
        ac);
    XtManageChild(_tbEditErase);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tbEditErase,
        XmNvalueChangedCallback,
        MainWindow::vEraseToggleCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tbEditErase,
        XmNdisarmCallback,
        MainWindow::vUnpostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)"Use mouse to erase/edit image pixels";
    XtAddCallback(_tbEditErase,
        XmNarmCallback,
        MainWindow::vPostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    _pbEditBeam = XmCreatePushButton(_pmEdit,
        "pbEditBeam",
        args, 
        ac);
    XtManageChild(_pbEditBeam);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbEditBeam,
        XmNdisarmCallback,
        MainWindow::vUnpostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)"Pop-up help message on editing direct beam position";
    XtAddCallback(_pbEditBeam,
        XmNarmCallback,
        MainWindow::vPostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbEditBeam,
        XmNactivateCallback,
        MainWindow::vZoomMsgPopupCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    _pbEditHeader = XmCreatePushButton(_pmEdit,
        "pbEditHeader",
        args, 
        ac);
    XtManageChild(_pbEditHeader);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbEditHeader,
        XmNdisarmCallback,
        MainWindow::vUnpostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)"Edit the header ";
    XtAddCallback(_pbEditHeader,
        XmNarmCallback,
        MainWindow::vPostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbEditHeader,
        XmNactivateCallback,
        MainWindow::vZoomMsgPopupCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    XtSetArg(args[ac], XmNsubMenuId, _pmEdit); ac++;
    XtSetValues(_cbEdit, args, ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNx, 133); ac++;
    XtSetArg(args[ac], XmNy, 5); ac++;
    XtSetArg(args[ac], XmNwidth, 64); ac++;
    XtSetArg(args[ac], XmNheight, 25); ac++;
    _cbView = XmCreateCascadeButton(_menuBar,
        "cbView",
        args, 
        ac);
    XtManageChild(_cbView);
    
    ac = 0;
    XtSetArg(args[ac], XmNx, 0); ac++;
    XtSetArg(args[ac], XmNy, 0); ac++;
    XtSetArg(args[ac], XmNwidth, 267); ac++;
    XtSetArg(args[ac], XmNheight, 291); ac++;
    _pmView = XmCreatePulldownMenu(XtParent(_cbView),
        "pmView",
        args, 
        ac);
    
    ac = 0;
    _pbViewRefresh = XmCreatePushButton(_pmView,
        "pbViewRefresh",
        args, 
        ac);
    XtManageChild(_pbViewRefresh);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbViewRefresh,
        XmNdisarmCallback,
        MainWindow::vUnpostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)"Refresh the image drawing area";
    XtAddCallback(_pbViewRefresh,
        XmNarmCallback,
        MainWindow::vPostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbViewRefresh,
        XmNactivateCallback,
        MainWindow::vViewRefreshCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    _pbViewZoom = XmCreatePushButton(_pmView,
        "pbViewZoom",
        args, 
        ac);
    XtManageChild(_pbViewZoom);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbViewZoom,
        XmNdisarmCallback,
        MainWindow::vUnpostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)"Pop-up a how to zoom message";
    XtAddCallback(_pbViewZoom,
        XmNarmCallback,
        MainWindow::vPostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbViewZoom,
        XmNactivateCallback,
        MainWindow::vZoomMsgPopupCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    _pbViewUnzoom = XmCreatePushButton(_pmView,
        "pbViewUnzoom",
        args, 
        ac);
    XtManageChild(_pbViewUnzoom);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbViewUnzoom,
        XmNdisarmCallback,
        MainWindow::vUnpostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)"Unzoom the image display";
    XtAddCallback(_pbViewUnzoom,
        XmNarmCallback,
        MainWindow::vPostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbViewUnzoom,
        XmNactivateCallback,
        MainWindow::vUnzoomCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    XtSetArg(args[ac], XmNsensitive, True); ac++;
    _pbViewPan = XmCreatePushButton(_pmView,
        "pbViewPan",
        args, 
        ac);
    XtManageChild(_pbViewPan);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbViewPan,
        XmNdisarmCallback,
        MainWindow::vUnpostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)"Learn how to pan the image";
    XtAddCallback(_pbViewPan,
        XmNarmCallback,
        MainWindow::vPostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbViewPan,
        XmNactivateCallback,
        MainWindow::vZoomMsgPopupCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    _spView1 = XmCreateSeparator(_pmView,
        "spView1",
        args, 
        ac);
    XtManageChild(_spView1);
    
    ac = 0;
    _pbViewHeader = XmCreatePushButton(_pmView,
        "pbViewHeader",
        args, 
        ac);
    XtManageChild(_pbViewHeader);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbViewHeader,
        XmNdisarmCallback,
        MainWindow::vUnpostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)"Display the image header";
    XtAddCallback(_pbViewHeader,
        XmNarmCallback,
        MainWindow::vPostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbViewHeader,
        XmNactivateCallback,
        MainWindow::vViewHeaderCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    XtSetArg(args[ac], XmNsensitive, False); ac++;
    _tbViewCalc = XmCreateToggleButton(_pmView,
        "tbViewCalc",
        args, 
        ac);
    XtManageChild(_tbViewCalc);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tbViewCalc,
        XmNdisarmCallback,
        MainWindow::vUnpostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)"Plot calculated reflection positions, if available";
    XtAddCallback(_tbViewCalc,
        XmNarmCallback,
        MainWindow::vPostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    _tbViewObs = XmCreateToggleButton(_pmView,
        "tbViewObs",
        args, 
        ac);
    XtManageChild(_tbViewObs);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tbViewObs,
        XmNvalueChangedCallback,
        MainWindow::vPlotReflnListCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tbViewObs,
        XmNdisarmCallback,
        MainWindow::vUnpostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)"Plot observed reflection positions, if available";
    XtAddCallback(_tbViewObs,
        XmNarmCallback,
        MainWindow::vPostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    XtSetArg(args[ac], XmNsensitive, True); ac++;
    XtSetArg(args[ac], XmNindicatorOn, True); ac++;
    XtSetArg(args[ac], XmNvisibleWhenOff, False); ac++;
    XtSetArg(args[ac], XmNrecomputeSize, True); ac++;
    _tbViewReso = XmCreateToggleButton(_pmView,
        "tbViewReso",
        args, 
        ac);
    XtManageChild(_tbViewReso);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tbViewReso,
        XmNvalueChangedCallback,
        MainWindow::vDrawResoCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tbViewReso,
        XmNdisarmCallback,
        MainWindow::vUnpostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)"Draw isoresolution arcs or circles";
    XtAddCallback(_tbViewReso,
        XmNarmCallback,
        MainWindow::vPostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    _tbViewMeasure = XmCreateToggleButton(_pmView,
        "tbViewMeasure",
        args, 
        ac);
    XtManageChild(_tbViewMeasure);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tbViewMeasure,
        XmNvalueChangedCallback,
        MainWindow::vDrawResoCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tbViewMeasure,
        XmNdisarmCallback,
        MainWindow::vUnpostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)"Draw isoresolution arcs or circles at ice diffraction positions";
    XtAddCallback(_tbViewMeasure,
        XmNarmCallback,
        MainWindow::vPostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    XtSetArg(args[ac], XmNsensitive, False); ac++;
    _tbViewPlot = XmCreateToggleButton(_pmView,
        "tbViewPlot",
        args, 
        ac);
    XtManageChild(_tbViewPlot);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tbViewPlot,
        XmNdisarmCallback,
        MainWindow::vUnpostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)"Graph pixel values between two points";
    XtAddCallback(_tbViewPlot,
        XmNarmCallback,
        MainWindow::vPostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    XtSetArg(args[ac], XmNsensitive, False); ac++;
    XtSetArg(args[ac], XmNrecomputeSize, True); ac++;
    _tbViewPixel = XmCreateToggleButton(_pmView,
        "tbViewPixel",
        args, 
        ac);
    XtManageChild(_tbViewPixel);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tbViewPixel,
        XmNdisarmCallback,
        MainWindow::vUnpostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)"View pixel values at selected point";
    XtAddCallback(_tbViewPixel,
        XmNarmCallback,
        MainWindow::vPostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    XtSetArg(args[ac], XmNsubMenuId, _pmView); ac++;
    XtSetValues(_cbView, args, ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNx, 952); ac++;
    XtSetArg(args[ac], XmNy, 5); ac++;
    XtSetArg(args[ac], XmNwidth, 64); ac++;
    XtSetArg(args[ac], XmNheight, 25); ac++;
    _cbHelp = XmCreateCascadeButton(_menuBar,
        "cbHelp",
        args, 
        ac);
    XtManageChild(_cbHelp);
    
    ac = 0;
    XtSetArg(args[ac], XmNx, 0); ac++;
    XtSetArg(args[ac], XmNy, 0); ac++;
    XtSetArg(args[ac], XmNwidth, 290); ac++;
    XtSetArg(args[ac], XmNheight, 85); ac++;
    _pmHelp = XmCreatePulldownMenu(XtParent(_cbHelp),
        "pmHelp",
        args, 
        ac);
    
    ac = 0;
    _pbHelpHTML = XmCreatePushButton(_pmHelp,
        "pbHelpHTML",
        args, 
        ac);
    XtManageChild(_pbHelpHTML);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbHelpHTML,
        XmNdisarmCallback,
        MainWindow::vUnpostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)"This activates HTML help";
    XtAddCallback(_pbHelpHTML,
        XmNarmCallback,
        MainWindow::vPostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)"HelpHTML$$";
    XtAddCallback(_pbHelpHTML,
        XmNactivateCallback,
        MainWindow::vHTMLHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    _pbHelpAbout = XmCreatePushButton(_pmHelp,
        "pbHelpAbout",
        args, 
        ac);
    XtManageChild(_pbHelpAbout);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbHelpAbout,
        XmNdisarmCallback,
        MainWindow::vUnpostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)"Show version information";
    XtAddCallback(_pbHelpAbout,
        XmNarmCallback,
        MainWindow::vPostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbHelpAbout,
        XmNactivateCallback,
        MainWindow::vPopDialogCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    _pbHelpRefln = XmCreatePushButton(_pmHelp,
        "pbHelpRefln",
        args, 
        ac);
    XtManageChild(_pbHelpRefln);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbHelpRefln,
        XmNdisarmCallback,
        MainWindow::vUnpostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)"Info on refln colors";
    XtAddCallback(_pbHelpRefln,
        XmNarmCallback,
        MainWindow::vPostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbHelpRefln,
        XmNactivateCallback,
        MainWindow::vPopDialogCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    XtSetArg(args[ac], XmNsubMenuId, _pmHelp); ac++;
    XtSetValues(_cbHelp, args, ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNx, 197); ac++;
    XtSetArg(args[ac], XmNy, 5); ac++;
    XtSetArg(args[ac], XmNwidth, 76); ac++;
    XtSetArg(args[ac], XmNheight, 25); ac++;
    _cbUtils = XmCreateCascadeButton(_menuBar,
        "cbUtils",
        args, 
        ac);
    XtManageChild(_cbUtils);
    
    ac = 0;
    XtSetArg(args[ac], XmNx, 0); ac++;
    XtSetArg(args[ac], XmNy, 0); ac++;
    XtSetArg(args[ac], XmNwidth, 170); ac++;
    XtSetArg(args[ac], XmNheight, 31); ac++;
    _pmUtils = XmCreatePulldownMenu(XtParent(_cbUtils),
        "pmUtils",
        args, 
        ac);
    
    ac = 0;
    _pbUtilsProcess = XmCreatePushButton(_pmUtils,
        "pbUtilsProcess",
        args, 
        ac);
    XtManageChild(_pbUtilsProcess);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbUtilsProcess,
        XmNdisarmCallback,
        MainWindow::vUnpostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)"Launch a separate dtprocess window";
    XtAddCallback(_pbUtilsProcess,
        XmNarmCallback,
        MainWindow::vPostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbUtilsProcess,
        XmNactivateCallback,
        MainWindow::vUtilsCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
//+2010-03-24 JWP
    ac = 0;
    _pbUtilsProcessExtern = XmCreatePushButton(_pmUtils,
        "pbUtilsProcessExtern",
        args, 
        ac);
    XtManageChild(_pbUtilsProcessExtern);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbUtilsProcessExtern,
        XmNdisarmCallback,
        MainWindow::vUnpostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)"Launch an external program to process images";
    XtAddCallback(_pbUtilsProcessExtern,
        XmNarmCallback,
        MainWindow::vPostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbUtilsProcessExtern,
        XmNactivateCallback,
        MainWindow::vUtilsCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;

    ac = 0;
    _pbUtilsProcessExternHKL = XmCreatePushButton(_pmUtils,
        "pbUtilsProcessExternHKL",
        args, 
        ac);
    XtManageChild(_pbUtilsProcessExternHKL);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbUtilsProcessExternHKL,
        XmNdisarmCallback,
        MainWindow::vUnpostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)"Launch the HKL2000 program to process images";
    XtAddCallback(_pbUtilsProcessExternHKL,
        XmNarmCallback,
        MainWindow::vPostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbUtilsProcessExternHKL,
        XmNactivateCallback,
        MainWindow::vUtilsCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;

    ac = 0;
    _pbUtilsProcessExternXDS = XmCreatePushButton(_pmUtils,
        "pbUtilsProcessExternXDS",
        args, 
        ac);
    XtManageChild(_pbUtilsProcessExternXDS);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbUtilsProcessExternXDS,
        XmNdisarmCallback,
        MainWindow::vUnpostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)"Launch the XDS program to process images";
    XtAddCallback(_pbUtilsProcessExternXDS,
        XmNarmCallback,
        MainWindow::vPostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbUtilsProcessExternXDS,
        XmNactivateCallback,
        MainWindow::vUtilsCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;

    ac = 0;
    _pbUtilsProcessExternMOSFLM = XmCreatePushButton(_pmUtils,
        "pbUtilsProcessExternMOSFLM",
        args, 
        ac);
    XtManageChild(_pbUtilsProcessExternMOSFLM);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbUtilsProcessExternMOSFLM,
        XmNdisarmCallback,
        MainWindow::vUnpostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)"Launch the iMosflm program to process images";
    XtAddCallback(_pbUtilsProcessExternMOSFLM,
        XmNarmCallback,
        MainWindow::vPostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbUtilsProcessExternMOSFLM,
        XmNactivateCallback,
        MainWindow::vUtilsCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;

//-2010-03-24 JWP

    ac = 0;
    XtSetArg(args[ac], XmNsubMenuId, _pmUtils); ac++;
    XtSetValues(_cbUtils, args, ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNresizePolicy, XmRESIZE_GROW); ac++;
    XtSetArg(args[ac], XmNwidth, 1021); ac++;
    XtSetArg(args[ac], XmNheight, 716); ac++;
    _form = XmCreateForm(_MainWindow,
        "form",
        args, 
        ac);
    XtManageChild(_form);
    
    ac = 0;
    XtSetArg(args[ac], XmNx, 0); ac++;
    XtSetArg(args[ac], XmNy, 485); ac++;
    XtSetArg(args[ac], XmNwidth, 289); ac++;
    XtSetArg(args[ac], XmNheight, 231); ac++;
    _frImageSmall = XmCreateFrame(_form,
        "frImageSmall",
        args, 
        ac);
    XtManageChild(_frImageSmall);
    
    ac = 0;
    XtSetArg(args[ac], XmNx, 3); ac++;
    XtSetArg(args[ac], XmNy, 3); ac++;
    XtSetArg(args[ac], XmNwidth, 283); ac++;
    XtSetArg(args[ac], XmNheight, 225); ac++;
    _daImageSmall = XmCreateDrawingArea(_frImageSmall,
        "daImageSmall",
        args, 
        ac);
    XtManageChild(_daImageSmall);
    
    ac = 0;
    XtSetArg(args[ac], XmNx, 0); ac++;
    XtSetArg(args[ac], XmNy, 0); ac++;
    XtSetArg(args[ac], XmNwidth, 286); ac++;
    XtSetArg(args[ac], XmNheight, 480); ac++;
    _pwMain = XmCreatePanedWindow(_form,
        "pwMain",
        args, 
        ac);
    XtManageChild(_pwMain);
    
    ac = 0;
    XtSetArg(args[ac], XmNresizePolicy, XmRESIZE_GROW); ac++;
    XtSetArg(args[ac], XmNallowResize, True); ac++;
    XtSetArg(args[ac], XmNwidth, 280); ac++;
    _foMainTop = XmCreateForm(_pwMain,
        "foMainTop",
        args, 
        ac);
    XtManageChild(_foMainTop);
    
    ac = 0;
    XtSetArg(args[ac], XmNalignment, XmALIGNMENT_BEGINNING); ac++;
    XtSetArg(args[ac], XmNsensitive, True); ac++;
    XtSetArg(args[ac], XmNindicatorOn, True); ac++;
    XtSetArg(args[ac], XmNselectColor, 
        BX_CONVERT(_foMainTop, "green", 
        XmRPixel, 0, &argok)); if (argok) ac++;
    XtSetArg(args[ac], XmNindicatorType, XmONE_OF_MANY); ac++;
    XtSetArg(args[ac], XmNvisibleWhenOff, True); ac++;
    XtSetArg(args[ac], XmNrecomputeSize, True); ac++;
    XtSetArg(args[ac], XmNx, 140); ac++;
    XtSetArg(args[ac], XmNy, 0); ac++;
    XtSetArg(args[ac], XmNwidth, 140); ac++;
    XtSetArg(args[ac], XmNheight, 30); ac++;
    _tbCursorBeam = XmCreateToggleButton(_foMainTop,
        "tbCursorBeam",
        args, 
        ac);
    XtManageChild(_tbCursorBeam);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tbCursorBeam,
        XmNvalueChangedCallback,
        MainWindow::vCursorModeCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tbCursorBeam,
        XmNdisarmCallback,
        MainWindow::vUnpostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)"Use circle cursor to edit beam position";
    XtAddCallback(_tbCursorBeam,
        XmNarmCallback,
        MainWindow::vPostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    XtSetArg(args[ac], XmNalignment, XmALIGNMENT_BEGINNING); ac++;
    XtSetArg(args[ac], XmNsensitive, True); ac++;
    XtSetArg(args[ac], XmNindicatorOn, True); ac++;
    XtSetArg(args[ac], XmNselectColor, 
        BX_CONVERT(_foMainTop, "green", 
        XmRPixel, 0, &argok)); if (argok) ac++;
    XtSetArg(args[ac], XmNindicatorType, XmONE_OF_MANY); ac++;
    XtSetArg(args[ac], XmNvisibleWhenOff, True); ac++;
    XtSetArg(args[ac], XmNrecomputeSize, True); ac++;
    XtSetArg(args[ac], XmNx, 140); ac++;
    XtSetArg(args[ac], XmNy, 30); ac++;
    XtSetArg(args[ac], XmNwidth, 140); ac++;
    XtSetArg(args[ac], XmNheight, 30); ac++;
    _tbCursorSpot = XmCreateToggleButton(_foMainTop,
        "tbCursorSpot",
        args, 
        ac);
    XtManageChild(_tbCursorSpot);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tbCursorSpot,
        XmNvalueChangedCallback,
        MainWindow::vCursorModeCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tbCursorSpot,
        XmNdisarmCallback,
        MainWindow::vUnpostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)"Use circle cursor to measure spot radii";
    XtAddCallback(_tbCursorSpot,
        XmNarmCallback,
        MainWindow::vPostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    XtSetArg(args[ac], XmNalignment, XmALIGNMENT_BEGINNING); ac++;
    XtSetArg(args[ac], XmNsensitive, True); ac++;
    XtSetArg(args[ac], XmNindicatorOn, True); ac++;
    XtSetArg(args[ac], XmNselectColor, 
        BX_CONVERT(_foMainTop, "green", 
        XmRPixel, 0, &argok)); if (argok) ac++;
    XtSetArg(args[ac], XmNindicatorType, XmONE_OF_MANY); ac++;
    XtSetArg(args[ac], XmNvisibleWhenOff, True); ac++;
    XtSetArg(args[ac], XmNrecomputeSize, True); ac++;
    XtSetArg(args[ac], XmNx, 0); ac++;
    XtSetArg(args[ac], XmNy, 30); ac++;
    XtSetArg(args[ac], XmNwidth, 140); ac++;
    XtSetArg(args[ac], XmNheight, 30); ac++;
    _tbCursorMeasure = XmCreateToggleButton(_foMainTop,
        "tbCursorMeasure",
        args, 
        ac);
    XtManageChild(_tbCursorMeasure);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tbCursorMeasure,
        XmNvalueChangedCallback,
        MainWindow::vCursorModeCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tbCursorMeasure,
        XmNdisarmCallback,
        MainWindow::vUnpostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)"Use line cursor to measure d-spacing";
    XtAddCallback(_tbCursorMeasure,
        XmNarmCallback,
        MainWindow::vPostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    XtSetArg(args[ac], XmNalignment, XmALIGNMENT_BEGINNING); ac++;
    XtSetArg(args[ac], XmNsensitive, True); ac++;
    XtSetArg(args[ac], XmNindicatorOn, True); ac++;
    XtSetArg(args[ac], XmNselectColor, 
        BX_CONVERT(_foMainTop, "green", 
        XmRPixel, 0, &argok)); if (argok) ac++;
    XtSetArg(args[ac], XmNindicatorType, XmONE_OF_MANY); ac++;
    XtSetArg(args[ac], XmNvisibleWhenOff, True); ac++;
    XtSetArg(args[ac], XmNrecomputeSize, True); ac++;
    XtSetArg(args[ac], XmNx, 0); ac++;
    XtSetArg(args[ac], XmNy, 0); ac++;
    XtSetArg(args[ac], XmNwidth, 140); ac++;
    XtSetArg(args[ac], XmNheight, 30); ac++;
    _tbCursorRect = XmCreateToggleButton(_foMainTop,
        "tbCursorRect",
        args, 
        ac);
    XtManageChild(_tbCursorRect);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tbCursorRect,
        XmNvalueChangedCallback,
        MainWindow::vCursorModeCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tbCursorRect,
        XmNdisarmCallback,
        MainWindow::vUnpostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)"Use rectangle cursor to define zoom region";
    XtAddCallback(_tbCursorRect,
        XmNarmCallback,
        MainWindow::vPostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    XtSetArg(args[ac], XmNsensitive, False); ac++;
    XtSetArg(args[ac], XmNx, 150); ac++;
    XtSetArg(args[ac], XmNy, 226); ac++;
    XtSetArg(args[ac], XmNwidth, 28); ac++;
    XtSetArg(args[ac], XmNheight, 40); ac++;
    _lbImageNum = XmCreateLabel(_foMainTop,
        "lbImageNum",
        args, 
        ac);
    XtManageChild(_lbImageNum);
    
    ac = 0;
    XtSetArg(args[ac], XmNsensitive, False); ac++;
    XtSetArg(args[ac], XmNuserData, 1); ac++;
    XtSetArg(args[ac], XmNx, 80); ac++;
    XtSetArg(args[ac], XmNy, 226); ac++;
    XtSetArg(args[ac], XmNwidth, 65); ac++;
    XtSetArg(args[ac], XmNheight, 40); ac++;
    _pbImageNext = XmCreatePushButton(_foMainTop,
        "pbImageNext",
        args, 
        ac);
    XtManageChild(_pbImageNext);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbImageNext,
        XmNdisarmCallback,
        MainWindow::vUnpostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)"Read and display next image in a scan";
    XtAddCallback(_pbImageNext,
        XmNarmCallback,
        MainWindow::vPostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbImageNext,
        XmNactivateCallback,
        MainWindow::vFileTemplateCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    XtSetArg(args[ac], XmNsensitive, False); ac++;
    XtSetArg(args[ac], XmNuserData, 0); ac++;
    XtSetArg(args[ac], XmNx, 10); ac++;
    XtSetArg(args[ac], XmNy, 226); ac++;
    XtSetArg(args[ac], XmNwidth, 65); ac++;
    XtSetArg(args[ac], XmNheight, 40); ac++;
    _pbImagePrev = XmCreatePushButton(_foMainTop,
        "pbImagePrev",
        args, 
        ac);
    XtManageChild(_pbImagePrev);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbImagePrev,
        XmNdisarmCallback,
        MainWindow::vUnpostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)"Read and display previous image in a scan";
    XtAddCallback(_pbImagePrev,
        XmNarmCallback,
        MainWindow::vPostHelpCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_pbImagePrev,
        XmNactivateCallback,
        MainWindow::vFileTemplateCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    XtSetArg(args[ac], XmNscrollingPolicy, XmAPPLICATION_DEFINED); ac++;
    XtSetArg(args[ac], XmNx, 0); ac++;
    XtSetArg(args[ac], XmNy, 60); ac++;
    XtSetArg(args[ac], XmNwidth, 280); ac++;
    XtSetArg(args[ac], XmNheight, 156); ac++;
    _swOutput = XmCreateScrolledWindow(_foMainTop,
        "swOutput",
        args, 
        ac);
    XtManageChild(_swOutput);
    
    ac = 0;
    XtSetArg(args[ac], XmNeditMode, XmMULTI_LINE_EDIT); ac++;
    XtSetArg(args[ac], XmNcursorPositionVisible, False); ac++;
    XtSetArg(args[ac], XmNscrollLeftSide, True); ac++;
    XtSetArg(args[ac], XmNscrollHorizontal, True); ac++;
    XtSetArg(args[ac], XmNeditable, False); ac++;
    XtSetArg(args[ac], XmNheight, 137); ac++;
    _tfOutput = XmCreateText(_swOutput,
        "tfOutput",
        args, 
        ac);
    XtManageChild(_tfOutput);
    
    ac = 0;
    XtSetArg(args[ac], XmNvalue, "?"); ac++;
    XtSetArg(args[ac], XmNsensitive, False); ac++;
    XtSetArg(args[ac], XmNmaxLength, 20); ac++;
    XtSetArg(args[ac], XmNuserData, 2); ac++;
    XtSetArg(args[ac], XmNx, 180); ac++;
    XtSetArg(args[ac], XmNy, 226); ac++;
    XtSetArg(args[ac], XmNwidth, 100); ac++;
    XtSetArg(args[ac], XmNheight, 40); ac++;
    _tfImageNum = XmCreateTextField(_foMainTop,
        "tfImageNum",
        args, 
        ac);
    XtManageChild(_tfImageNum);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tfImageNum,
        XmNactivateCallback,
        MainWindow::vFileTemplateCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    XtSetArg(args[ac], XmNresizePolicy, XmRESIZE_GROW); ac++;
    XtSetArg(args[ac], XmNallowResize, True); ac++;
    XtSetArg(args[ac], XmNwidth, 280); ac++;
    _foMainMid = XmCreateForm(_pwMain,
        "foMainMid",
        args, 
        ac);
    XtManageChild(_foMainMid);
    
    ac = 0;
    XtSetArg(args[ac], XmNalignment, XmALIGNMENT_END); ac++;
    XtSetArg(args[ac], XmNtraversalOn, False); ac++;
    XtSetArg(args[ac], XmNx, 0); ac++;
    XtSetArg(args[ac], XmNy, 0); ac++;
    XtSetArg(args[ac], XmNwidth, 160); ac++;
    XtSetArg(args[ac], XmNheight, 40); ac++;
    _lbRotStart = XmCreateLabel(_foMainMid,
        "lbRotStart",
        args, 
        ac);
    XtManageChild(_lbRotStart);
    
    ac = 0;
    XtSetArg(args[ac], XmNvalue, "?"); ac++;
    XtSetArg(args[ac], XmNx, 180); ac++;
    XtSetArg(args[ac], XmNy, 0); ac++;
    XtSetArg(args[ac], XmNwidth, 100); ac++;
    XtSetArg(args[ac], XmNheight, 40); ac++;
    _tfRotStart = XmCreateTextField(_foMainMid,
        "tfRotStart",
        args, 
        ac);
    XtManageChild(_tfRotStart);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tfRotStart,
        XmNvalueChangedCallback,
        MainWindow::vTextFieldCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tfRotStart,
        XmNlosingFocusCallback,
        MainWindow::vTextFieldCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tfRotStart,
        XmNactivateCallback,
        MainWindow::vTextFieldCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    XtSetArg(args[ac], XmNalignment, XmALIGNMENT_END); ac++;
    XtSetArg(args[ac], XmNtraversalOn, False); ac++;
    XtSetArg(args[ac], XmNx, 0); ac++;
    XtSetArg(args[ac], XmNy, 40); ac++;
    XtSetArg(args[ac], XmNwidth, 160); ac++;
    XtSetArg(args[ac], XmNheight, 40); ac++;
    _lbRotEnd = XmCreateLabel(_foMainMid,
        "lbRotEnd",
        args, 
        ac);
    XtManageChild(_lbRotEnd);
    
    ac = 0;
    XtSetArg(args[ac], XmNvalue, "?"); ac++;
    XtSetArg(args[ac], XmNx, 180); ac++;
    XtSetArg(args[ac], XmNy, 40); ac++;
    XtSetArg(args[ac], XmNwidth, 100); ac++;
    XtSetArg(args[ac], XmNheight, 40); ac++;
    _tfRotEnd = XmCreateTextField(_foMainMid,
        "tfRotEnd",
        args, 
        ac);
    XtManageChild(_tfRotEnd);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tfRotEnd,
        XmNvalueChangedCallback,
        MainWindow::vTextFieldCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tfRotEnd,
        XmNlosingFocusCallback,
        MainWindow::vTextFieldCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tfRotEnd,
        XmNactivateCallback,
        MainWindow::vTextFieldCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    XtSetArg(args[ac], XmNvalue, "?"); ac++;
    XtSetArg(args[ac], XmNx, 180); ac++;
    XtSetArg(args[ac], XmNy, 80); ac++;
    XtSetArg(args[ac], XmNwidth, 100); ac++;
    XtSetArg(args[ac], XmNheight, 40); ac++;
    _tfDetDist = XmCreateTextField(_foMainMid,
        "tfDetDist",
        args, 
        ac);
    XtManageChild(_tfDetDist);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tfDetDist,
        XmNvalueChangedCallback,
        MainWindow::vTextFieldCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tfDetDist,
        XmNlosingFocusCallback,
        MainWindow::vTextFieldCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tfDetDist,
        XmNactivateCallback,
        MainWindow::vTextFieldCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    XtSetArg(args[ac], XmNalignment, XmALIGNMENT_END); ac++;
    XtSetArg(args[ac], XmNtraversalOn, False); ac++;
    XtSetArg(args[ac], XmNx, 0); ac++;
    XtSetArg(args[ac], XmNy, 80); ac++;
    XtSetArg(args[ac], XmNwidth, 160); ac++;
    XtSetArg(args[ac], XmNheight, 40); ac++;
    _lbDetDist = XmCreateLabel(_foMainMid,
        "lbDetDist",
        args, 
        ac);
    XtManageChild(_lbDetDist);
    
    ac = 0;
    XtSetArg(args[ac], XmNalignment, XmALIGNMENT_END); ac++;
    XtSetArg(args[ac], XmNtraversalOn, False); ac++;
    XtSetArg(args[ac], XmNx, 0); ac++;
    XtSetArg(args[ac], XmNy, 120); ac++;
    XtSetArg(args[ac], XmNwidth, 160); ac++;
    XtSetArg(args[ac], XmNheight, 40); ac++;
    _lbDetSwing = XmCreateLabel(_foMainMid,
        "lbDetSwing",
        args, 
        ac);
    XtManageChild(_lbDetSwing);
    
    ac = 0;
    XtSetArg(args[ac], XmNvalue, "?"); ac++;
    XtSetArg(args[ac], XmNx, 180); ac++;
    XtSetArg(args[ac], XmNy, 120); ac++;
    XtSetArg(args[ac], XmNwidth, 100); ac++;
    XtSetArg(args[ac], XmNheight, 40); ac++;
    _tfDetSwing = XmCreateTextField(_foMainMid,
        "tfDetSwing",
        args, 
        ac);
    XtManageChild(_tfDetSwing);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tfDetSwing,
        XmNvalueChangedCallback,
        MainWindow::vTextFieldCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tfDetSwing,
        XmNlosingFocusCallback,
        MainWindow::vTextFieldCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tfDetSwing,
        XmNactivateCallback,
        MainWindow::vTextFieldCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    XtSetArg(args[ac], XmNvalue, "?"); ac++;
    XtSetArg(args[ac], XmNx, 180); ac++;
    XtSetArg(args[ac], XmNy, 160); ac++;
    XtSetArg(args[ac], XmNwidth, 100); ac++;
    XtSetArg(args[ac], XmNheight, 40); ac++;
    _tfWavelength = XmCreateTextField(_foMainMid,
        "tfWavelength",
        args, 
        ac);
    XtManageChild(_tfWavelength);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tfWavelength,
        XmNvalueChangedCallback,
        MainWindow::vTextFieldCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tfWavelength,
        XmNlosingFocusCallback,
        MainWindow::vTextFieldCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_tfWavelength,
        XmNactivateCallback,
        MainWindow::vTextFieldCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    ac = 0;
    XtSetArg(args[ac], XmNalignment, XmALIGNMENT_END); ac++;
    XtSetArg(args[ac], XmNtraversalOn, False); ac++;
    XtSetArg(args[ac], XmNx, 0); ac++;
    XtSetArg(args[ac], XmNy, 160); ac++;
    XtSetArg(args[ac], XmNwidth, 160); ac++;
    XtSetArg(args[ac], XmNheight, 40); ac++;
    _lbWavelength = XmCreateLabel(_foMainMid,
        "lbWavelength",
        args, 
        ac);
    XtManageChild(_lbWavelength);
    
    ac = 0;
    XtSetArg(args[ac], XmNx, 289); ac++;
    XtSetArg(args[ac], XmNy, 0); ac++;
    XtSetArg(args[ac], XmNwidth, 732); ac++;
    XtSetArg(args[ac], XmNheight, 716); ac++;
    _frImageBig = XmCreateFrame(_form,
        "frImageBig",
        args, 
        ac);
    XtManageChild(_frImageBig);
    
    ac = 0;
    XtSetArg(args[ac], XmNx, 3); ac++;
    XtSetArg(args[ac], XmNy, 3); ac++;
    XtSetArg(args[ac], XmNwidth, 726); ac++;
    XtSetArg(args[ac], XmNheight, 710); ac++;
    _daImageBig = XmCreateDrawingArea(_frImageBig,
        "daImageBig",
        args, 
        ac);
    XtManageChild(_daImageBig);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_daImageBig,
        XmNinputCallback,
        MainWindow::vDAInputCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    ac = 0;
    XtSetArg(args[ac], XmNrightAttachment, XmATTACH_FORM); ac++;
    XtSetArg(args[ac], XmNleftAttachment, XmATTACH_FORM); ac++;
    XtSetArg(args[ac], XmNleftOffset, 0); ac++;
    XtSetArg(args[ac], XmNrightOffset, 0); ac++;
    XtSetArg(args[ac], XmNtopOffset, 0); ac++;
    XtSetValues(_scProgress, args, ac);
    ac = 0;
    XtSetArg(args[ac], XmNtopAttachment, XmATTACH_NONE); ac++;
    XtSetArg(args[ac], XmNrightAttachment, XmATTACH_FORM); ac++;
    XtSetArg(args[ac], XmNleftAttachment, XmATTACH_FORM); ac++;
    XtSetArg(args[ac], XmNbottomAttachment, XmATTACH_FORM); ac++;
    XtSetArg(args[ac], XmNbottomOffset, 10); ac++;
    XtSetArg(args[ac], XmNleftOffset, 260); ac++;
    XtSetArg(args[ac], XmNrightOffset, 276); ac++;
    XtSetValues(_pbViewHeaderDismiss, args, ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNtopAttachment, XmATTACH_NONE); ac++;
    XtSetArg(args[ac], XmNrightAttachment, XmATTACH_FORM); ac++;
    XtSetArg(args[ac], XmNleftAttachment, XmATTACH_FORM); ac++;
    XtSetArg(args[ac], XmNbottomAttachment, XmATTACH_FORM); ac++;
    XtSetArg(args[ac], XmNbottomOffset, 61); ac++;
    XtSetArg(args[ac], XmNleftOffset, 0); ac++;
    XtSetArg(args[ac], XmNrightOffset, 21); ac++;
    XtSetValues(_spViewHeader, args, ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNtopAttachment, XmATTACH_FORM); ac++;
    XtSetArg(args[ac], XmNrightAttachment, XmATTACH_FORM); ac++;
    XtSetArg(args[ac], XmNleftAttachment, XmATTACH_FORM); ac++;
    XtSetArg(args[ac], XmNbottomAttachment, XmATTACH_WIDGET); ac++;
    XtSetArg(args[ac], XmNbottomOffset, 0); ac++;
    XtSetArg(args[ac], XmNbottomWidget, _spViewHeader); ac++;
    XtSetArg(args[ac], XmNleftOffset, 0); ac++;
    XtSetArg(args[ac], XmNrightOffset, 0); ac++;
    XtSetArg(args[ac], XmNtopOffset, 0); ac++;
    XtSetValues(_swViewHeader, args, ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNmenuHelpWidget, _cbHelp); ac++;
    XtSetValues(_menuBar, args, ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNtopAttachment, XmATTACH_WIDGET); ac++;
    XtSetArg(args[ac], XmNrightAttachment, XmATTACH_WIDGET); ac++;
    XtSetArg(args[ac], XmNleftAttachment, XmATTACH_FORM); ac++;
    XtSetArg(args[ac], XmNbottomAttachment, XmATTACH_FORM); ac++;
    XtSetArg(args[ac], XmNbottomOffset, 0); ac++;
    XtSetArg(args[ac], XmNleftOffset, 0); ac++;
    XtSetArg(args[ac], XmNrightOffset, 0); ac++;
    XtSetArg(args[ac], XmNtopOffset, 5); ac++;
    XtSetArg(args[ac], XmNrightWidget, _frImageBig); ac++;
    XtSetArg(args[ac], XmNtopWidget, _pwMain); ac++;
    XtSetValues(_frImageSmall, args, ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNtopAttachment, XmATTACH_FORM); ac++;
    XtSetArg(args[ac], XmNrightAttachment, XmATTACH_POSITION); ac++;
    XtSetArg(args[ac], XmNleftAttachment, XmATTACH_FORM); ac++;
    XtSetArg(args[ac], XmNbottomAttachment, XmATTACH_POSITION); ac++;
    XtSetArg(args[ac], XmNrightPosition, 28); ac++;
    XtSetArg(args[ac], XmNbottomPosition, 67); ac++;
    XtSetArg(args[ac], XmNleftOffset, 0); ac++;
    XtSetArg(args[ac], XmNtopOffset, 0); ac++;
    XtSetValues(_pwMain, args, ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNpositionIndex, 0); ac++;
    XtSetValues(_foMainTop, args, ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNtopAttachment, XmATTACH_FORM); ac++;
    XtSetArg(args[ac], XmNrightAttachment, XmATTACH_NONE); ac++;
    XtSetArg(args[ac], XmNleftAttachment, XmATTACH_POSITION); ac++;
    XtSetArg(args[ac], XmNbottomAttachment, XmATTACH_NONE); ac++;
    XtSetArg(args[ac], XmNbottomOffset, 0); ac++;
    XtSetArg(args[ac], XmNleftPosition, 50); ac++;
    XtSetArg(args[ac], XmNrightOffset, 0); ac++;
    XtSetArg(args[ac], XmNtopOffset, 0); ac++;
    XtSetArg(args[ac], XmNallowResize, False); ac++;
    XtSetValues(_tbCursorBeam, args, ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNtopAttachment, XmATTACH_WIDGET); ac++;
    XtSetArg(args[ac], XmNrightAttachment, XmATTACH_FORM); ac++;
    XtSetArg(args[ac], XmNleftAttachment, XmATTACH_POSITION); ac++;
    XtSetArg(args[ac], XmNbottomAttachment, XmATTACH_NONE); ac++;
    XtSetArg(args[ac], XmNbottomOffset, 0); ac++;
    XtSetArg(args[ac], XmNleftPosition, 50); ac++;
    XtSetArg(args[ac], XmNrightOffset, 0); ac++;
    XtSetArg(args[ac], XmNtopOffset, 0); ac++;
    XtSetArg(args[ac], XmNtopWidget, _tbCursorRect); ac++;
    XtSetArg(args[ac], XmNallowResize, False); ac++;
    XtSetValues(_tbCursorSpot, args, ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNtopAttachment, XmATTACH_FORM); ac++;
    XtSetArg(args[ac], XmNrightAttachment, XmATTACH_POSITION); ac++;
    XtSetArg(args[ac], XmNleftAttachment, XmATTACH_FORM); ac++;
    XtSetArg(args[ac], XmNrightPosition, 50); ac++;
    XtSetArg(args[ac], XmNleftOffset, 0); ac++;
    XtSetArg(args[ac], XmNtopOffset, 30); ac++;
    XtSetArg(args[ac], XmNallowResize, False); ac++;
    XtSetValues(_tbCursorMeasure, args, ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNrightAttachment, XmATTACH_POSITION); ac++;
    XtSetArg(args[ac], XmNleftAttachment, XmATTACH_FORM); ac++;
    XtSetArg(args[ac], XmNrightPosition, 50); ac++;
    XtSetArg(args[ac], XmNleftOffset, 0); ac++;
    XtSetArg(args[ac], XmNtopOffset, 0); ac++;
    XtSetArg(args[ac], XmNallowResize, False); ac++;
    XtSetValues(_tbCursorRect, args, ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNtopAttachment, XmATTACH_OPPOSITE_WIDGET); ac++;
    XtSetArg(args[ac], XmNrightAttachment, XmATTACH_WIDGET); ac++;
    XtSetArg(args[ac], XmNleftAttachment, XmATTACH_NONE); ac++;
    XtSetArg(args[ac], XmNbottomAttachment, XmATTACH_OPPOSITE_WIDGET); ac++;
    XtSetArg(args[ac], XmNbottomOffset, 0); ac++;
    XtSetArg(args[ac], XmNbottomWidget, _tfImageNum); ac++;
    XtSetArg(args[ac], XmNrightOffset, 2); ac++;
    XtSetArg(args[ac], XmNtopOffset, 0); ac++;
    XtSetArg(args[ac], XmNrightWidget, _tfImageNum); ac++;
    XtSetArg(args[ac], XmNtopWidget, _tfImageNum); ac++;
    XtSetValues(_lbImageNum, args, ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNtopAttachment, XmATTACH_NONE); ac++;
    XtSetArg(args[ac], XmNrightAttachment, XmATTACH_WIDGET); ac++;
    XtSetArg(args[ac], XmNleftAttachment, XmATTACH_NONE); ac++;
    XtSetArg(args[ac], XmNbottomAttachment, XmATTACH_OPPOSITE_WIDGET); ac++;
    XtSetArg(args[ac], XmNbottomOffset, 0); ac++;
    XtSetArg(args[ac], XmNbottomWidget, _tfImageNum); ac++;
    XtSetArg(args[ac], XmNrightOffset, 35); ac++;
    XtSetArg(args[ac], XmNtopOffset, 0); ac++;
    XtSetArg(args[ac], XmNrightWidget, _tfImageNum); ac++;
    XtSetValues(_pbImageNext, args, ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNtopAttachment, XmATTACH_NONE); ac++;
    XtSetArg(args[ac], XmNrightAttachment, XmATTACH_WIDGET); ac++;
    XtSetArg(args[ac], XmNleftAttachment, XmATTACH_NONE); ac++;
    XtSetArg(args[ac], XmNbottomAttachment, XmATTACH_OPPOSITE_WIDGET); ac++;
    XtSetArg(args[ac], XmNbottomOffset, 0); ac++;
    XtSetArg(args[ac], XmNbottomWidget, _tfImageNum); ac++;
    XtSetArg(args[ac], XmNrightOffset, 5); ac++;
    XtSetArg(args[ac], XmNtopOffset, 0); ac++;
    XtSetArg(args[ac], XmNrightWidget, _pbImageNext); ac++;
    XtSetValues(_pbImagePrev, args, ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNtopAttachment, XmATTACH_FORM); ac++;
    XtSetArg(args[ac], XmNrightAttachment, XmATTACH_FORM); ac++;
    XtSetArg(args[ac], XmNleftAttachment, XmATTACH_FORM); ac++;
    XtSetArg(args[ac], XmNbottomAttachment, XmATTACH_WIDGET); ac++;
    XtSetArg(args[ac], XmNbottomOffset, 10); ac++;
    XtSetArg(args[ac], XmNbottomWidget, _tfImageNum); ac++;
    XtSetArg(args[ac], XmNleftOffset, 0); ac++;
    XtSetArg(args[ac], XmNrightOffset, 0); ac++;
    XtSetArg(args[ac], XmNtopOffset, 60); ac++;
    XtSetValues(_swOutput, args, ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNtopAttachment, XmATTACH_NONE); ac++;
    XtSetArg(args[ac], XmNrightAttachment, XmATTACH_FORM); ac++;
    XtSetArg(args[ac], XmNleftAttachment, XmATTACH_NONE); ac++;
    XtSetArg(args[ac], XmNbottomAttachment, XmATTACH_FORM); ac++;
    XtSetArg(args[ac], XmNbottomOffset, 0); ac++;
    XtSetArg(args[ac], XmNrightOffset, 0); ac++;
    XtSetValues(_tfImageNum, args, ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNpositionIndex, 1); ac++;
    XtSetValues(_foMainMid, args, ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNtopAttachment, XmATTACH_OPPOSITE_WIDGET); ac++;
    XtSetArg(args[ac], XmNrightAttachment, XmATTACH_WIDGET); ac++;
    XtSetArg(args[ac], XmNleftAttachment, XmATTACH_FORM); ac++;
    XtSetArg(args[ac], XmNbottomAttachment, XmATTACH_NONE); ac++;
    XtSetArg(args[ac], XmNbottomOffset, 0); ac++;
    XtSetArg(args[ac], XmNleftOffset, 0); ac++;
    XtSetArg(args[ac], XmNrightOffset, 20); ac++;
    XtSetArg(args[ac], XmNtopOffset, 0); ac++;
    XtSetArg(args[ac], XmNrightWidget, _tfRotStart); ac++;
    XtSetArg(args[ac], XmNtopWidget, _tfRotStart); ac++;
    XtSetValues(_lbRotStart, args, ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNtopAttachment, XmATTACH_FORM); ac++;
    XtSetArg(args[ac], XmNrightAttachment, XmATTACH_FORM); ac++;
    XtSetArg(args[ac], XmNleftAttachment, XmATTACH_NONE); ac++;
    XtSetArg(args[ac], XmNbottomAttachment, XmATTACH_NONE); ac++;
    XtSetArg(args[ac], XmNbottomOffset, 0); ac++;
    XtSetArg(args[ac], XmNrightOffset, 0); ac++;
    XtSetValues(_tfRotStart, args, ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNtopAttachment, XmATTACH_OPPOSITE_WIDGET); ac++;
    XtSetArg(args[ac], XmNrightAttachment, XmATTACH_WIDGET); ac++;
    XtSetArg(args[ac], XmNleftAttachment, XmATTACH_FORM); ac++;
    XtSetArg(args[ac], XmNbottomAttachment, XmATTACH_NONE); ac++;
    XtSetArg(args[ac], XmNbottomOffset, 0); ac++;
    XtSetArg(args[ac], XmNleftOffset, 0); ac++;
    XtSetArg(args[ac], XmNrightOffset, 20); ac++;
    XtSetArg(args[ac], XmNtopOffset, 0); ac++;
    XtSetArg(args[ac], XmNrightWidget, _tfRotEnd); ac++;
    XtSetArg(args[ac], XmNtopWidget, _tfRotEnd); ac++;
    XtSetValues(_lbRotEnd, args, ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNtopAttachment, XmATTACH_FORM); ac++;
    XtSetArg(args[ac], XmNrightAttachment, XmATTACH_FORM); ac++;
    XtSetArg(args[ac], XmNleftAttachment, XmATTACH_NONE); ac++;
    XtSetArg(args[ac], XmNbottomAttachment, XmATTACH_NONE); ac++;
    XtSetArg(args[ac], XmNbottomOffset, 0); ac++;
    XtSetArg(args[ac], XmNrightOffset, 0); ac++;
    XtSetValues(_tfRotEnd, args, ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNtopAttachment, XmATTACH_FORM); ac++;
    XtSetArg(args[ac], XmNrightAttachment, XmATTACH_FORM); ac++;
    XtSetArg(args[ac], XmNleftAttachment, XmATTACH_NONE); ac++;
    XtSetArg(args[ac], XmNbottomAttachment, XmATTACH_NONE); ac++;
    XtSetArg(args[ac], XmNbottomOffset, 0); ac++;
    XtSetArg(args[ac], XmNrightOffset, 0); ac++;
    XtSetValues(_tfDetDist, args, ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNtopAttachment, XmATTACH_OPPOSITE_WIDGET); ac++;
    XtSetArg(args[ac], XmNrightAttachment, XmATTACH_WIDGET); ac++;
    XtSetArg(args[ac], XmNleftAttachment, XmATTACH_FORM); ac++;
    XtSetArg(args[ac], XmNbottomAttachment, XmATTACH_NONE); ac++;
    XtSetArg(args[ac], XmNbottomOffset, 0); ac++;
    XtSetArg(args[ac], XmNleftOffset, 0); ac++;
    XtSetArg(args[ac], XmNrightOffset, 20); ac++;
    XtSetArg(args[ac], XmNtopOffset, 0); ac++;
    XtSetArg(args[ac], XmNrightWidget, _tfDetDist); ac++;
    XtSetArg(args[ac], XmNtopWidget, _tfDetDist); ac++;
    XtSetValues(_lbDetDist, args, ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNtopAttachment, XmATTACH_OPPOSITE_WIDGET); ac++;
    XtSetArg(args[ac], XmNrightAttachment, XmATTACH_WIDGET); ac++;
    XtSetArg(args[ac], XmNleftAttachment, XmATTACH_FORM); ac++;
    XtSetArg(args[ac], XmNbottomAttachment, XmATTACH_NONE); ac++;
    XtSetArg(args[ac], XmNbottomOffset, 0); ac++;
    XtSetArg(args[ac], XmNleftOffset, 0); ac++;
    XtSetArg(args[ac], XmNrightOffset, 20); ac++;
    XtSetArg(args[ac], XmNtopOffset, 0); ac++;
    XtSetArg(args[ac], XmNrightWidget, _tfDetSwing); ac++;
    XtSetArg(args[ac], XmNtopWidget, _tfDetSwing); ac++;
    XtSetValues(_lbDetSwing, args, ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNtopAttachment, XmATTACH_FORM); ac++;
    XtSetArg(args[ac], XmNrightAttachment, XmATTACH_FORM); ac++;
    XtSetArg(args[ac], XmNleftAttachment, XmATTACH_NONE); ac++;
    XtSetArg(args[ac], XmNbottomAttachment, XmATTACH_NONE); ac++;
    XtSetArg(args[ac], XmNbottomOffset, 0); ac++;
    XtSetArg(args[ac], XmNrightOffset, 0); ac++;
    XtSetValues(_tfDetSwing, args, ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNtopAttachment, XmATTACH_FORM); ac++;
    XtSetArg(args[ac], XmNrightAttachment, XmATTACH_FORM); ac++;
    XtSetArg(args[ac], XmNleftAttachment, XmATTACH_NONE); ac++;
    XtSetArg(args[ac], XmNbottomAttachment, XmATTACH_NONE); ac++;
    XtSetArg(args[ac], XmNbottomOffset, 0); ac++;
    XtSetArg(args[ac], XmNrightOffset, 0); ac++;
    XtSetValues(_tfWavelength, args, ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNtopAttachment, XmATTACH_OPPOSITE_WIDGET); ac++;
    XtSetArg(args[ac], XmNrightAttachment, XmATTACH_WIDGET); ac++;
    XtSetArg(args[ac], XmNleftAttachment, XmATTACH_FORM); ac++;
    XtSetArg(args[ac], XmNbottomAttachment, XmATTACH_NONE); ac++;
    XtSetArg(args[ac], XmNbottomOffset, 0); ac++;
    XtSetArg(args[ac], XmNleftOffset, 0); ac++;
    XtSetArg(args[ac], XmNrightOffset, 20); ac++;
    XtSetArg(args[ac], XmNtopOffset, 0); ac++;
    XtSetArg(args[ac], XmNrightWidget, _tfWavelength); ac++;
    XtSetArg(args[ac], XmNtopWidget, _tfWavelength); ac++;
    XtSetValues(_lbWavelength, args, ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNtopAttachment, XmATTACH_FORM); ac++;
    XtSetArg(args[ac], XmNrightAttachment, XmATTACH_FORM); ac++;
    XtSetArg(args[ac], XmNleftAttachment, XmATTACH_WIDGET); ac++;
    XtSetArg(args[ac], XmNbottomAttachment, XmATTACH_FORM); ac++;
    XtSetArg(args[ac], XmNbottomOffset, 0); ac++;
    XtSetArg(args[ac], XmNleftOffset, 3); ac++;
    XtSetArg(args[ac], XmNrightOffset, 0); ac++;
    XtSetArg(args[ac], XmNtopOffset, 0); ac++;
    XtSetArg(args[ac], XmNleftWidget, _pwMain); ac++;
    XtSetValues(_frImageBig, args, ac);
    
    
    // Begin user code block <endcreate>

    // Some stuff to look things up in the resource database

    String pcText;
    String pcProgname;
    XtGetApplicationNameAndClass(XtDisplay(_w), &pcProgname, &pcText);

    m_fCircleRadius = 1.0;

    // Create the help object

    m_poXhelp     = new CXhelp (_w);     // Methods for on-line help
    m_poXcursor   = new CXcursor (_w);   // Methods for cursor manipulation

    // Unmanage some extraneous buttons

    XtUnmanageChild(XmMessageBoxGetChild(_mbViewZoomPan,
					 XmDIALOG_OK_BUTTON));
    
    XtUnmanageChild(XmMessageBoxGetChild(_mbViewZoomPan,
					 XmDIALOG_HELP_BUTTON));
    
    XtUnmanageChild(XmMessageBoxGetChild(_mbError,
					 XmDIALOG_OK_BUTTON));
    
    XtUnmanageChild(XmMessageBoxGetChild(_mbError,
					 XmDIALOG_HELP_BUTTON));
    
    XtUnmanageChild(XmMessageBoxGetChild(_mbProgress,
					 XmDIALOG_OK_BUTTON));
    
    XtUnmanageChild(XmMessageBoxGetChild(_mbProgress,
					 XmDIALOG_HELP_BUTTON));

    // Set properties for interclient communication

    m_poXprop = new CXprop(ms_sAtomNameWindowID);

    // Set callback stuff for the _cUIprintSelect object

    _cUIprintSelect->m_pObj = (XtPointer)this;
    _cUIprintSelect->m_prvFileCallback = MainWindow::vPrintCBCallback;

    // Set callback stuff for the _cUIimageviewprops object

    _cUIimageviewprops->m_pObj = (XtPointer)this;
    _cUIimageviewprops->m_prvOKCallback = MainWindow::vImageViewPropsCBCallback;

    m_tImageProps.fZoom             = 0.9;    // Allow room for profiles
    m_tImageProps.nOrient           = -1;      // -1 means not set
    m_tImageProps.fSatPixValue      = 65535.0;
    m_tImageProps.sSatPixColor      = "RED";  // UPPERCASE is important here

    m_tImageProps.fTooLowPixValue   = 0.0;
    m_tImageProps.sTooLowPixColor   = "YELLOW";  // UPPERCASE is important here

    m_tImageProps.nResoCircles      = -1;
    m_tImageProps.nPlotRockingCurve = 0;
    m_tImageProps.fScaleMinSD       = 1.5;
    m_tImageProps.fScaleMaxSD       = 5.0;
    m_tImageProps.fSD               = -1.0;
    m_tImageProps.fImageMin         = 0.0;
    m_tImageProps.fImageMax         = 65535.0;
    m_tImageProps.fAvg              = 100.0;
    m_tImageProps.fScaleMin         = 0.0;
    m_tImageProps.fScaleMax         = 65535.0;

    _cUIimageviewprops->vGetValues(&m_tImagePropsInit);   // Get default values

    m_tImageProps.nOrient      = m_tImagePropsInit.nOrient; // for orientation,
    m_tImageProps.sSatPixColor = m_tImagePropsInit.sSatPixColor; // sat color,
    m_tImageProps.fSatPixValue = m_tImagePropsInit.fSatPixValue; // sat value,
    m_tImageProps.sTooLowPixColor = m_tImagePropsInit.sTooLowPixColor; // sat color,
    m_tImageProps.fTooLowPixValue = m_tImagePropsInit.fTooLowPixValue; // sat value,
    m_tImageProps.fZoom        = m_tImagePropsInit.fBorder;      // border,
    m_tImageProps.nIntegrateBox[0] = m_tImagePropsInit.nIntegrateBox[0];// box 
    m_tImageProps.nIntegrateBox[1] = m_tImagePropsInit.nIntegrateBox[1];// size
    m_tImageProps.nPlotRockingCurve = 0;
    m_tImageProps.nResoCircles      = -1;


	// Set callback stuff for the _cUIreflnviewprops object

    _cUIreflnviewprops->m_pObj = (XtPointer)this;
    _cUIreflnviewprops->m_prvOKCallback = MainWindow::vReflnViewPropsCBCallback;

    _cUIreflnviewprops->vGetValues(&m_tReflnPropsInit);   // Get default values

    m_tReflnProps.a6fReflnSize[0] = m_tReflnPropsInit.a6fReflnSize[0];
    m_tReflnProps.a6fReflnSize[1] = m_tReflnPropsInit.a6fReflnSize[1];
    m_tReflnProps.a6fReflnSize[2] = m_tReflnPropsInit.a6fReflnSize[2];
    m_tReflnProps.a6fReflnSize[3] = m_tReflnPropsInit.a6fReflnSize[3];
    m_tReflnProps.a6fReflnSize[4] = m_tReflnPropsInit.a6fReflnSize[4];
    m_tReflnProps.a6fReflnSize[5] = m_tReflnPropsInit.a6fReflnSize[5];
    m_tReflnProps.sReflnColor     = m_tReflnPropsInit.sReflnColor;
    m_tReflnProps.nReflnPredObs   = m_tReflnPropsInit.nReflnPredObs;
    m_tReflnProps.nReflnSymbol    = m_tReflnPropsInit.nReflnSymbol;
    m_tReflnProps.fImageRotStart  = 0.0;
    m_tReflnProps.fImageRotEnd    = 0.0;

    // Set callback stuff for the _cUIimagefileSelect object

    _cUIimagefileSelect->m_pObj = (XtPointer)this;
    _cUIimagefileSelect->m_prvFileCallback = MainWindow::vImageFileCBCallback;
    m_hFilePB = _pbFileOpen;
    pcText = XGetDefault(XtDisplay(_w), pcProgname, "imageSize");
    if (NULL != pcText)
      {
	int nStat, nTemp;
	nStat = sscanf(pcText, "%d", &nTemp);
	if (1 == nStat) m_nDefaultImageSize = nTemp;
      }
    _cUIimagefileSelect->vSetImageSize(m_nDefaultImageSize);

	// Set callback stuff for the _cUIreflnfileSelect object

    _cUIreflnfileSelect->m_pObj = (XtPointer)this;
    _cUIreflnfileSelect->m_prvFileCallback = MainWindow::vReflnFileCBCallback;

    // Motif 1.1 does not have the focusCallbacks
    // so add them only if Motif 1.2 or higher
#if (XmVersion >= 1002)

    m_nCDC = 0;
    m_ptClientDataStructs[m_nCDC].object = this;
    m_ptClientDataStructs[m_nCDC].client_data = (XtPointer)"Image start rotation angle in degrees";
    XtAddCallback(_tfRotStart,
        XmNfocusCallback,
        MainWindow::vPostHelpCallback,
        (XtPointer)&m_ptClientDataStructs[m_nCDC]);
    m_nCDC++;

    m_ptClientDataStructs[m_nCDC].object = this;
    m_ptClientDataStructs[m_nCDC].client_data = (XtPointer)0;
    XtAddCallback(_tfRotStart,
        XmNlosingFocusCallback,
        MainWindow::vUnpostHelpCallback,
        (XtPointer)&m_ptClientDataStructs[m_nCDC]);
    m_nCDC++;

    m_ptClientDataStructs[m_nCDC].object = this;
    m_ptClientDataStructs[m_nCDC].client_data = (XtPointer)"Image end rotation angle in degrees";
    XtAddCallback(_tfRotEnd,
        XmNfocusCallback,
        MainWindow::vPostHelpCallback,
        (XtPointer)&m_ptClientDataStructs[m_nCDC]);
    m_nCDC++;

    m_ptClientDataStructs[m_nCDC].object = this;
    m_ptClientDataStructs[m_nCDC].client_data = (XtPointer)0;
    XtAddCallback(_tfRotEnd,
        XmNlosingFocusCallback,
        MainWindow::vUnpostHelpCallback,
        (XtPointer)&m_ptClientDataStructs[m_nCDC]);
    m_nCDC++;

    m_ptClientDataStructs[m_nCDC].object = this;
    m_ptClientDataStructs[m_nCDC].client_data = (XtPointer)"Detector swing or two-theta angle in degrees";
    XtAddCallback(_tfDetSwing,
        XmNfocusCallback,
        MainWindow::vPostHelpCallback,
        (XtPointer)&m_ptClientDataStructs[m_nCDC]);
    m_nCDC++;

    m_ptClientDataStructs[m_nCDC].object = this;
    m_ptClientDataStructs[m_nCDC].client_data = (XtPointer)0;
    XtAddCallback(_tfDetSwing,
        XmNlosingFocusCallback,
        MainWindow::vUnpostHelpCallback,
        (XtPointer)&m_ptClientDataStructs[m_nCDC]);
    m_nCDC++;

    m_ptClientDataStructs[m_nCDC].object = this;
    m_ptClientDataStructs[m_nCDC].client_data = (XtPointer)"Detector to crystal distance in millimeters";
    XtAddCallback(_tfDetDist,
        XmNfocusCallback,
        MainWindow::vPostHelpCallback,
        (XtPointer)&m_ptClientDataStructs[m_nCDC]);
    m_nCDC++;

    m_ptClientDataStructs[m_nCDC].object = this;
    m_ptClientDataStructs[m_nCDC].client_data = (XtPointer)0;
    XtAddCallback(_tfDetDist,
        XmNlosingFocusCallback,
        MainWindow::vUnpostHelpCallback,
        (XtPointer)&m_ptClientDataStructs[m_nCDC]);
    m_nCDC++;

    m_ptClientDataStructs[m_nCDC].object = this;
    m_ptClientDataStructs[m_nCDC].client_data = (XtPointer)"Source wavelength in Angstroms";
    XtAddCallback(_tfWavelength,
        XmNfocusCallback,
        MainWindow::vPostHelpCallback,
        (XtPointer)&m_ptClientDataStructs[m_nCDC]);
    m_nCDC++;
    m_ptClientDataStructs[m_nCDC].object = this;
    m_ptClientDataStructs[m_nCDC].client_data = (XtPointer)0;
    XtAddCallback(_tfWavelength,
        XmNlosingFocusCallback,
        MainWindow::vUnpostHelpCallback,
        (XtPointer)&m_ptClientDataStructs[m_nCDC]);
    m_nCDC++;

    m_ptClientDataStructs[m_nCDC].object = this;
    m_ptClientDataStructs[m_nCDC].client_data = (XtPointer)"Sequence number of image to read and display";
    XtAddCallback(_tfImageNum,
        XmNfocusCallback,
        MainWindow::vPostHelpCallback,
        (XtPointer)&m_ptClientDataStructs[m_nCDC]);
    m_nCDC++;
    m_ptClientDataStructs[m_nCDC].object = this;

    m_ptClientDataStructs[m_nCDC].client_data = (XtPointer)0;
    XtAddCallback(_tfImageNum,
        XmNlosingFocusCallback,
        MainWindow::vUnpostHelpCallback,
        (XtPointer)&m_ptClientDataStructs[m_nCDC]);
    m_nCDC++;

#endif

    // Make sure "close" (delete window) from window manager calls our vExitCB

    Atom hWM_DELETE_WINDOW;
    hWM_DELETE_WINDOW = XmInternAtom(XtDisplay(parent),
				     "WM_DELETE_WINDOW", False);

    m_ptClientDataStructs[m_nCDC].object = this;

    m_ptClientDataStructs[m_nCDC].client_data = (XtPointer)0;
    XmAddWMProtocolCallback(parent, hWM_DELETE_WINDOW, 
			    MainWindow::vExitCBCallback, 
			    (XtPointer)&m_ptClientDataStructs[m_nCDC]);
    m_nCDC++;    

    // Unmanage some widgets that do not do anything yet

    XtUnmanageChild(_pbFilePrefer);
    XtUnmanageChild(_tbViewCalc);
    XtUnmanageChild(_tbViewPlot);
    XtUnmanageChild(_tbViewPixel);
    XtSetSensitive(_pbFileWrite, False);
    XtSetSensitive(_pbEditDelRef, False);

    XtUnmanageChild(_pbEditHeader);

    // Default is to show reso arcs

    XmToggleButtonSetState(_tbViewReso, True, False);

    // Kludge

      vSetLabel(_tbCursorMeasure, "Erase line", NULL);
      vSetLabel(_tbCursorSpot, "Erase circle", NULL);
      // vSetLabel(_tbCursorBeam, "Erase quad", NULL);
      vSetLabel(_tbCursorMeasure, "Measure", NULL);
      vSetLabel(_tbCursorSpot, "Spot circle", NULL);
      // vSetLabel(_tbCursorBeam, "Beam circle", NULL);

      // If DTREK_PROCESS_EXTERN is undefined, 
      //   then unmanage the pbUtilsProcessExtern 
      //
      Cstring sTemp;
      if ("" == sGetEnv("DTREK_PROCESS_EXTERN"))
	{
	  // Unmanage the button
	  XtUnmanageChild(_pbUtilsProcessExtern);
	}
      else
	{
	  sTemp = sTransSymbol("$(DTREK_PROCESS_EXTERN)");
	  // Set the label
	  sTemp = sTemp + " ...";
	  vSetLabel(_pbUtilsProcessExtern, sTemp.string(), NULL);
	}

      if ("" != sGetEnv("DTREK_PROCESS_HKL"))
	{
      	  sTemp = sTransSymbol("$(DTREK_PROCESS_HKL)");
	  // Set the label
	  sTemp = sTemp + " ...";
	  vSetLabel(_pbUtilsProcessExternHKL, sTemp.string(), NULL);
	}

      if ("" != sGetEnv("DTREK_PROCESS_XDS"))
	{
      	  sTemp = sTransSymbol("$(DTREK_PROCESS_XDS)");
	  // Set the label
	  sTemp = sTemp + " ...";
	  vSetLabel(_pbUtilsProcessExternXDS, sTemp.string(), NULL);
	}
      if ("" != sGetEnv("DTREK_PROCESS_MOSFLM"))
	{
      	  sTemp = sTransSymbol("$(DTREK_PROCESS_MOSFLM)");
	  // Set the label
	  sTemp = sTemp + " ...";
	  vSetLabel(_pbUtilsProcessExternMOSFLM, sTemp.string(), NULL);
	}

    // End user code block <endcreate>
}

//
// Classname access.
//
const char *const MainWindow::className()
{
    return ("MainWindow");
}

void MainWindow::vProgressCancelCBCallback(Widget w, 
    XtPointer clientData, XtPointer callData)
{
    UICallbackStruct *data = (UICallbackStruct *) clientData;
    MainWindow *obj = (MainWindow *)data->object;
    obj->vProgressCancelCB(w, (XtPointer) data->client_data, callData);
}

void MainWindow::vProgressCancelCB(Widget w, XtPointer clientData, XtPointer callData)
{
    
    // Begin user code block <vProgressCancelCB>
  m_nProgressCancel = 1;
  if (NULL != m_poXdisplay)
    {
      // The message box has several functions.  One is to display the
      // instructions on how to auto mask the beamstop shadow.  If the user
      // presses the Cancel button, while in auto-mask mode, we need to go
      // to manual erase/edit mask mode.  If not in auto-mask mode, then we
      // need to do something else.
      if (0 != m_poXdisplay->nGetBeamstopShadowMode())
	{
	  m_poXdisplay->vSetBeamstopShadowMode(0);
	  // Set the manual mode toggle button ON and call its callback:
	  XmToggleButtonSetState(_tbEditErase, True, True);	  
	}
    }
    // End user code block <vProgressCancelCB>
}

void MainWindow::vHTMLHelpCallback(Widget w, 
    XtPointer clientData, XtPointer callData)
{
    UICallbackStruct *data = (UICallbackStruct *) clientData;
    MainWindow *obj = (MainWindow *)data->object;
    obj->vHTMLHelp(w, (XtPointer) data->client_data, callData);
}

void MainWindow::vHTMLHelp(Widget w, XtPointer clientData, XtPointer callData)
{
    
    // Begin user code block <vHTMLHelp>
  if (NULL != m_poXhelp)
    {
      vPutMessage("Please check your web browser window for help text.", 1);
      XmUpdateDisplay(w);
      m_poXhelp->vHTMLHelp(w, clientData, callData);
    }
  else
    {
      vPutMessage("No HTML help available.", 1);
    }
    // End user code block <vHTMLHelp>
}

void MainWindow::vUnpostHelpCallback(Widget w, 
    XtPointer clientData, XtPointer callData)
{
    UICallbackStruct *data = (UICallbackStruct *) clientData;
    MainWindow *obj = (MainWindow *)data->object;
    obj->vUnpostHelp(w, (XtPointer) data->client_data, callData);
}

void MainWindow::vUnpostHelp(Widget w, XtPointer clientData, XtPointer callData)
{
    
    // Begin user code block <vUnpostHelp>
  if (NULL != m_poXhelp)
    {
      m_poXhelp->vUnpostOneLineCB(w, clientData, callData);
    }
    // End user code block <vUnpostHelp>
}

void MainWindow::vPostHelpCallback(Widget w, 
    XtPointer clientData, XtPointer callData)
{
    UICallbackStruct *data = (UICallbackStruct *) clientData;
    MainWindow *obj = (MainWindow *)data->object;
    obj->vPostHelp(w, (XtPointer) data->client_data, callData);
}

void MainWindow::vPostHelp(Widget w, XtPointer clientData, XtPointer callData)
{
    
    // Begin user code block <vPostHelp>
  if (NULL != m_poXhelp)
    {
      m_poXhelp->vPostOneLineCB(w, clientData, callData);
    }
    // End user code block <vPostHelp>
}

void MainWindow::vFileSelectionPostCBCallback(Widget w, 
    XtPointer clientData, XtPointer callData)
{
    UICallbackStruct *data = (UICallbackStruct *) clientData;
    MainWindow *obj = (MainWindow *)data->object;
    obj->vFileSelectionPostCB(w, (XtPointer) data->client_data, callData);
}

void MainWindow::vFileSelectionPostCB(Widget w, XtPointer clientData, XtPointer callData)
{
    
    // Begin user code block <vFileSelectionPostCB>

  // This routine is called by numerous pushbutton widgets.
  // It sets up the single _cUIimagefileSelect object and manages it.

  Boolean  argok=False;  
  m_hFilePB = w;          // Save the pushbutton that got us here
  XmString  xsOKLabel;
  XmString  xsTitle;

  if (NULL != m_poScan)
    {
      // Load _cUIimagefileSelect with current scan values

      _cUIimagefileSelect->vSetTemplate(m_poScan->sGetTemplate());
      _cUIimagefileSelect->vSetSeqIncr(m_poScan->nGetSeqInc());
      _cUIimagefileSelect->vSetSeqStart(m_poScan->nGetSeqNum(0));
    }

  if ( (w == _pbFileOpen) || (w == _pbFileNewImage) )
    {

      // File/Open... button

      // Make sure file selection is managed
     
      _cUIimagefileSelect->vSelectFilter(1);

      // Set OK button label

      xsOKLabel = (XmString)BX_CONVERT(_cUIimagefileSelect->baseWidget(),
			  "OK, Open", XmRXmString, 0, &argok);

      // Dialog box title
      
      xsTitle = (XmString)BX_CONVERT(_cUIimagefileSelect->baseWidget(),
			"Open an image file", XmRXmString, 0, &argok);

    }
  else if (w == _pbFileSaveAs)
    {
      // File/Save Image As... button


      // Make sure file selection is managed
     
      _cUIimagefileSelect->vSelectFilter(1);

      // Set OK button label

      xsOKLabel = (XmString)BX_CONVERT(_cUIimagefileSelect->baseWidget(),
			  "OK, Save As", XmRXmString, 0, &argok);

      // Dialog box title

      xsTitle = (XmString)BX_CONVERT(_cUIimagefileSelect->baseWidget(),
			"Save displayed image to a file", 
			XmRXmString, 0, &argok); 
    }
  else if (w == _pbFileSaveHeader)
    {
      // File/SaveHeader... button

      // Make sure file selection is managed
     
      _cUIimagefileSelect->vSelectFilter(1);

      // Set OK button label

      xsOKLabel = (XmString)BX_CONVERT(_cUIimagefileSelect->baseWidget(),
			  "OK, Save Header As", XmRXmString, 0, &argok);

      // Dialog box title

      xsTitle = (XmString)BX_CONVERT(_cUIimagefileSelect->baseWidget(),
			"Save ONLY header to a file", 
			XmRXmString, 0, &argok); 
    }
  else if (w == _pbFileTemplate)
    {
      // Only the Filter is pertinent, so unmanage file selection
      // and make sure Filter is managed.
      
      _cUIimagefileSelect->vSelectFilter(2);

      // Set OK button label

      xsOKLabel = (XmString)BX_CONVERT(_cUIimagefileSelect->baseWidget(),
			  "Set Template", XmRXmString, 0, &argok);

      // Dialog box title

      xsTitle = (XmString)BX_CONVERT(_cUIimagefileSelect->baseWidget(),
			"Set scan image template and sequence info", 
			XmRXmString, 0, &argok);
    }
  else if (w == _pbFileNewTile)
    {
      _cUIimagefileSelect->vSelectFilter(2);

      // Set OK button label

      xsOKLabel = (XmString)BX_CONVERT(_cUIimagefileSelect->baseWidget(),
			  "OK, Tile", XmRXmString, 0, &argok);

      // Dialog box title

      xsTitle = (XmString)BX_CONVERT(_cUIimagefileSelect->baseWidget(),
			"Tile a series of images", 
			XmRXmString, 0, &argok);
    }
  else if (w == _pbFileNewOverlay)
    {
      _cUIimagefileSelect->vSelectFilter(2);

      // Set OK button label

      xsOKLabel = (XmString)BX_CONVERT(_cUIimagefileSelect->baseWidget(),
			  "OK, Overlay", XmRXmString, 0, &argok);

      // Dialog box title

      xsTitle = (XmString)BX_CONVERT(_cUIimagefileSelect->baseWidget(),
			"Overlay a series of images", 
			XmRXmString, 0, &argok);
    }
  else if (w == _pbFileNewUnderlay)
    {
      _cUIimagefileSelect->vSelectFilter(2);

      // Set OK button label

      xsOKLabel = (XmString)BX_CONVERT(_cUIimagefileSelect->baseWidget(),
			  "OK, Underlay", XmRXmString, 0, &argok);

      // Dialog box title

      xsTitle = (XmString)BX_CONVERT(_cUIimagefileSelect->baseWidget(),
			"Underlay a series of images", 
			XmRXmString, 0, &argok);
    }
  else if (w == _pbFileNewMovie)
    {
      _cUIimagefileSelect->vSelectFilter(2);

      // Set OK button label

      xsOKLabel = (XmString)BX_CONVERT(_cUIimagefileSelect->baseWidget(),
			  "OK, Run movie", XmRXmString, 0, &argok);

      // Dialog box title

      xsTitle = (XmString)BX_CONVERT(_cUIimagefileSelect->baseWidget(),
			"Repeated show a series of images like movie frames", 
			XmRXmString, 0, &argok);
    }
  else if (w == _pbFileNewAverage)
    {
      _cUIimagefileSelect->vSelectFilter(2);

      // Set OK button label

      xsOKLabel = (XmString)BX_CONVERT(_cUIimagefileSelect->baseWidget(),
			  "OK, Average", XmRXmString, 0, &argok);

      // Dialog box title

      xsTitle = (XmString)BX_CONVERT(_cUIimagefileSelect->baseWidget(),
			"Average a series of images", 
			XmRXmString, 0, &argok);
    }
  else if (w == _pbFileNewStats)
    {
      _cUIimagefileSelect->vSelectFilter(2);

      // Set OK button label

      xsOKLabel = (XmString)BX_CONVERT(_cUIimagefileSelect->baseWidget(),
			  "OK, Statistics", XmRXmString, 0, &argok);

      // Dialog box title

      xsTitle = (XmString)BX_CONVERT(_cUIimagefileSelect->baseWidget(),
			"Do some statistics on a series of images", 
			XmRXmString, 0, &argok);
    }

  XtVaSetValues(_cUIimagefileSelect->baseWidget(),
		XmNokLabelString, xsOKLabel, NULL);
  XmStringFree(xsOKLabel);

  XtVaSetValues(_cUIimagefileSelect->baseWidget(),
		XmNdialogTitle, xsTitle, NULL);
  XmStringFree(xsTitle);

  if (NULL != m_poImage)
    {
      // Get size in bytes of the current image

      m_nDefaultImageSize = m_poImage->nGetSize();
    }
  _cUIimagefileSelect->vSetImageSize(m_nDefaultImageSize);
  _cUIimagefileSelect->manage();

  if (   ( (Widget)callData == _tbEditErase) 
      || (XmToggleButtonGetState(_tbEditErase)) )
    {
      // Shortcut to put standard mask filename in file selection dialog.
      // This has to go here or the filename is reset to the filter
      // in the previous manage()
      // If in Edit nonunf/mask erase mode ...
      
      // Make the file name beam.mask in the current working directory
      _cUIimagefileSelect->vSetFilename(sGetCWD()+"beam.mask");
    }

  // End user code block <vFileSelectionPostCB>
}

void MainWindow::vLoadReflnCBCallback(Widget w, 
    XtPointer clientData, XtPointer callData)
{
    UICallbackStruct *data = (UICallbackStruct *) clientData;
    MainWindow *obj = (MainWindow *)data->object;
    obj->vLoadReflnCB(w, (XtPointer) data->client_data, callData);
}

void MainWindow::vLoadReflnCB(Widget w, XtPointer clientData, XtPointer callData)
{
    
    // Begin user code block <vLoadReflnCB>
  if (w == _pbFileLoad)
    {
      m_nReflnFileMode = 0;
    }
  else if (w == _pbFileWrite)
    {
      m_nReflnFileMode = 1;
      if (NULL == m_poReflnlist)
	{
	  XtSetSensitive(_pbFileWrite, False);
	  XtSetSensitive(_pbEditDelRef, False);
	  vPutMessage("No reflnlist available.  Use Read refln list... first.\n", 1);
	}
    }
  _cUIreflnfileSelect->vSetReadWrite(m_nReflnFileMode);
  _cUIreflnfileSelect->manage();
    // End user code block <vLoadReflnCB>
}

void MainWindow::vPostPrintCBCallback(Widget w, 
    XtPointer clientData, XtPointer callData)
{
    UICallbackStruct *data = (UICallbackStruct *) clientData;
    MainWindow *obj = (MainWindow *)data->object;
    obj->vPostPrintCB(w, (XtPointer) data->client_data, callData);
}

void MainWindow::vPostPrintCB(Widget w, XtPointer clientData, XtPointer callData)
{
    
    // Begin user code block <vPostPrintCB>
  if (NULL != m_poImage)
    {
      Cstring sTemp;
      if (0 == m_poImage->m_oHeader.nGetValue(Cimage_header::ms_sComment,
					      &sTemp))
	{
	  _cUIprintSelect->vSetComment(sTemp);
	}
    }
  _cUIprintSelect->manage();
    // End user code block <vPostPrintCB>
}

void MainWindow::vFileListenCBCallback(Widget w, 
    XtPointer clientData, XtPointer callData)
{
    UICallbackStruct *data = (UICallbackStruct *) clientData;
    MainWindow *obj = (MainWindow *)data->object;
    obj->vFileListenCB(w, (XtPointer) data->client_data, callData);
}

void MainWindow::vFileListenCB(Widget w, XtPointer clientData, XtPointer callData)
{
    
    // Begin user code block <vFileListenCB>
  
  Boolean       bSet;
  Cstring       sAtomName;
  Display      *dpy;
  Window        window;
  int           nStat;

  dpy    = XtDisplay(w);
  window = XtWindow(_MainWindow);

  // Update events first, so we don't lose an unupdated togglebutton

  XSync(XtDisplay(_MainWindow), False);
  XmUpdateDisplay(_MainWindow);

  // Get state of togglebutton widget

  bSet = XmToggleButtonGetState(w);
  if ( (bSet) && (!m_bEventHandlerInstalled) )
    {
      // Install eventhandler that looks for image and reflnlist updates.

      nStat = m_poXprop->nSetWindowID(XtWindow(_MainWindow));
      m_hAtomReflnUpdate = m_poXprop->hSetProperty(ms_sAtomNameReflnUpdate,
						   "No refln property.",
						   False);
      m_hAtomImageUpdate = m_poXprop->hSetProperty(ms_sAtomNameImageUpdate,
						   "No image property.",
						   False);
      m_hAtomBeamCenterUpdate = m_poXprop->hSetProperty(ms_sAtomNameBeamCenterUpdate,
						   "No beamcenter property.",
						   False);
      // Now add the property notify handler

      XtAddEventHandler(_MainWindow,
			PropertyChangeMask,
			False,
			(XtEventHandler)MainWindow::vPropNotifyCBCallback,
			(XtPointer)this);
      m_bEventHandlerInstalled = True;
    }
  else if (   !XmToggleButtonGetState(_tbFileListenCollect)
	   && !XmToggleButtonGetState(_tbFileListenOther) 
	   && !XmToggleButtonGetState(_tbFileListenIntegrate) 
	   && m_bEventHandlerInstalled)
    {
      // Remove eventhandler that looks for image and reflnlist updates.

      XtRemoveEventHandler(_MainWindow,
			PropertyChangeMask,
			False,
			(XtEventHandler)MainWindow::vPropNotifyCBCallback,
			(XtPointer)this);

      m_bEventHandlerInstalled = False;

      // Delete properties added (maybe this should be part up CXprop??!

      m_poXprop->nSetWindowID(0); // Required since deleting property does
                                  // not seem to work correctly.

      if ((Atom)None != m_hAtomImageUpdate)
	XDeleteProperty(XtDisplay(_MainWindow), XtWindow(_MainWindow), 
			m_hAtomImageUpdate);
      if ((Atom)None != m_hAtomReflnUpdate)
	XDeleteProperty(XtDisplay(_MainWindow), XtWindow(_MainWindow), 
			m_hAtomReflnUpdate);
      if ((Atom)None != m_hAtomBeamCenterUpdate)
	XDeleteProperty(XtDisplay(_MainWindow), XtWindow(_MainWindow), 
			m_hAtomBeamCenterUpdate);
    }

    // End user code block <vFileListenCB>
}

void MainWindow::vExitCBCallback(Widget w, 
    XtPointer clientData, XtPointer callData)
{
    UICallbackStruct *data = (UICallbackStruct *) clientData;
    MainWindow *obj = (MainWindow *)data->object;
    obj->vExitCB(w, (XtPointer) data->client_data, callData);
}

void MainWindow::vExitCB(Widget w, XtPointer clientData, XtPointer callData)
{
    
    // Begin user code block <vExitCB>
  vDestroy();
  exit (0);
    // End user code block <vExitCB>
}

void MainWindow::vPopupImagePropsCBCallback(Widget w, 
    XtPointer clientData, XtPointer callData)
{
    UICallbackStruct *data = (UICallbackStruct *) clientData;
    MainWindow *obj = (MainWindow *)data->object;
    obj->vPopupImagePropsCB(w, (XtPointer) data->client_data, callData);
}

void MainWindow::vPopupImagePropsCB(Widget w, XtPointer clientData, XtPointer callData)
{
    
    // Begin user code block <vPopupImagePropsCB>

  // Make sure the dialog box has the correct values
  
  vUpdateImageViewPropsDialog();
  _cUIimageviewprops->manage();

    // End user code block <vPopupImagePropsCB>
}

void MainWindow::vPopupReflnPropsCBCallback(Widget w, 
    XtPointer clientData, XtPointer callData)
{
    UICallbackStruct *data = (UICallbackStruct *) clientData;
    MainWindow *obj = (MainWindow *)data->object;
    obj->vPopupReflnPropsCB(w, (XtPointer) data->client_data, callData);
}

void MainWindow::vPopupReflnPropsCB(Widget w, XtPointer clientData, XtPointer callData)
{
    
    // Begin user code block <vPopupReflnPropsCB>
  vUpdateReflnViewPropsDialog();
  _cUIreflnviewprops->manage();
    // End user code block <vPopupReflnPropsCB>
}

void MainWindow::vClearOutputCallback(Widget w, 
    XtPointer clientData, XtPointer callData)
{
    UICallbackStruct *data = (UICallbackStruct *) clientData;
    MainWindow *obj = (MainWindow *)data->object;
    obj->vClearOutput(w, (XtPointer) data->client_data, callData);
}

void MainWindow::vClearOutput(Widget w, XtPointer clientData, XtPointer callData)
{
    
    // Begin user code block <vClearOutput>
  
// This clears ALL the text:
//  XmTextSetSelection(_tfOutput, 0, XmTextGetLastPosition(_tfOutput),
//		     CurrentTime);
#if (XmVersion >= 1002)
  XtVaSetValues(_tfOutput, XmNeditable, True, NULL);
  XmTextRemove(_tfOutput);
  XtVaSetValues(_tfOutput, XmNeditable, False, NULL);
#else
  XmTextRemove(_tfOutput);
#endif
  XmTextShowPosition(_tfOutput, XmTextGetLastPosition(_tfOutput));    

    // End user code block <vClearOutput>
}

void MainWindow::vDeleteReflnsCallback(Widget w, 
    XtPointer clientData, XtPointer callData)
{
    UICallbackStruct *data = (UICallbackStruct *) clientData;
    MainWindow *obj = (MainWindow *)data->object;
    obj->vDeleteReflns(w, (XtPointer) data->client_data, callData);
}

void MainWindow::vDeleteReflns(Widget w, XtPointer clientData, XtPointer callData)
{
    
    // Begin user code block <vDeleteReflns>

  if (NULL != m_poReflnlist)
    {
      // Set lowest 10% of non-rejected reflections to be bad

      Crefln *poRefln;
      int    *pnIndex;

      // Sort on intensity

      pnIndex = new int [max(1, m_poReflnlist->nGetNumReflns())];
      m_poReflnlist->vSort(eReflnField_float_type, 
			   m_poReflnlist->m_nFI_fIntensity, pnIndex);

      int i, j;
      int nNumFlagged;
      i = j = 0;
      nNumFlagged = 0;
      while (    (i < m_poReflnlist->nGetNumReflns())
	     &&  (nNumFlagged * 10 < m_poReflnlist->nGetNumReflns()) )
	{
	  poRefln = m_poReflnlist->poGetRefln(pnIndex[i++]);
	  if (0.0 < poRefln->fGetIntensity())
	    {
	      poRefln->vSetIntensity((float)-997.678);
	      nNumFlagged++;
	    }
	}
      delete [] pnIndex;

      if (0 < nNumFlagged)
	{
	  nNumFlagged = 0;
	  for (i = m_poReflnlist->nGetNumReflns()-1; i >=0; i--)
	    {
	      if ((float)-997.678 == m_poReflnlist->poGetRefln(i)->fGetIntensity())
		{
		  (void) m_poReflnlist->nDelete(i);
		  nNumFlagged++;
		}
	    }
	  sprintf(m_a255cText, "%d refs deleted.\n", nNumFlagged);
	  vPutMessage(m_a255cText);
	  // Re-sort on "color" before display
	  
	  i = m_poReflnlist->m_nFI_nNonunfFlag;
	  if (0 > i)
	    i = m_poReflnlist->m_nFI_nH;
	  m_poReflnlist->vSort(eReflnField_int_type, i, NULL);
	  vViewRefresh(w, NULL, NULL);
	}
    }
    // End user code block <vDeleteReflns>
}

void MainWindow::vEraseToggleCBCallback(Widget w, 
    XtPointer clientData, XtPointer callData)
{
    UICallbackStruct *data = (UICallbackStruct *) clientData;
    MainWindow *obj = (MainWindow *)data->object;
    obj->vEraseToggleCB(w, (XtPointer) data->client_data, callData);
}

void MainWindow::vEraseToggleCB(Widget w, XtPointer clientData, XtPointer callData)
{
    
    // Begin user code block <vEraseToggleCB>
  if (   (NULL == m_poXcursor) 
      || (NULL == m_poXdisplay)
      || (NULL == m_poXdisplay1) )
    return;
  if (XmToggleButtonGetState(w))
    {
      // State is now True, so give user info on how to Erase/Edit the image

      m_nEraseMode      = 1;
      m_poXcursor->vSetFont(XC_gumby, FALSE);
      vPostError(_mbError, 
      (XtPointer)"EraseMode$$Use the Erase circle-cursor and\n"
		 "the Erase line-cursor to set pixels to zero.\n"
               "\nNEW: The erased line thickness is the diameter of\n"
                 "HALF the LAST circle erased.\n"
	       "\nUse File/Save Mask or Image As... \n"
                 "to save the edited image.\n\n"
		 "See also Help on Erase (edit mask) mode....\n",
		 NULL);
      vSetLabel(_tbCursorMeasure, "Erase line", NULL);
      vSetLabel(_tbCursorSpot, "Erase circle", NULL);
      m_poXdisplay1->vSetCursorMode(RB_NONE_MODE);
      m_poXdisplay->vSetCursorMode(RB_NONE_MODE);
      XmToggleButtonSetState(_tbCursorRect, False, False);
      XmToggleButtonSetState(_tbCursorSpot, False, False);
      XmToggleButtonSetState(_tbCursorMeasure, False, False);
      XmToggleButtonSetState(_tbCursorBeam, False, False);

      // vSetLabel(_tbCursorBeam, "Erase quad", NULL);
    }
  else
    {
      // State is now False, so pop-up file_save_dialog in friendly way
      // unless this is the result of ....

      m_poXdisplay->vSetCursorMode(RB_NONE_MODE);
      m_poXdisplay1->vSetCursorMode(RB_NONE_MODE);
      XmToggleButtonSetState(_tbCursorRect, False, False);
      XmToggleButtonSetState(_tbCursorSpot, False, False);
      XmToggleButtonSetState(_tbCursorBeam, False, False);
      XmToggleButtonSetState(_tbCursorMeasure, False, False);
      
      m_poXcursor->vReset();
      vSetLabel(_tbCursorMeasure, "Measure", NULL);
      vSetLabel(_tbCursorSpot, "Spot circle", NULL);
      // vSetLabel(_tbCursorBeam, "Beam circle", NULL);
      // File name 'beam.mask' may not be correct here
      if (0 != m_nEraseMode)
	{
	  // Do not call next line if this routine was not called with the
	  // toggle button set

	  vFileSelectionPostCB(_pbFileSaveAs, NULL, (XtPointer)_tbEditErase);
	}
      m_nEraseMode = 0;
    }
    // End user code block <vEraseToggleCB>
}

void MainWindow::vZoomMsgPopupCallback(Widget w, 
    XtPointer clientData, XtPointer callData)
{
    UICallbackStruct *data = (UICallbackStruct *) clientData;
    MainWindow *obj = (MainWindow *)data->object;
    obj->vZoomMsgPopup(w, (XtPointer) data->client_data, callData);
}

void MainWindow::vZoomMsgPopup(Widget w, XtPointer clientData, XtPointer callData)
{
    
    // Begin user code block <vZoomMsgPopup>
  if (_pbEditBeam == w)
    {
      if (NULL != m_poXdisplay)
        {
          // Kludge: Before posting the message box, make sure its width is
          // 575
          // It would also be nice if the messagebox posted in the upper left
          // corner of the mainwindow, but that would need another callback

          Cardinal ac = 0;
          Arg      args[4];
          ac = 0;
          XtSetArg(args[ac], XmNwidth, 575); ac++;
          XtSetValues(_mbError, args, ac);
          vPostError(_mbError,
          (XtPointer)"ShadowMode$$PLEASE READ ALL OF THIS at least once!!!\n\n"
                     "INFO: Experimental auto beam stop shadow tool\n\n"
                     "1. CLICK anywhere in the area to be masked.\n\n"
                     "2. You may click in a new place to try to mask\n"
                     "   more pixels.\n\n"
                     "3. Dismiss this message box to cancel this shadow\n"
                     "   tool mode and go to manual erase/edit mask mode.\n\n"
                     "4. Touch up in manual erase/edit mask mode, then use\n"
                     "   File/Save Mask or Image As... to save the edited\n"
                     "   image.\n\n"
                     "The algorithm is trying to use edge detection between\n"
                     "areas of high and low pixel values, so if there is no\n"
                     "edge, there is no detection and no masking.\n\n"
                     "Best results occur if you first\n"
                     "UNDERLAY several images with\n"
                     "File/New/Underlay...\n\n"
                     "To un-do, reload an image with\n"
                     "   Next, Prev, or File/Open...\n\n",
                     NULL);
          m_poXdisplay->vSetBeamstopShadowMode(1);
        }
    }
  else
    XtManageChild(_mbViewZoomPan);
    // End user code block <vZoomMsgPopup>
}

void MainWindow::vViewRefreshCallback(Widget w, 
    XtPointer clientData, XtPointer callData)
{
    UICallbackStruct *data = (UICallbackStruct *) clientData;
    MainWindow *obj = (MainWindow *)data->object;
    obj->vViewRefresh(w, (XtPointer) data->client_data, callData);
}

void MainWindow::vViewRefresh(Widget w, XtPointer clientData, XtPointer callData)
{
    
    // Begin user code block <vViewRefresh>

  //+JWP 2012-09-27

  // Figure out if title string will fit on window.  If it won't fit,
  // then modify it 

  Cstring sTitleTemp = m_sTitle;
  vMakeTitleStringFitWindow(_MainWindow, m_sTitle, &sTitleTemp);
  //cout << "1 In: " << m_sTitle << "  Out: " << sTitleTemp << endl;
  XtVaSetValues(XtParent(w), XmNtitle, sTitleTemp.string(), NULL);
  //XtVaSetValues(XtParent(_w), XmNtitle, m_sTitle.string(), NULL);
  //-JWP 2012-09-27

  if (NULL == m_poXdisplay) 
    {
      // There is no display object, so nothing to do

      return;
    }

  if ( (w == _pbViewRefresh) && (0 == m_tImageProps.nAutoRescale))
    {
      // Try to auto-scale
      
      int   nStat;
      int   a4nArea[4];
      float fMin, fMax;
      float fAvg, fSD;
      vPutMessage("Auto-scaling...\n");
      m_poXdisplay->nGetImageProps(&m_tImageProps);
      a4nArea[0] = m_tImageProps.nOrig[0];
      a4nArea[1] = m_tImageProps.nOrig[1];
      a4nArea[2] = m_tImageProps.nExt[0];
      a4nArea[3] = m_tImageProps.nExt[1];
      fMin = min(0.0, m_tImageProps.fImageMin);
      fMax = min(300000.0, m_poImage->fGetSatValue() - 1.0);
      nStat = m_poXdisplay->nAvgSD(*m_poImage, a4nArea, 
				   fMin, fMax,
				   &fMin, &fMax, &fAvg, &fSD);
      if (0 == nStat)
	{
	  if (0.0 >= m_tImageProps.fScaleMinSD)
	    m_tImageProps.fScaleMinSD = 1.5;
	  if (0.0 >= m_tImageProps.fScaleMaxSD)
	    m_tImageProps.fScaleMaxSD = 5.0;
	  m_tImageProps.fScaleMin        = max(m_tImageProps.fImageMin,
					       fAvg - (m_tImageProps.fScaleMinSD
						       * fSD));
	  m_tImageProps.fScaleMax        = min(m_tImageProps.fImageMax,
					       fAvg + (m_tImageProps.fScaleMaxSD
						       * fSD));

	  m_poXdisplay->nSetImageProps(&m_tImageProps);
	  if (NULL != m_poXdisplay1)
	    m_poXdisplay1->nSetImageProps(&m_tImageProps);
	}
    }

  (void) m_poXdisplay->nSetReflnProps(&m_tReflnProps, FALSE);
  m_poXdisplay->vRefresh();

  if (NULL != m_poXdisplay1)
    {
      (void) m_poXdisplay1->nSetReflnProps(&m_tReflnProps, FALSE);
      m_poXdisplay1->vRefresh();
    }
  if (1 == m_nEraseMode)
    m_poXcursor->vSetFont(XC_gumby, FALSE);

    // End user code block <vViewRefresh>
}

void MainWindow::vUnzoomCBCallback(Widget w, 
    XtPointer clientData, XtPointer callData)
{
    UICallbackStruct *data = (UICallbackStruct *) clientData;
    MainWindow *obj = (MainWindow *)data->object;
    obj->vUnzoomCB(w, (XtPointer) data->client_data, callData);
}

void MainWindow::vUnzoomCB(Widget w, XtPointer clientData, XtPointer callData)
{
    
    // Begin user code block <vUnzoomCB>
  if (NULL != m_poXdisplay)
    {
      (void)m_poXdisplay->nSetRegion(0, 0, 0, 0);
      m_poXdisplay->nGetImageProps(&m_tImageProps);
      m_tImageProps.fZoom = 0.9;                  // Set zoom back to 0.9 
      m_poXdisplay->nSetImageProps(&m_tImageProps);
      vUpdateImageViewPropsDialog();
    }
  
    // End user code block <vUnzoomCB>
}

void MainWindow::vViewHeaderCBCallback(Widget w, 
    XtPointer clientData, XtPointer callData)
{
    UICallbackStruct *data = (UICallbackStruct *) clientData;
    MainWindow *obj = (MainWindow *)data->object;
    obj->vViewHeaderCB(w, (XtPointer) data->client_data, callData);
}

void MainWindow::vViewHeaderCB(Widget w, XtPointer clientData, XtPointer callData)
{
    
    // Begin user code block <vViewHeaderCB>

  if (NULL != m_poImage)
    {
/* The following is a bug, since dialogTitle is an XmString, and not
   a String
      
      XtVaSetValues(w, XmNdialogTitle, 
		 (Cstring("d*TREK - Header for:")
			   + m_poImage->sGetName()).string(), NULL);
*/
      if (NULL == m_poHeader)
	m_poHeader = new Cimage_header(m_poImage->m_oHeader);

      XmTextSetString(_tfViewHeader, m_poHeader->sGet().string());
    }
  else
    {
      XmTextSetString(_tfViewHeader, m_sNoHeader.string());
    }
    XtManageChild(_fmViewHeader);

    // End user code block <vViewHeaderCB>
}

void MainWindow::vPlotReflnListCBCallback(Widget w, 
    XtPointer clientData, XtPointer callData)
{
    UICallbackStruct *data = (UICallbackStruct *) clientData;
    MainWindow *obj = (MainWindow *)data->object;
    obj->vPlotReflnListCB(w, (XtPointer) data->client_data, callData);
}

void MainWindow::vPlotReflnListCB(Widget w, XtPointer clientData, XtPointer callData)
{
    
    // Begin user code block <vPlotReflnListCB>

  bool bSet;
  if ( (NULL != m_poXdisplay) && (NULL != m_poReflnlist) )
    {
      // Find out the state of the toggle button
      bSet = XmToggleButtonGetState(w);
      if (bSet)
	{
	  m_poXdisplay->m_tImageProps.nDisplayReflns = 1;
	  m_poXdisplay->m_poReflnlist = m_poReflnlist;   // This should be encapsulated!
	  m_poXdisplay1->m_tImageProps.nDisplayReflns = 1;
	  m_poXdisplay1->m_poReflnlist = m_poReflnlist;   // This should be encapsulated!
	}
      else
	{
	  // Erase any displayed reflection list
	  m_poXdisplay->m_poReflnlist = NULL;   // This should be encapsulated!
	  m_poXdisplay1->m_poReflnlist = NULL;   // This should be encapsulated!
	}
      vViewRefresh(w, NULL, NULL);
    }
    // End user code block <vPlotReflnListCB>
}

void MainWindow::vDrawResoCBCallback(Widget w, 
    XtPointer clientData, XtPointer callData)
{
    UICallbackStruct *data = (UICallbackStruct *) clientData;
    MainWindow *obj = (MainWindow *)data->object;
    obj->vDrawResoCB(w, (XtPointer) data->client_data, callData);
}

void MainWindow::vDrawResoCB(Widget w, XtPointer clientData, XtPointer callData)
{
    
    // Begin user code block <vDrawResoCB>

  if ( (NULL != m_poXdisplay) && (NULL != m_poDetector) )
    {
      float fResMin, fResMax, fResMaxEdge;
      m_poDetector->nGetResolution(m_fS0, &fResMin, &fResMax, &fResMaxEdge);
      sprintf(m_a255cText, "Min, max, edge resol:\n %.2f, %.2f, %.2f\n",
	      fResMin * m_fWavelength, fResMax * m_fWavelength,
	      fResMaxEdge * m_fWavelength);
      vPutMessage(m_a255cText);

      if (w == _tbViewReso)
	{
	  // Special trick to view resolution rings at ice ring locations
	  if (XmToggleButtonGetState(_tbViewReso))
	    m_tImageProps.nResoCircles      = 5;
	  else
	    m_tImageProps.nResoCircles      = -1;	      
	  //	  m_poXdisplay->vSetResol(m_poDetector, m_fS0, m_fWavelength, 
	  //m_tImageProps.nResoCircles);
	  XmToggleButtonSetState(_tbViewMeasure, False, False);
	}
      else if (w == _tbViewMeasure)
	{
	  // Special trick to view resolution rings at ice ring locations
	  if (XmToggleButtonGetState(_tbViewMeasure))
	    m_tImageProps.nResoCircles      = 8;
	  else
	    m_tImageProps.nResoCircles      = -1;
	  //m_poXdisplay->vSetResol(m_poDetector, m_fS0, m_fWavelength,
	  //m_tImageProps.nResoCircles);
	  XmToggleButtonSetState(_tbViewReso, False, False);
	}
      else
	{
	  m_tImageProps.nResoCircles      = -1;
	}
      
      m_poXdisplay->vSetResol(m_poDetector, m_fS0, m_fWavelength, 
				  m_tImageProps.nResoCircles);
      m_poXdisplay->vRefresh();
    }

    // End user code block <vDrawResoCB>
}

void MainWindow::vPopDialogCallback(Widget w, 
    XtPointer clientData, XtPointer callData)
{
    UICallbackStruct *data = (UICallbackStruct *) clientData;
    MainWindow *obj = (MainWindow *)data->object;
    obj->vPopDialog(w, (XtPointer) data->client_data, callData);
}

void MainWindow::vPopDialog(Widget w, XtPointer clientData, XtPointer callData)
{
    
    // Begin user code block <vPopDialog>
  if (w == _pbHelpAbout)
    {
      Cstring sTemp;
      sTemp = (Cstring)"HelpAbout$$dtdisplay\nHelp About...\n"
	      + (Cstring) D_K_DTREKVersion
	      + (Cstring)"\nCopyright (c) 2006 Rigaku\n"
	+ (Cstring)"\nReference: Pflugrath, JW (1999) Acta Cryst. D55,"
        + (Cstring)"\n                1718-1725.\n"
        + (Cstring)"\nPlease see the file ${DTREK_ROOT}/ACKNOWLEDGEMENTS"
        + (Cstring)"\nfor further acknowledgements, copyrights and"
        + (Cstring)"\nlicense information.";

      vPostError(_mbError, (XtPointer)sTemp.string(), NULL);
    }
  else if (w == _pbHelpRefln)
    {
      vPostError(_mbError, (XtPointer)"HelpReflnColor$$"
		 "The Edit / Refln view props... dialog selects the color\n"
                 "and symbol used for displaying reflections and spots.\n"
	       "\nNormally, reflections are displayed as blue circles or ellipses:\n"
                "BLUE circles:    reflns in the loaded reflnlist\n"
                "BLUE squares:    reflns in the loaded reflnlist NOT intersecting\n"
                "                       rotation range of currently displayed image (i.e. Pad)\n"
                "RED diamonds:    reflns in bad regions or overlapped,\n"
                "                         or rejected reflns from refinement\n\n"
                "GREEN diamonds:  reflns ignored in refinement\n\n"
               "\nIf rocking curve information is available in the reflnlist\n"
                 "and if symbol 'o and []' is selected, then reflections with\n"
		 "rocking curves that intersect the image will be drawn\n"
		 "as circles and those with rocking curves that do not\n"
		 "intersect the image will be drawn as squares.\n"
	       "\nOr if symbol 'o and no []' is selected, then ONLY reflections\n"
                 "with rocking curves that intersect the image will be drawn.\n"
                 "Reflections in the list that do not intersect the image\n"
                 "will NOT be drawn.  You may not see reflections used\n"
                 "in refinement if they do not appear in the displayed image.\n"
               "\nThus in 'o and []' mode DURING integration, you should see\n"
                 "spots in circles and background in squares.  Circles and\n"
                 "squares may be overlapping.  If you see spots in squares,\n"
                 "then it is likely that the crystal mosaicity is set too\n"
                 "low.  If you do not see spots in some circles, then the\n"
                 "the crystal mosaicity may be set too high.\n"
               "\nIf no rocking curve information is available, then ALL reflns\n"
                 "will be drawn as circles.\n"
               "\nReflections with a non-zero nonunf flag will be drawn in either\n"
                 "RED or GREEN with a diamond superimposed on the normal symbol.\n"
                 "Overlapped reflections are also drawn in RED with a diamond\n"
                 "superimposed.  GREEN reflections are those ignored by refinement.\n"
               "\nNo information about reflection partiality is displayed,\n"
                 "since in d*TREK the concept of partiality has no meaning.\n"
                  "\nDorothy in 'The Wizard of d*TREK':\n"
		  "    'Toto, I have a feeling we're not in denzo anymore.'\n",
		 NULL);
    }
    // End user code block <vPopDialog>
}

void MainWindow::vUtilsCBCallback(Widget w, 
    XtPointer clientData, XtPointer callData)
{
    UICallbackStruct *data = (UICallbackStruct *) clientData;
    MainWindow *obj = (MainWindow *)data->object;
    obj->vUtilsCB(w, (XtPointer) data->client_data, callData);
}

void MainWindow::vUtilsCB(Widget w, XtPointer clientData, XtPointer callData)
{
    
    // Begin user code block <vUtilsCB>
  Cstring sTemp;
  if (w == _pbUtilsProcess)
    {
      // Write out dtdisplay.head first, then launch dtprocess 

      if ( (NULL == m_poHeader) || !m_poHeader->bIsAvailable() )
	{
	  sTemp = (Cstring)"Header not available, display an image first!";
	  vPostError(_mbError, (XtPointer)sTemp.string(), NULL);	  
	}
      else if (0 == m_poHeader->nWrite(m_sHeaderFilename))
	{
	  sTemp = m_sHeaderFilename;
	  vPutMessage("...starting dtprocess " + sTemp + " ...\n", 1);
	  nDoSystemCommand(sTransSymbol("$(dtprocess)") + ' ' + sTemp
			   + " -nodisplay &");
	}
      else
	{
	  vPutMessage(Cstring("ERROR writing new header file: ") + m_sHeaderFilename
                      + "\ndtprocess NOT launched!", 1);
	}
/*
      // Launch dtprocess with current image if available, otherwise use
      // dtprocess.head in current directory if available, otherwise no file


      sTemp = "dtprocess.head";
      if ("" != m_sFilename)
	{
	  sTemp = m_sFilename;
	}
      if (!bFileExists(sTemp)) sTemp = "";
      vPutMessage("... Launching dtprocess " + sTemp + " ...\n", 1);
      nDoSystemCommand(sTransSymbol("$(dtprocess)") + ' ' + sTemp
		       + " -nodisplay &");
*/
    }
  else if (w == _pbUtilsProcessExtern)
    {
      //sprintf(m_a255cText, "Process > ProcessExtern clicked.\n");
      //vPutMessage(m_a255cText);
      sTemp = sTransSymbol("$(DTREK_PROCESS_EXTERN)");
      vPutMessage("... Attempting to launch " + sTemp + " ...\n", 1);
      Cstring sName = "";
      if (NULL != m_poScan)
        m_poScan->nGetImageName(&sName);
      // We need the full path name of the image
      //+2012-12-10 JWP
      if (0 == sName.length())
        {
          // Probably no image displayed
        }
      else if ('/' != sName.GetAt(0))
        {
          sName = sGetCWD() + sName;
        }
      else
        {
          // The image filename has a suggestion of a full path, 
          // should we change directory to that directory or not?
          Cstring sCommand;
          sCommand = "cd " + sFileGetDirectory(sTemp) + "; " + sTemp;
          sTemp = sCommand;
        }
      //-2012-12-10 JWP
      // Let's add as arguments some things which may have been edited by the user:
      // a) beam coordinates in pixels,
      // b) distance in mm,
      // c) 2theta in degrees
      // There are other things that may be edited, but these are probably the major ones
      // except for Wavelength

      Cstring sParams = "";
      if (NULL != m_poDetector)
        {
          float fBeam0 = 0.0;
          float fBeam1 = 0.0;
          (void) m_poDetector->m_poSpatial->nGetBeamPosition(&fBeam0, &fBeam1);
          float fDist = 100.0;
          fDist = m_poDetector->fGetDistance();
          float fSwing = 0.0;
          fSwing = m_poDetector->fGetSwing();
          sParams =   Cstring(fBeam0, 6) + ' ' 
                    + Cstring(fBeam1, 6) + ' '
                    + Cstring(fDist,  6) + ' '
                    + Cstring(fSwing, 6);
        }
      nDoSystemCommand(sTemp + ' ' + sName + sParams + " &");
    }
  else if (w == _pbUtilsProcessExternHKL)
    {
      if ("" != sGetEnv("DTREK_PROCESS_HKL"))
	sTemp = sTransSymbol("$(DTREK_PROCESS_HKL)");
      else
	sTemp = "HKL2000"; 
      vPutMessage("... Attempting to launch " + sTemp + " ...\n", 1);
      nDoSystemCommand(sTemp + " &");
    }
  else if (w == _pbUtilsProcessExternXDS)
    {
      if ("" != sGetEnv("DTREK_PROCESS_XDS"))
	sTemp = sTransSymbol("$(DTREK_PROCESS_XDS)");
      else
	sTemp = "xds"; 
      vPutMessage("... Attempting to launch " + sTemp + " ...\n", 1);
      Cstring sName = "";
      if (NULL != m_poScan)
	m_poScan->nGetImageName(&sName);
      nDoSystemCommand(sTemp + ' ' + sName + " &");
    }
  else if (w == _pbUtilsProcessExternMOSFLM)
    {
      if ("" != sGetEnv("DTREK_PROCESS_MOSFLM"))
	sTemp = sTransSymbol("$(DTREK_PROCESS_MOSFLM)");
      else
	sTemp = "imosflm"; 
      vPutMessage("... Attempting to launch " + sTemp + " ...\n", 1);
      nDoSystemCommand(sTemp + " &");
    }
    // End user code block <vUtilsCB>
}

void MainWindow::vCursorModeCBCallback(Widget w, 
    XtPointer clientData, XtPointer callData)
{
    UICallbackStruct *data = (UICallbackStruct *) clientData;
    MainWindow *obj = (MainWindow *)data->object;
    obj->vCursorModeCB(w, (XtPointer) data->client_data, callData);
}

void MainWindow::vCursorModeCB(Widget w, XtPointer clientData, XtPointer callData)
{
    
    // Begin user code block <vCursorModeCB>
  if ( (NULL != m_poXdisplay) && (NULL != m_poXdisplay1) )
    {
      if (w == _tbCursorRect)
	{
	  if (!XmToggleButtonGetState(_tbCursorRect))
	    {
	      m_poXdisplay->vSetCursorMode(RB_NONE_MODE);
	      m_poXdisplay1->vSetCursorMode(RB_NONE_MODE);
	      vUnzoomCB(w, NULL, NULL);
	      m_poXcursor->vReset();
	    }
	  else
	    {
	      m_poXdisplay->vSetCursorMode(RB_RECT_MODE);
	      m_poXdisplay1->vSetCursorMode(RB_RECT_MODE);
	      XmToggleButtonSetState(_tbCursorSpot, False, False);
	      XmToggleButtonSetState(_tbCursorBeam, False, False);
	      XmToggleButtonSetState(_tbCursorMeasure, False, False);
	      m_poXcursor->vSetFont(XC_sizing, TRUE);
	    }
	}
      else if (w == _tbCursorMeasure)
	{
	  if (!XmToggleButtonGetState(_tbCursorMeasure))
	    {
	      m_poXdisplay->vSetCursorMode(RB_NONE_MODE);
	      m_poXdisplay1->vSetCursorMode(RB_NONE_MODE);
	      m_poXcursor->vReset();
	    }
	  else
	    {
	      if (!XmToggleButtonGetState(_tbEditErase))
		{
		  // Erase mode not active, use thin line mode

		  m_poXdisplay->vSetCursorMode(RB_LINE_MODE);
		  m_poXdisplay1->vSetCursorMode(RB_LINE_MODE);
		}
	      else
		{
		  // Erase mode is active, use THICK line mode

		  m_poXdisplay->vSetCursorMode(RB_TLIN_MODE);
		  m_poXdisplay1->vSetCursorMode(RB_TLIN_MODE);
		}
		
	      XmToggleButtonSetState(_tbCursorRect, False, False);
	      XmToggleButtonSetState(_tbCursorSpot, False, False);
	      XmToggleButtonSetState(_tbCursorBeam, False, False);
	      m_poXcursor->vSetFont(XC_hand2, TRUE);
	    }
	}
      else if (w == _tbCursorSpot)
	{
	  if (!XmToggleButtonGetState(_tbCursorSpot))
	    {
	      m_poXdisplay->vSetCursorMode(RB_NONE_MODE);
	      m_poXdisplay1->vSetCursorMode(RB_NONE_MODE);
	      m_poXcursor->vReset();
	    }
	  else
	    {
	      m_poXdisplay->vSetCursorMode(RB_CIRC_MODE);
	      m_poXdisplay1->vSetCursorMode(RB_CIRC_MODE);
	      XmToggleButtonSetState(_tbCursorRect, False, False);
	      XmToggleButtonSetState(_tbCursorBeam, False, False);
	      XmToggleButtonSetState(_tbCursorMeasure, False, False);
	      m_poXcursor->vSetFont(XC_circle, TRUE);
	    }
	}
      else if (w == _tbCursorBeam)
	{
	  if (!XmToggleButtonGetState(_tbCursorBeam))
	    {
	      m_poXdisplay->vSetCursorMode(RB_NONE_MODE);
	      m_poXdisplay1->vSetCursorMode(RB_NONE_MODE);
	      m_poXcursor->vReset();
	    }
	  else
	    {
	      m_poXdisplay->vSetCursorMode(RB_CIR2_MODE);
	      m_poXdisplay1->vSetCursorMode(RB_CIR2_MODE);
	      XmToggleButtonSetState(_tbCursorRect, False, False);
	      XmToggleButtonSetState(_tbCursorSpot, False, False);
	      XmToggleButtonSetState(_tbCursorMeasure, False, False);
	      m_poXcursor->vSetFont(XC_target, TRUE);
	    }
	}
    }
    // End user code block <vCursorModeCB>
}

void MainWindow::vFileTemplateCBCallback(Widget w, 
    XtPointer clientData, XtPointer callData)
{
    UICallbackStruct *data = (UICallbackStruct *) clientData;
    MainWindow *obj = (MainWindow *)data->object;
    obj->vFileTemplateCB(w, (XtPointer) data->client_data, callData);
}

void MainWindow::vFileTemplateCB(Widget w, XtPointer clientData, XtPointer callData)
{
    
    // Begin user code block <vFileTemplateCB>

  int nTemp, nStat;
  m_poXcursor->vSetWait();
  if (NULL == m_poScan)
    {
      m_poScan = new Cscan ();
    }
  if (NULL != m_poScan)
    {
      XtVaGetValues(w, XmNuserData, &nTemp, NULL);
      if (NULL == m_poImage)
	{
	  // Create the empty new image, so that a file can be read in below

	  m_poImage = new Cimage ();
	}

      int nSeq;
      nSeq = m_poScan->nGetSeqNum();
      if (w == _pbImagePrev)
	{
	  // Previous image
	  vPutMessage("Previous image...\n");
	}
      else if (w == _pbImageNext)
	{
	  // Next image
	  vPutMessage("Next image...\n");
	}
      else
	{
	  // Possible number entered in text field... read it and 

	  char *pcString;
	  pcString = XmTextGetString(_tfImageNum);
	  nStat = sscanf(pcString, "%d", &nTemp);
	  if (1 == nStat)
	    {
	      sprintf(m_a255cText, "Image #: %d\n", nTemp);
	      vPutMessage(m_a255cText);
	      m_poScan->vSetSeqNum(nTemp);
	    }
	  XtFree(pcString);
	}

      // If _pbImagePrev or _pbImageNext, then keep trying if
      // the image number DOES NOT exist up to 360 times.

      int nTries = 0;
      do
	{
	  if (w == _pbImagePrev)
	    {
	      // Previous image

	      m_poScan->vPrevSeqNum();
	    }
	  else if (w == _pbImageNext)
	    {
	      // Next image

	      m_poScan->vNextSeqNum();
	    }

	  // Put the actual number back into the text field

	  if (0 == nTries)
	    nTemp = m_poScan->nGetSeqNum();

	  // Place image filename into member variable m_sFilename

	  (void)  m_poScan->nGetImageName(&m_sFilename);
	  nTries++;
	} while (!bFileExists(m_sFilename) && (360 > nTries)
		 && ((w == _pbImagePrev) || (w == _pbImageNext)) );

      if (!bFileExists(m_sFilename))
	{
	  // Could not find the image, so abort

	  m_poScan->vSetSeqNum(nTemp);
	  (void)  m_poScan->nGetImageName(&m_sFilename);
	  vPutMessage(Cstring("Image file ") + m_sFilename

                      + " does not exist!\n", 1);

	  // Go back to original sequence number

	  m_poScan->vSetSeqNum(nSeq);
	  sprintf(m_a255cText, "%d", nSeq);
	  XmTextSetString(_tfImageNum, m_a255cText);
	  m_poXcursor->vReset();
	  return;
	}

      sprintf(m_a255cText, "%d", m_poScan->nGetSeqNum());
      XmTextSetString(_tfImageNum, m_a255cText);

      m_poScan->nGetImage(m_poImage);
      m_tImageProps.nPlotRockingCurve = 0;

      if (NULL == m_poXdisplay)
	{
	  // This calculates new scaling factors
	  vNewImage();
	}
      else
	{
	  // This keeps old scaling factors, etc.

	  m_poXdisplay->nSetImageProps(&m_tImageProps);
	  XmTextSetString(_tfViewHeader, m_poImage->m_oHeader.sGet().string());
	  if (m_poImage->bIsAvailable())
	    {
	      m_sTitle = "d*TREK: dtdisplay - Image filename: " 
		         + m_sFilename;

	      //+2012-12-11 JWP
	      // Maybe adjust m_sTitle ?
	      Cstring sTitleTemp;
	      vMakeTitleStringFitWindow(_MainWindow, m_sTitle, &sTitleTemp);
	      // cout << "2 In: " << m_sTitle << "  Out: " << sTitleTemp << endl;
	      m_sTitle = sTitleTemp;
	      //-2012-12-11 JWP

	      XtSetSensitive(_cbView, True);
	      XtSetSensitive(_pbFileSaveAs, True);
	      XtSetSensitive(_pbFilePrint, True);

	      // Read rotation information from the header

	      if (NULL != m_poRotation)
		{
		  delete m_poRotation;
		  m_poRotation = NULL;
		}

	      m_poRotation = new Crotation (m_poImage->m_oHeader);

	      // Fill rotation start and end text fields

//	      cout << "From m_poRotation!\n";
	      m_tReflnProps.fImageRotStart = m_poRotation->fGetRotStart();
	      m_tReflnProps.fImageRotEnd   = m_poRotation->fGetRotEnd();
	      sprintf (m_a255cText, "%.3f", m_poRotation->fGetRotStart());
	      XmTextSetString(_tfRotStart, m_a255cText);
	      sprintf (m_a255cText, "%.3f", m_poRotation->fGetRotEnd());
	      XmTextSetString(_tfRotEnd, m_a255cText);
	      vViewRefresh(_w, NULL, NULL);
	      
	      // Get crystal goniometer angles from header 
	      Cstring sTemp;
	      if (0 == m_poImage->m_oHeader.nGetValue(
			      D_K_CrystalPrefix D_K_GonioValues, &sTemp))
		{
		  sprintf(m_a255cText, "Crystal gonio angles:\n%s\n",
			  sTemp.string());
		  vPutMessage(m_a255cText);
		}
	    }	      
	  else
	    {
	      // Image was not read in properly.

	      XtSetSensitive(_cbView, False);
	      XtSetSensitive(_pbFileSaveAs, False);
	      XtSetSensitive(_pbFilePrint, False);

	      m_sTitle = "d*TREK display - Image unavailable";
	      if (NULL != m_poXdisplay)
		{
		  delete m_poXdisplay;
		  m_poXdisplay = NULL;
		}
	      if (NULL != m_poXdisplay1)
		{
		  delete m_poXdisplay1;
		  m_poXdisplay1 = NULL;
		}
	      if (NULL != m_poImage)
		{
		  delete m_poImage;
		  m_poImage = NULL;
		}
	    }
	  //+JWP 2012-09-27
	  // Figure out if title string will fit on window.  If it won't fit,
	  // then modify it 
	  Cstring sTitleTemp = m_sTitle;
	  vMakeTitleStringFitWindow(_MainWindow, m_sTitle, &sTitleTemp);
	  //cout << "4 In: " << m_sTitle << "  Out: " << sTitleTemp << endl;
	  //m_sTitle = sTitleTemp;
	  XtVaSetValues(XtParent(_w), XmNtitle, sTitleTemp.string(), NULL);
	  //XtVaSetValues(XtParent(_w), XmNtitle, m_sTitle.string(), NULL);
	  //-JWP 2012-09-27
	}
    }
  m_poXcursor->vReset();
    // End user code block <vFileTemplateCB>
}

void MainWindow::vTextFieldCBCallback(Widget w, 
    XtPointer clientData, XtPointer callData)
{
    UICallbackStruct *data = (UICallbackStruct *) clientData;
    MainWindow *obj = (MainWindow *)data->object;
    obj->vTextFieldCB(w, (XtPointer) data->client_data, callData);
}

void MainWindow::vTextFieldCB(Widget w, XtPointer clientData, XtPointer callData)
{
    
    // Begin user code block <vTextFieldCB>
  //Callback for the textfield widgets

  char *pcString;
  XmAnyCallbackStruct *cbs =  (XmAnyCallbackStruct *) callData;
  float fTemp;
  int   nStat;
  Boolean bChanged    = False;
  Boolean bRotChanged = False;
  float fResMin, fResMax, fResMaxEdge;
  static char *pcMinMaxResol = "Min, max, edge resol:\n %.2f, %.2f, %.2f\n";

  if ( (XmCR_ACTIVATE == cbs->reason) || (XmCR_LOSING_FOCUS == cbs->reason) )
    {
      // Read the text in the widget into a float variable

      pcString = XmTextGetString(w);
      nStat = sscanf(pcString, "%f", &fTemp);
      XtFree(pcString);

      if (1 == nStat)
	{
	  if (w == _tfRotStart) 
	    {
	      // Rot start

	      m_tReflnProps.fImageRotStart = fTemp;
	      bRotChanged = True;
	      if (NULL != m_poRotation)
		{
		  m_poRotation->vSetRotStart(fTemp);
		}
	    }
	  else if (w == _tfRotEnd)
	    {
	      // Rot end

	      m_tReflnProps.fImageRotEnd = fTemp;
	      bRotChanged = True;
	      if (NULL != m_poRotation)
		{
		  m_poRotation->vSetRotEnd(fTemp);
		}
	    }
	  else if (w == _tfDetDist)
	    {
	      // Det dist
	      bChanged = (m_fDetDist != fTemp);
	      m_fDetDist = fTemp;
	      if (NULL != m_poDetector)
		{
		  m_poDetector->m_poGoniometer->nSetDistance(m_fDetDist);
		  m_poDetector->nUpdateHeader(m_poHeader, "");
		  m_poDetector->nGetResolution(m_fS0, &fResMin, &fResMax,
					       &fResMaxEdge);
		  sprintf(m_a255cText, pcMinMaxResol,
			  fResMin * m_fWavelength, fResMax * m_fWavelength,
			  fResMaxEdge * m_fWavelength);
		  vPutMessage(m_a255cText);
		}
	    }
	  else if (w == _tfDetSwing)
	    {
	      // Det swing
	      bChanged = (m_fDetSwing != fTemp);
	      m_fDetSwing = fTemp;
	      if (NULL != m_poDetector)
		{
		  m_poDetector->m_poGoniometer->nSetSwing(m_fDetSwing);
		  m_poDetector->nUpdateHeader(m_poHeader, "");
		  m_poDetector->nGetResolution(m_fS0, &fResMin, &fResMax, 
					       &fResMaxEdge);
		  sprintf(m_a255cText, pcMinMaxResol,
			  fResMin * m_fWavelength, fResMax * m_fWavelength,
			  fResMaxEdge * m_fWavelength);
		  vPutMessage(m_a255cText);
		}
	    }
	  else if (w == _tfWavelength) 
	    {
	      // Wavelength
	      bChanged = (m_fWavelength != fTemp);
	      m_fWavelength = fTemp;
	      if (NULL != m_poSource)
		{
		  m_poSource->m_poWavelength->nSetWavelength(m_fWavelength);
		  m_poSource->nUpdateHeader(m_poHeader);
		  if (NULL != m_poDetector)
		    {
		      m_poDetector->nGetResolution(m_fS0, &fResMin, &fResMax, 
						   &fResMaxEdge);
		      sprintf(m_a255cText, pcMinMaxResol,
			      fResMin * m_fWavelength, fResMax * m_fWavelength,
			      fResMaxEdge * m_fWavelength);
		      vPutMessage(m_a255cText);
		    }
		}
	    }
	  if (   bChanged
		 && (XmToggleButtonGetState(_tbViewReso)
//+JWP 2008-03-05
// if ice rings displayed, be sure to update them as well
		     || XmToggleButtonGetState(_tbViewMeasure)) 
//-JWP 2008-03-05
	      && (NULL != m_poXdisplay) )
	    {
	      m_poXdisplay->vSetWavelength(m_fWavelength);
	      m_poXdisplay->vRefresh();
	    }
	  if (   bRotChanged
	      && XmToggleButtonGetState(_tbViewObs))
	    {
	      vViewRefresh(w, NULL, NULL);
	    }
	}
      if (XmCR_ACTIVATE == cbs->reason)
//      if (NULL != cbs->event)
	{
	  // Get the background color of the parent and reset the background
	  // color of this widget to that of the parent
//	  Pixel hPixel;
//          XtVaGetValues(XtParent(w), XmNbackground, &hPixel, NULL);
//	  XtVaSetValues(w, XmNbackground, hPixel, NULL );
	}
      // Update the text formatting in all the text widgets

      vUpdateText();
    }
  else if (XmCR_VALUE_CHANGED == cbs->reason)
    {
      if (NULL != cbs->event) 
	{
#if (XmVersion >= 1002)
//	  XmChangeColor(w, BX_CONVERT(w, "red", XmRPixel, 0, &bTemp));
#else
//	  XtVaSetValues(w, XmNbackground, 
//			BX_CONVERT(w, "red", XmRPixel, 0, &bTemp), NULL);
#endif
	}
    }

    // End user code block <vTextFieldCB>
}

void MainWindow::vDAInputCBCallback(Widget w, 
    XtPointer clientData, XtPointer callData)
{
    UICallbackStruct *data = (UICallbackStruct *) clientData;
    MainWindow *obj = (MainWindow *)data->object;
    obj->vDAInputCB(w, (XtPointer) data->client_data, callData);
}

void MainWindow::vDAInputCB(Widget w, XtPointer clientData, XtPointer callData)
{
    
    // Begin user code block <vDAInputCB>
  if (NULL != m_poXdisplay)
    {
      XmDrawingAreaCallbackStruct *cbs =
	(XmDrawingAreaCallbackStruct *) callData;
      XEvent *pXevent = cbs->event;

      if (XmCR_INPUT == cbs->reason)
	{
	  if (ButtonRelease == pXevent->xany.type)
	    {
	      XmProcessTraversal(w, XmTRAVERSE_CURRENT);
	      int nX = pXevent->xbutton.x;
	      int nY = pXevent->xbutton.y;
	      if (1 == pXevent->xbutton.button)
		{
		  // Put pixel coords, value in scrolledtext widget

		  float f1, f2, fValue;
		  int nStat;
		  nStat = m_poXdisplay->nDpyPixToImgPix(nX, nY, &f1, &f2);
		  if (0 == nStat)
		    {
		      m_dCurrPoint[0] = (double)f1;
		      m_dCurrPoint[1] = (double)f2;
		      fValue = (m_poImage->*m_poImage->prfGetPixel)((int)(f1),
								    (int)(f2));
		      sprintf (m_a255cText, "\nImage coords: %.1f, %.1f\n"
			       "Value:     %12d\n", 
			       f1, f2, (int) fValue);
		      vPutMessage(m_a255cText);

		      if (NULL != m_poDetector)
			{
			  float fReso, f1MM, f2MM, f3MM;

			  // List millimeter position if it can be calculated

			  nStat = m_poDetector->m_poSpatial->nPixeltoMM(f1, f2,
						  &f1MM, &f2MM, &f3MM);
			  if (0 == nStat)
			    {
			      sprintf (m_a255cText, "Mm pos: %8.2f, %8.2f\n",
				       f1MM, f2MM);
			      vPutMessage(m_a255cText);
			    }

			  // List resolution if it can be calculated

			  fReso = m_poDetector->fCalcGetResolution((double)f1, (double)f2,
								   m_fS0,
								   &m_dCurrPointX[0])
			          * m_fWavelength;
			  vIntegrate2D(fReso);
			  if (0.0 < fReso)
			    {
			      if (XmToggleButtonGetState(_tbViewMeasure))
				{
				  // Compute d-spacing between this point 
				  // and the previous point if the Measure
				  // togglebutton is set.

				  double a3dDiff[3];
				  vSubVec3DVec3D(m_dCurrPointX,
						 m_dPrevPointX, a3dDiff); 
				  double dDspacing = fLenVec3D(a3dDiff);
				  if (0.0 != dDspacing)
				    dDspacing = ABS(m_fWavelength / dDspacing);
				  else
				    dDspacing = 999999.99;
				  sprintf(m_a255cText, 
					  "d-spacing between last\n"
					  "2 points:  %12.2lf\n", dDspacing);
				  vPutMessage(m_a255cText);
				}
			      // Calculate 2theta for the small mol folks

			      f1MM = 2.0 * asin((double)m_fWavelength * 0.5 / (double)fReso)
                                       / Gs_dRADIANS_PER_DEGREE;
			      sprintf (m_a255cText,
				       "Resol: %9.2f A,  2T: %.0f\n", fReso, f1MM);
			      vPutMessage(m_a255cText);
			    }
			  m_dPrevPoint[0] = f1MM;
			  m_dPrevPoint[1] = f2MM;
			  m_dPrevPoint[2] = fReso;
			  m_dPrevPointX[0] = m_dCurrPointX[0];
			  m_dPrevPointX[1] = m_dCurrPointX[1];
			  m_dPrevPointX[2] = m_dCurrPointX[2];
			} // End of NULL != m_poDetector

		      if (   (NULL != m_poReflnlist)
			  && XmToggleButtonGetState(_tbViewObs) )
			{
			  // Try to find if there is a refln near what was
			  // clicked on
			  
			  nStat = 0;
			  Crefln *poRefln;
			  float fClose0, fClose1;
			  int nFI_fRotMid;
			  nFI_fRotMid = m_nFI4;
			  if (   (0 < m_poReflnlist->nGetNumReflns())
			      && (0 < nFI_fRotMid) )
			    {
			      // Decide to show observed rot mid or calc rot mid

			      poRefln = m_poReflnlist->poGetRefln(0);
			      if (  (-900.0 > poRefln->fGetField(nFI_fRotMid))
				  && (0 < m_nFI5) )
				{
				  // Observed rot mid is bogus and calc rot mid available

				  nFI_fRotMid = m_nFI5;
				}
			    }
			  fClose0 = (float)m_tImageProps.nIntegrateBox[0] * 0.5;
			  fClose1 = (float)m_tImageProps.nIntegrateBox[1] * 0.5;
			  if (0 < m_nFI0 && 0 < m_nFI1)
			    {
			      float fTemp;
			      for (int i = 0;
				      (i < m_poReflnlist->nGetNumReflns())
				   && (0 == nStat); i++)
				{
				  poRefln = m_poReflnlist->poGetRefln(i);
				  fTemp = poRefln->fGetField(m_nFI0);
				  if (0.0 > fTemp) fTemp = poRefln->fGetField(m_nFI2);
				  if (fClose0 > ABS(fTemp - f1))
				    {
				      fTemp = poRefln->fGetField(m_nFI1);
				      if (0.0 > fTemp) fTemp = poRefln->fGetField(m_nFI3);
				      if (fClose1 > ABS(fTemp - f2))
					{
					  // Found reflection close to point
					  if (0 > nFI_fRotMid)
					    {
					      sprintf (m_a255cText,
						       "hkl: %d, %d, %d\n",
						       poRefln->nGetH(),
						       poRefln->nGetK(),
						       poRefln->nGetL());
					    }
					  else
					    {
					      sprintf (m_a255cText,
						       "hkl: %d, %d, %d  Rot:%8.2f\n",
						       poRefln->nGetH(),
						       poRefln->nGetK(),
						       poRefln->nGetL(),
						       poRefln->fGetField(nFI_fRotMid));
					    }
					  vPutMessage(m_a255cText);
					}
				    }
				} // next i
			    }
			} // End of NULL != m_poReflnlist
		    }

		  // Now update _daSmallImage with zoom around selected point

		  m_poXdisplay->nGetImageProps(&m_tImageProps);
		  if (   (NULL != m_poXdisplay1) 
		      && (1 == pXevent->xbutton.button) )
		    {
		      int nOrigB[2], nExtB[2];
		      float fMid[2];
		  
		      if (0 == m_poXdisplay->nDpyPixToImgPix(nX, nY, 
							     &fMid[0],
							     &fMid[1]))
			{
			  nOrigB[0] = (int) fMid[0] 
			                - m_tImageProps.nIntegrateBox[0]/2;
			  nOrigB[1] = (int) fMid[1] 
                                        - m_tImageProps.nIntegrateBox[1]/2;
			  nExtB[0]  = m_tImageProps.nIntegrateBox[0];
			  nExtB[1]  = m_tImageProps.nIntegrateBox[1];
			  m_poXdisplay1->nSetRegion(nOrigB[0], nOrigB[1],
						    nExtB[0], nExtB[1]);
			  m_poXdisplay1->vSetZoom(1.0);
			  m_poXdisplay1->vRefresh();
			}
		    }
		}
	    }
	}
    }
    // End user code block <vDAInputCB>
}

// Begin user code block <tail>

void
MainWindow::vUpdateImageViewPropsDialog(void)
{
  // Update the Edit Image Properties dialog
  // Transfer the information in m_tImageProps into the dialog box.

  if (NULL != m_poXdisplay)
    {
      m_poXdisplay->nGetImageProps(&m_tImageProps);
      tagImageProps tProps;
//      tProps.fRotStart        = m_tImageProps.fRotStart;
//      tProps.fRotEnd          = m_tImageProps.fRotEnd;
//      tProps.fExpTime         = m_tImageProps.fExpTime;
      tProps.fBorder          = m_tImageProps.fZoom;
      tProps.fScaleMin        = m_tImageProps.fScaleMin;
      tProps.fScaleMax        = m_tImageProps.fScaleMax;
      tProps.fImageMin        = m_tImageProps.fImageMin;
      tProps.fImageMax        = m_tImageProps.fImageMax;
      tProps.fAvg             = m_tImageProps.fAvg;
      tProps.fSD              = m_tImageProps.fSD;
      tProps.fAspectRatio     = m_tImageProps.fAspectRatio;
      tProps.nDim[0]          = m_tImageProps.nDim[0];
      tProps.nDim[1]          = m_tImageProps.nDim[1];
      tProps.nOrig[0]         = m_tImageProps.nOrig[0];
      tProps.nOrig[1]         = m_tImageProps.nOrig[1];
      tProps.nIntegrateBox[0] = m_tImageProps.nIntegrateBox[0];
      tProps.nIntegrateBox[1] = m_tImageProps.nIntegrateBox[1];
      tProps.nAutoRescale     = m_tImageProps.nAutoRescale;
      if (-1 != m_tImageProps.nOrient)
	tProps.nOrient          = m_tImageProps.nOrient;
      tProps.nAspectMode      = m_tImageProps.nAspectMode;
      tProps.nDisplayReflns   = m_tImageProps.nDisplayReflns;
      tProps.nDisplayPixValues= m_tImageProps.nDisplayPixValues;
      tProps.fSatPixValue     = m_tImageProps.fSatPixValue;
      tProps.sSatPixColor     = m_tImageProps.sSatPixColor;
      tProps.fTooLowPixValue     = m_tImageProps.fTooLowPixValue;
      tProps.sTooLowPixColor     = m_tImageProps.sTooLowPixColor;
      if (NULL != m_poRotation)
	{
	  tProps.fRotStart    = m_poRotation->fGetRotStart();
	  tProps.fRotEnd      = m_poRotation->fGetRotEnd();
	  tProps.fExpTime     = m_poRotation->fGetExposureTime();
	}
      _cUIimageviewprops->vSetValues(tProps);
    }
}


void
MainWindow::vUpdateReflnViewPropsDialog(void)
{
  tagReflnProps tProps;

  tProps.a6fReflnSize[0] = m_tReflnProps.a6fReflnSize[0];
  tProps.a6fReflnSize[1] = m_tReflnProps.a6fReflnSize[1];
  tProps.a6fReflnSize[2] = m_tReflnProps.a6fReflnSize[2];
  tProps.a6fReflnSize[3] = m_tReflnProps.a6fReflnSize[3];
  tProps.a6fReflnSize[4] = m_tReflnProps.a6fReflnSize[4];
  tProps.a6fReflnSize[5] = m_tReflnProps.a6fReflnSize[5];
  tProps.nReflnPredObs   = m_tReflnProps.nReflnPredObs;
  tProps.nReflnSymbol    = m_tReflnProps.nReflnSymbol;
  tProps.sReflnColor     = m_tReflnProps.sReflnColor;
  _cUIreflnviewprops->vSetValues(tProps, m_sReflnFilename, m_nReflnNum);
}

void
MainWindow::vNewImage(const int nUpdateScaling)
{
  // Display a newly created or read in image.
  
  // Fill the header view window with the header (probably do this only if
  // the header view window is managed.

  m_poXcursor->vSetWait();

  XmTextSetString(_tfViewHeader, m_poImage->m_oHeader.sGet().string());

  // Create a colormap with 128 entries with greyscale default if it does not
  // already exist.

  if (NULL == m_poColormap)
    {
      // Request 128 grey scale with a tolerance of 256

      m_poColormap = new CXcolormap ("mainCmap", _w, 128, 256);
      m_poColormap->vSetWindow(_daImageBig);
      m_poColormap->vSetWindow(_daImageSmall);
      
    }

  // Delete previous CXDisplay before creating new one

  if (NULL != m_poXdisplay)
    {
      delete m_poXdisplay;
      m_poXdisplay = NULL;
    }
  if (NULL != m_poXdisplay1)
    {
      delete m_poXdisplay1;
      m_poXdisplay1 = NULL;
    }

  if ( (NULL == m_poImage) || !m_poImage->bIsAvailable())
    {
      // Image was not read in properly or some other major error

      XtSetSensitive(_cbView, False);
      XtSetSensitive(_pbFilePrint, False);
      XtSetSensitive(_pbFileSaveAs, False);

      m_sTitle = "d*TREK display - Image unavailable";
      if (NULL != m_poImage)
	{
	  delete m_poImage;
	  m_poImage = NULL;
	}
    }
  else
    {
      // Be sure to force calculation of image average and sd for small image
      // then use that average and sd below for large image (GetImageProps
      // first!)

      Cstring sTemp;

      m_tImageProps.fSD = -1.0;
      vPutMessage("...computing average, sd,\n    min, max...");
      XmUpdateDisplay(_w);

      // Use display orientation from info in image header if available
//+2010-11-10 JWP
// Allow a simple environment variable to be set to F, false, FALSE, f, are something starting with f
// to make the view NOT cameraman view, but from crystal view.

      bool bNotCameramanView = FALSE;
      if ("" != sGetEnv("DTDISPLAY_CAMERAMAN_VIEW"))
	{
	  sTemp = sTransSymbol("$(DTDISPLAY_CAMERAMAN_VIEW)");
	  sTemp.upcase();
	  bNotCameramanView = ('F' == sTemp.GetAt(0));
	}
//-2010-11-10 JWP	  

      if (0 == m_poImage->m_oHeader.nGetValue(Cimage_header::ms_sDtdisplayOrientation,
					    &sTemp))
	{
	  if ("+X+Y" == sTemp)
	    {
	      m_tImageProps.nOrient = 0;
	      if (bNotCameramanView) m_tImageProps.nOrient = 2;
	    }
	  else if ("+X-Y" == sTemp)
	    {
	      m_tImageProps.nOrient = 1;
	      if (bNotCameramanView) m_tImageProps.nOrient = 3;
	    }
	  else if ("-X+Y" == sTemp)
	    {
	      m_tImageProps.nOrient = 2;
	      if (bNotCameramanView) m_tImageProps.nOrient = 0;
	    }
	  else if ("-X-Y" == sTemp)
	    {
	      m_tImageProps.nOrient = 3;
	      if (bNotCameramanView) m_tImageProps.nOrient = 1;
	    }
	  else if ("+Y+X" == sTemp)
	    {
	      m_tImageProps.nOrient = 4;
	      if (bNotCameramanView) m_tImageProps.nOrient = 6;
	    }
	  else if ("+Y-X" == sTemp)
	    {
	      m_tImageProps.nOrient = 5;
	      if (bNotCameramanView) m_tImageProps.nOrient = 7;
	    }
	  else if ("-Y+X" == sTemp)
	    {
	      m_tImageProps.nOrient = 6;
	      if (bNotCameramanView) m_tImageProps.nOrient = 4;
	    }
	  else if ("-Y-X" == sTemp)
	    {
	      m_tImageProps.nOrient = 7;
	      if (bNotCameramanView) m_tImageProps.nOrient = 5;
	    }
	}
	  
      // Read rotation information from the header

      if (NULL != m_poRotation)
	delete m_poRotation;

      m_poRotation = new Crotation (m_poImage->m_oHeader);

      // Fill rotation start and end text fields

      char cString[30];
      m_tReflnProps.fImageRotStart = m_poRotation->fGetRotStart();
      m_tReflnProps.fImageRotEnd   = m_poRotation->fGetRotEnd();

      sprintf (cString, "%.3f", m_poRotation->fGetRotStart());
      XmTextSetString(_tfRotStart, cString);
      sprintf (cString, "%.3f", m_poRotation->fGetRotEnd());
      XmTextSetString(_tfRotEnd, cString);
      
      m_poXdisplay1 = new CXdisplay (m_sFilename.string(), _daImageSmall, 
				     m_poImage, m_poColormap,
				     &m_tImageProps, &m_tReflnProps);
      vPutMessage("done.\n");

      // Get crystal goniometer angles from header 

      if (0 == m_poImage->m_oHeader.nGetValue(
			D_K_CrystalPrefix D_K_GonioValues, &sTemp))
	{
	  sprintf(m_a255cText, "Crystal gonio angles:\n%s\n",
		  sTemp.string());
	  vPutMessage(m_a255cText);
	}

      XmUpdateDisplay(_w);
      (void) m_poXdisplay1->nGetImageProps(&m_tImageProps);


      m_poXdisplay = new CXdisplay (m_sFilename.string(), _daImageBig, 
				    m_poImage, m_poColormap,
				    &m_tImageProps, &m_tReflnProps);
      m_poXdisplay->m_pObj = this;
      m_poXdisplay->m_prvRubberbandCallback = MainWindow::vRubberbandCBCallback;

      m_sTitle = "d*TREK: dtdisplay - Image filename: " + m_sFilename;

      XtSetSensitive(_cbView, True);
      XtSetSensitive(_pbFilePrint, True);
      XtSetSensitive(_pbFileSaveAs, True);

      nNewHeader(m_poImage->m_oHeader);

      // Many of the image properties are kept from the previous image
      // display if there was one.

      int nChanged = 0;
      m_tImagePropsInit.nOrient      = m_tImageProps.nOrient;
      m_tImagePropsInit.sSatPixColor = m_tImageProps.sSatPixColor;
      m_tImagePropsInit.fSatPixValue = m_tImageProps.fSatPixValue;
      m_tImagePropsInit.sTooLowPixColor = m_tImageProps.sTooLowPixColor;
      m_tImagePropsInit.fTooLowPixValue = m_tImageProps.fTooLowPixValue;
      m_tImagePropsInit.fBorder      = m_tImageProps.fZoom;
      m_poXdisplay->nGetImageProps(&m_tImageProps);
      if (0 > m_tImageProps.nOrient)
	{
	  nChanged++;
	  m_tImageProps.nOrient = m_tImagePropsInit.nOrient;
	}
      if ("RED" == m_tImageProps.sSatPixColor)
	{
	  nChanged++;
	  m_tImageProps.sSatPixColor = m_tImagePropsInit.sSatPixColor;
	}
      if (   (m_poImage->fGetSatValue() == m_tImageProps.fSatPixValue)
	  && (m_poImage->fGetSatValue() != m_tImagePropsInit.fSatPixValue) )
	{
	  nChanged++;
	  m_tImageProps.fSatPixValue = m_tImagePropsInit.fSatPixValue;
	}
      if (   (0.9 == m_tImageProps.fZoom) 
	  && (0.9 != m_tImagePropsInit.fBorder) )
	{
	  nChanged++;
	  m_tImageProps.fZoom = m_tImagePropsInit.fBorder;
	}

      if (XmToggleButtonGetState(_tbViewReso))
	{
	  nChanged++;
	}

      if (0 != nChanged)
	{
	  m_poXdisplay->nSetImageProps(&m_tImageProps);
	  m_poXdisplay1->nSetImageProps(&m_tImageProps);
	}

      m_poXdisplay1->vSetZoom(1.0);

      // Make sure the dialog box has the correct values

      vUpdateImageViewPropsDialog();
    }

  //+JWP 2012-09-27
  // Figure out if title string will fit on window.  If it won't fit,
  // then modify it 
  Cstring sTitleTemp = m_sTitle;
  vMakeTitleStringFitWindow(_MainWindow, m_sTitle, &sTitleTemp);
  //cout << "6 In: " << m_sTitle << "  Out: " << sTitleTemp << endl;
  XtVaSetValues(XtParent(_w), XmNtitle, sTitleTemp.string(), NULL);
  //XtVaSetValues(XtParent(_w), XmNtitle, m_sTitle.string(), NULL);
  //-JWP 2012-09-27
  m_poXcursor->vReset();
}

void
MainWindow::vUpdateText(void)
{

  // Update the text widget in the form along left side

  char cString[30];

  if (NULL != m_poRotation)
    {
      // Rot start

      sprintf (cString, "%.3f", m_poRotation->fGetRotStart());
      XmTextSetString(_tfRotStart, cString);

      // Rot end

      sprintf (cString, "%.3f", m_poRotation->fGetRotEnd());
      XmTextSetString(_tfRotEnd, cString);
    }

  // Det dist

  sprintf (cString, "%.2f", m_fDetDist);
  XmTextSetString(_tfDetDist, cString);

  // Det swing

  sprintf (cString, "%.2f", m_fDetSwing);
  XmTextSetString(_tfDetSwing, cString);

  // Wavelength

  sprintf (cString, "%.5f", m_fWavelength);
  XmTextSetString(_tfWavelength, cString);

}

void
MainWindow::vIntegrate2D(const float fReso)
{
  // Integrate the spot found at the pixel coordinate m_dCurrPoint

  int   i;
  int   nStat;
  float fAvg, fSD;
  float a3fCentroid[3];
  float a3fSize[3];
  float fInt, fSigmaI;
  int   a3nOrig[2];
  int   a3nExt[2];

  // Create an object that can do the calculation

  if (m_tImageProps.nIntegrateBox[0] < 2)
    m_tImageProps.nIntegrateBox[0] = 24;
  if (m_tImageProps.nIntegrateBox[1] < 2)
    m_tImageProps.nIntegrateBox[1] = 24;

  for (i = 0; i < 2; i++)
    {
      a3nOrig[i] = (int) m_dCurrPoint[i] - m_tImageProps.nIntegrateBox[i]/2;
      a3nOrig[i] = max(0, a3nOrig[i]);
      a3nExt[i]  = (int) m_dCurrPoint[i] + m_tImageProps.nIntegrateBox[i]/2;
      a3nExt[i]  = min(m_tImageProps.nDim[i]-1, a3nExt[i]);
      a3nExt[i]  = max(1, a3nExt[i] - a3nOrig[i] + 1);
    }
  
  C3Ddata o3Ddata(a3nExt[0], a3nExt[1], 1, a3nOrig[0], a3nOrig[1], 0);

  // Get a layer of pixels

  nStat = o3Ddata.nFill2D(m_poImage, 0);
  fAvg = -10000.0;
  if (0 == nStat)
    {
      // Compute try to integrate and background average and sd
      // We should try to do non-uniformity correction here if available!

      if (NULL != m_poDetector)
	{
	  if (m_poDetector->m_poNonunf->bIsAvailable())
	    {
	      m_poDetector->m_poNonunf->nCorrect3Ddata(&o3Ddata);
	    }
	}
      a3fCentroid[0] = m_dCurrPoint[0] - (float) o3Ddata.nGetOffset(0);
      a3fCentroid[1] = m_dCurrPoint[1] - (float) o3Ddata.nGetOffset(1);
      //+19-Apr-2001      a3fCentroid[2] = 0.0;
      a3fCentroid[2] = 0.5;
      //-19-Apr-2001
      nStat = o3Ddata.nCalcGetPeakInfo(a3fCentroid, &fInt, &fSigmaI, 
				       &fAvg, &fSD, a3fSize);
      // Mask out onedge2 errors
#ifndef USE_OLD_ERROR_BITS
      nStat = nStat & ~(  (1 << Crefln::ms_nErrorOnEdge2)
                        | (1 << Crefln::ms_nErrorOffEdge2)
		       );
#else
      nStat = nStat & ~(1 << C3Ddata::ms_nErrorOnEdge2);
#endif
    }
  if ( (-999.0 != fInt)  && (0.0 < fSigmaI) )
    {
      if (0 == nStat)
	{
	  // Spot centroid was successfully found
/*
	  cout << "about to vSetSpotInfo with: "
               << "\nint " << fInt
               << "\nsig " << fSigmaI
	       << "\ncent: " << a3fCentroid[0] << ", " << a3fCentroid[1] << ", "
                             << a3fCentroid[2] << endl << flush;
*/
	  float fRotInc = m_tReflnProps.fImageRotEnd - m_tReflnProps.fImageRotStart;

	  m_poXdisplay->vSetSpotInfo(fInt, fSigmaI, fReso,
				     a3fCentroid[0] + (float) o3Ddata.nGetOffset(0), 
				     a3fCentroid[1] + (float) o3Ddata.nGetOffset(1),
				     (m_tReflnProps.fImageRotEnd + m_tReflnProps.fImageRotStart) * 0.5,
// Rotmid point is the center of the displayed image as shown in the
// tfRotStart and tfRotEnd				     
//				     (a3fCentroid[2] * fRotInc)
//				       + m_tReflnProps.fImageRotStart,
//		     -999.000f);  // We don't know Rot width, set it
				     m_tReflnProps.fImageRotEnd - m_tReflnProps.fImageRotStart);
	                          // We don't know Rot width, set it equal to image width
	}

      // Print out results
      sprintf (m_a255cText,
	       "Intensity: %11.0f (%7.0f)\n"
	       "Int/SigI: %8.1f\n"
//	       "SigmaI:    %11.0f\n"
	       "Size: %3.0f by %3.0f\n", fInt, fSigmaI, fInt / fSigmaI,
	       a3fSize[0], a3fSize[1]);
    }
  else
    {
      sprintf(m_a255cText, "Error getting peak info.\n");
    }
  vPutMessage(m_a255cText);
  if (-999.0 != fAvg)
    {
      // An average was successfully calculated, so display it

      sprintf (m_a255cText,
	       "Backgrnd: %10.0f (%5.0f)\n",
//	       "Back. sd.: %12.0f\n", 
	       fAvg, fSD);
    }
  else
    {
      // Print error message
      sprintf(m_a255cText, "Background error.\n");
    }
  vPutMessage(m_a255cText);
}


void
MainWindow::vOverlay(void)
{
  // Overlay a series of images.  Keep the largest value in all the
  // the images for each pixel.

  int nStat;

  if ( (NULL != m_poScan) && (NULL != m_poXdisplay) )
    {
      sprintf(m_a255cText, "Overlaying a series of %d images",
	      m_poScan->m_nNumImages);	      
      m_nProgressCancel = 0;
      XtManageChild(_mbProgress);
      m_poXcursor->vSetWait();
      Boolean  argok=False;  
      XmString xsProgress;
      xsProgress = (XmString)BX_CONVERT(_mbProgress, m_a255cText, XmRXmString, 0, &argok);
      XtVaSetValues(_mbProgress, XmNmessageString, xsProgress, NULL);
      XmStringFree(xsProgress);
      XtVaSetValues(_scProgress, XmNminimum, 0, XmNmaximum, 
		    12 * m_poScan->m_nNumImages / 10, NULL);
      nStat = m_poScan->nOverlay(m_poImage, m_poScan->m_nNumImages, 
				 MainWindow::vProgressCBCallback, (void *)this);
      if (0 != nStat)
	{
	  vPostError(_mbError,
		     (XtPointer)"FileNewOverlayError$$Error during overlay.", 
		     NULL);
	}
      m_sTitle = "d*TREK: dtdisplay - Overlayed Image";
      m_poXcursor->vReset();
      XtUnmanageChild(_mbProgress);
      vViewRefresh(_w, NULL, NULL);
    }
  else
    {
      // Post an error message
      vPostError(_mbError,
		 (XtPointer)"FileNewOverlay$$Error during overlay: First display an image, then overlay", NULL);
    }
}

void
MainWindow::vUnderlay(void)
{
  // Underlay a series of images.  Keep the smallest value in all the
  // the images for each pixel.

  int nStat;

  if ( (NULL != m_poScan) && (NULL != m_poXdisplay) )
    {
      sprintf(m_a255cText, "Underlaying a series of %d images",
	      m_poScan->m_nNumImages);	      
      m_nProgressCancel = 0;
      XtManageChild(_mbProgress);
      m_poXcursor->vSetWait();
      Boolean  argok=False;  
      XmString xsProgress;
      xsProgress = (XmString)BX_CONVERT(_mbProgress, m_a255cText, XmRXmString, 0, &argok);
      XtVaSetValues(_mbProgress, XmNmessageString, xsProgress, NULL);
      XmStringFree(xsProgress);
      XtVaSetValues(_scProgress, XmNminimum, 0, XmNmaximum, 
		    12 * m_poScan->m_nNumImages / 10, NULL);
      nStat = m_poScan->nUnderlay(m_poImage, m_poScan->m_nNumImages,
				  MainWindow::vProgressCBCallback, (void *)this);
      if (0 != nStat)
	{
	  vPostError(_mbError,
		     (XtPointer)"FileNewUnderlayError$$Error during underlay.", NULL);
	}

      m_sTitle = "d*TREK:display - Underlayed Image";
      m_poXcursor->vReset();
      XtUnmanageChild(_mbProgress);
      vViewRefresh(_w, NULL, NULL);
    }
  else
    {
      // Post an error message
      vPostError(_mbError,
		 (XtPointer)"FileNewUnderlay$$Error during underlay: First display an image, then underlay", NULL);
    }
}

void
MainWindow::vTile(void)
{
  int nStat;
  if ( (NULL != m_poImage) && (NULL != m_poScan) )
    {
      sprintf(m_a255cText, "Tiling a series of %d images",
	      m_poScan->m_nNumImages);	      
      m_nProgressCancel = 0;
      XtManageChild(_mbProgress);
      m_poXcursor->vSetWait();
      Boolean  argok=False;  
      XmString xsProgress;
      xsProgress = (XmString)BX_CONVERT(_mbProgress, m_a255cText, XmRXmString, 0, &argok);
      XtVaSetValues(_mbProgress, XmNmessageString, xsProgress, NULL);
      XmStringFree(xsProgress);
      XtVaSetValues(_scProgress, XmNminimum, 0, XmNmaximum, 
		    12 * m_poScan->m_nNumImages / 10, NULL);
      nStat = m_poScan->nTile(m_poImage, m_poScan->m_nNumImages,
			      MainWindow::vProgressCBCallback, (void *)this);
      if (0 != nStat)
	{
	  vPostError(_mbError,
		     (XtPointer)"FileNewTileError$$Error during tile.", NULL);
	}

      m_tImageProps.nPlotRockingCurve = m_poScan->m_nNumImages;
      // Do not plot reflnlist and do not plot reso circles
      m_tImageProps.nDisplayReflns    = 0;
      m_tImageProps.nResoCircles      = -1;
      m_poXdisplay->nSetImageProps(&m_tImageProps);

      m_sTitle = "d*TREK:display - Tiled Image";
      XtUnmanageChild(_mbProgress);
      vViewRefresh(_w, NULL, NULL);
      m_poXcursor->vReset();
    }
  else
    {
      // Post an error message
      vPostError(_mbError,
		 (XtPointer)"FileNewTile$$Error during tile: First display an image, then tile.", NULL);
    }
}

void
MainWindow::vAverage(void)
{

  // Compute average and SD of a series of images.
  // Write results to avg.img and sd.img

  int nStat;

  if ( (NULL != m_poScan) && (NULL != m_poXdisplay) )
    {
      sprintf(m_a255cText, "Averaging a series of %d images",
	      m_poScan->m_nNumImages);	      
      m_nProgressCancel = 0;
      XtManageChild(_mbProgress);
      m_poXcursor->vSetWait();
      Boolean  argok=False;  
      XmString xsProgress;
      xsProgress = (XmString)BX_CONVERT(_mbProgress, m_a255cText, XmRXmString, 0, &argok);
      XtVaSetValues(_mbProgress, XmNmessageString, xsProgress, NULL);
      XmStringFree(xsProgress);
      XtVaSetValues(_scProgress, XmNminimum, 0, XmNmaximum, 
		    12 * m_poScan->m_nNumImages / 10, NULL);
      nStat = m_poScan->nAvgSD(m_poImage, m_poScan->m_nNumImages,
			 MainWindow::vProgressCBCallback, (void *)this);
      if (0 != nStat)
	{
	  vPostError(_mbError,
		 (XtPointer)"FileNewAverageError$$Error during average.", NULL);
	}
      m_sTitle = "d*TREK:display - Averaged Image";
      m_poXcursor->vReset();
      XtUnmanageChild(_mbProgress);
      vViewRefresh(_w, NULL, NULL);
    }
  else
    {
      // Post an error message
      vPostError(_mbError,
		 (XtPointer)"FileNewAverage$$Error during average: First display an image, then average", NULL);
    }
}

void
MainWindow::vMovie(void)
{
  int nStat;
  if ( (NULL != m_poImage) && (NULL != m_poScan) )
    {
      sprintf(m_a255cText, "Movie of a series of %d images",
	      m_poScan->m_nNumImages);	      
      m_nProgressCancel = 0;
      XtManageChild(_mbProgress);
      m_poXcursor->vSetWait();
      Boolean  argok=False;  
      XmString xsProgress;
      xsProgress = (XmString)BX_CONVERT(_mbProgress, m_a255cText, XmRXmString, 0, &argok);
      XtVaSetValues(_mbProgress, XmNmessageString, xsProgress, NULL);
      XmStringFree(xsProgress);
      XtVaSetValues(_scProgress, XmNminimum, 0, XmNmaximum, 
		    12 * m_poScan->m_nNumImages / 10, NULL);

      Cstring sName;
      int i, nProgress;
      int nMoviePause = 1;

      nStat = 1;
      m_poXdisplay->nSetImageProps(&m_tImageProps);
      while (1 == nStat)
	{
	  m_poScan->nGetImage(m_poImage);   // Get the first image
	  if (!m_poImage->bIsAvailable())   // If error getting image, return
	    {
	      nStat = -2;
	      break;
	    }

	  m_poScan->vInitSeqNum();          // Initialize to first sequence
	  m_poScan->nGetImageName(&sName);
	  m_sTitle = "d*TREK:display - Movie Images: " + sName;
	  vViewRefresh(_w, NULL, NULL);	  

	  for (i = 1; i < m_poScan->m_nNumImages; i++)
	    {
	      nProgress = i;

	      // vProgressCB... calls XmUpdateDisplay()

	      vProgressCBCallback((void* )this, &nProgress);
	      if ( (nProgress != i) || (0 != m_nProgressCancel) )
		{
		  vPutMessage(Cstring("Movie cancel!\n"));
		  nStat = 0;
		  break;
		}
	      //	      sleep (nMoviePause);
	      m_poScan->vNextSeqNum();
	      m_poScan->nGetImage(m_poImage);  // Get next image
	      if (!m_poImage->bIsAvailable())
		{
		  nStat = -2;
		  break;                       // Break on error getting image
		}
	      m_poScan->nGetImageName(&sName);
	      m_sTitle = "d*TREK:display - Movie Images: " + sName;
  
	      if (NULL != m_poRotation)
		{
		  delete m_poRotation;
		}
	      m_poRotation = new Crotation (m_poImage->m_oHeader);
	      m_tReflnProps.fImageRotStart = m_poRotation->fGetRotStart();
	      m_tReflnProps.fImageRotEnd   = m_poRotation->fGetRotEnd();
	      vUpdateText();
	      vViewRefresh(_w, NULL, NULL);	  
	    } // end of for ...
	  // sleep (2 * nMoviePause);
	} // end of while ...

      if (0 != nStat)
	{
	  vPostError(_mbError,
		     (XtPointer)"FileNewTileError$$Error during movie.", NULL);
	}

      XtUnmanageChild(_mbProgress);
      vViewRefresh(_w, NULL, NULL);
      m_poXcursor->vReset();
    }
  else
    {
      // Post an error message
      vPostError(_mbError,
		 (XtPointer)"FileNewTile$$Error during tile: First display an image, then tile.", NULL);
    }
}

void
MainWindow::vPostError(Widget w, XtPointer clientData, XtPointer callData)
{
  // Post the message found in clientData to the widget w.
  // Widget w must be a messageBox widget

  if (XmIsMessageBox(w))
    {
      Cstring sMessage = (char *)clientData;
      Cstring sTemp;
      static Cstring ssSeparator = "$$";
      Boolean bTemp;
      if (sMessage.contains(ssSeparator))
	{
	  // Use the string before the separator as a resource and lookup
	  // what the error message translation should be.
	  sTemp = sMessage.before(ssSeparator);
	  String pcText;
	  String pcProgname;
	  XtGetApplicationNameAndClass(XtDisplay(w), &pcProgname, &pcText);
	  pcText = XGetDefault(XtDisplay(w), pcProgname,
			       ("error" + sTemp).string());
	  if (NULL != pcText)
	    {
	      // Ok, found a translation, so use it
	      sMessage = pcText;
	    }
	  else
	    {
	      // Did not find a translation so use the string after 
	      // the separator if it exists, otherwise use the input string

	      sTemp = sMessage.after(ssSeparator);
	      if (sTemp != "")
		sMessage = sTemp;
	      else 
		sMessage = sMessage.before(ssSeparator);
	    }
	}
      
      // Set the messageString in the error dialog box to sMessage

      XmString xsMessage;
      xsMessage = (XmString)BX_CONVERT(w, sMessage.string(), XmRXmString, 0, &bTemp);
      XtVaSetValues(w, XmNmessageString, xsMessage, NULL);
      XmStringFree(xsMessage);
      XtManageChild(w);
    }
}

void
MainWindow::vLoadImageFile(const char *pcName)
{
  // Read in an image file from disk.  The name of the file is found
  // in *pcName if not NULL, or in the member variable m_sFilename if
  // pcName == NULL.

  m_poXcursor->vSetWait();

  // We need to delete any display objects before deleting the image
  // since any display refresh will fail if there is not an image to go with
  // it

  if (NULL != m_poXdisplay1) 
    {
      delete m_poXdisplay1;
      m_poXdisplay1 = NULL;
    }
  if (NULL != m_poXdisplay)
    {
      delete m_poXdisplay;
      m_poXdisplay = NULL;
    }
  if (NULL != m_poImage)
    {
      delete m_poImage;
      m_poImage = NULL;
    }
  
  // If the input string is not null, then copy it to m_sFilename.
  // Otherwise just use m_sFilename for the image filename.

  if (NULL != pcName)
    m_sFilename = pcName;

  vPutMessage("...reading image file...");
  XmUpdateDisplay(_w);

  m_poImage = new Cimage (m_sFilename);
  if (m_poImage->bIsAvailable())
    {
      m_tImageProps.fSatPixValue = m_poImage->fGetSatValue();
      vPutMessage("done.\n");
    }
  else
    {
      vPutMessage("\nERROR getting image: " + m_sFilename + "\n", 1);
    }
  XmUpdateDisplay(_w);
  if (NULL != m_poScan)
    {
      delete m_poScan;
      m_poScan = NULL;
    }

  if (NULL != m_poRotation)
    {
      delete m_poRotation;
      m_poRotation = NULL;
    }

  if (m_poImage->bIsAvailable())
    {
      m_poScan     = new Cscan(m_poImage->m_oHeader);
      if (m_poScan->bIsAvailable())
	{
	  XtSetSensitive(_pbImagePrev, True);
	  XtSetSensitive(_pbImageNext, True);
	  XtSetSensitive(_tfImageNum,  True);
	  XtSetSensitive(_lbImageNum,  True);
	}
      else
	{
	  XtSetSensitive(_pbImagePrev, False);
	  XtSetSensitive(_pbImageNext, False);
	  XtSetSensitive(_tfImageNum, False);
	  XtSetSensitive(_lbImageNum, False);
	}
    }
  else
    {
      // Create empty default scan object

      m_poScan     = new Cscan();
    }
  m_poXcursor->vReset();
}

void
MainWindow::vPropNotifyCBCallback(Widget w, XtPointer clientData, 
				  XEvent* pEvent, Boolean *pBool)
{
    MainWindow *obj = (MainWindow *)clientData;
    obj->vPropNotifyCB(w, clientData, pEvent, pBool);
}

void
MainWindow::vPropNotifyCB(Widget w, XtPointer clientData, 
			  XEvent* pEvent, Boolean *pBool)
{
  // This routine is called when a property has been modified on the
  // mainWindow widget and we have "Respond to Updates" (aka _tbFileListen)
  // set to true.  This usually means an image or reflnlist update from an
  // external process.
    
  //  cout << "vPropNotifyCB called.\n";
  XPropertyEvent *pPropEvent = (XPropertyEvent *)pEvent;

  Cstring       sTemp;
  Cstring       sReflnlist;
  Cstring       sFilename;
  Cstring       sTemplate;
  int           nStat;
  bool          bStateCollect;
  bool          bStateIntegrate;
  bool          bStateOther;
  bool          bNewReflnlist;

  bStateOther     = XmToggleButtonGetState(_tbFileListenOther);
  bStateCollect   = XmToggleButtonGetState(_tbFileListenCollect);
  bStateIntegrate = XmToggleButtonGetState(_tbFileListenIntegrate);
  bNewReflnlist = FALSE;

  if (pPropEvent->atom == m_hAtomImageUpdate)
    {
      if (PropertyNewValue == pPropEvent->state)
	{
          nStat = m_poXprop->nGetProperty(ms_sAtomNameImageUpdate, &sTemp);

//+2012-12-13
          //vPutMessage(Cstring("@@") + sTemp + + "@@\n", 1);
// New idea: Modify sTemp if coming from HKL3000R
          if ("" != sGetEnv("DTDISPLAY_HKL3000R"))
            {
              if (0 > sTemp.find(" Seq: "))
                {
                  // No Seq: string found, ...
                  if (NULL != m_poScan)
                    {
                      // ... but the scan exists, so use it ...
                      Cstring sTempFile;
                      int     nSeqNum = 0; 
                      // Figure out sequence number of the file named by sTemp
                      //sTempFile = m_poScan->sGetTemplate();
                      sTempFile = sBuildScanTemplate(sTemp, 4, &nSeqNum);
                      sTemp = sTemp + " Template: " + sTempFile + " Seq: " + Cstring(nSeqNum);
                      //vPutMessage(Cstring("@@") + sTemp + + "@@\n", 1);
                    }
                }
            }
//-2012-12-13
	  if ( (0 == nStat) && ("No image property." != sTemp) )
	    {
//	      cout << "IMAGE UPDATE: >>" << sTemp << "<<\n" << flush;
	      nStat = sTemp.find("//dtcollect//");
	      if (   ( (0 <= nStat) && (!bStateCollect) )
		  || ( (0 >  nStat) && (!bStateOther && !bStateIntegrate) ) )
		{
		  // Update is from dtcollect, but dtcollect tog button NOT set
		  // OR update is NOT from dtcollect and dtintegrate &
		  // OTHER tb's NOT set
      
		  return;
		}

	      nStat = sTemp.find("//dtintegrate//");
	      if (   ( (0 <= nStat) && (!bStateIntegrate) )
		  || ( (0 >  nStat) && (!bStateOther && !bStateCollect) ) )
		{
		  // Update is from dtintegrate, but dtintegrate tb NOT set
		  // OR update is NOT from dtintegrate and dtcollect &
		  // OTHER tb NOT set
      
		  return;
		}

	      // Try to prevent another event from being queued 
	      // while we are in here (must be called AFTER m_poXprop->nGet...

	      XmToggleButtonSetState(_tbFileListenOther, False, True);
	      XmToggleButtonSetState(_tbFileListenCollect, False, True);
	      XmToggleButtonSetState(_tbFileListenIntegrate, False, True);

//	      cout << "Image file new update:\n";
//	      cout << sTemp << endl;

	      // Look for reflnlist name at the end, too:
	      
	      if (0 <= sTemp.find(" Reflnlist:"))
		{
		  sReflnlist = sTemp.after(" Reflnlist:");

		  // Strip off any leading white-space

		  while (' ' == sReflnlist.GetAt(0))
		    sReflnlist = sReflnlist.after(0);

		  // Go up to first blank or eos

		  sReflnlist = sReflnlist.before(' ');

		  vPutMessage(Cstring("Refln update:\n") + sReflnlist + '\n');
		  bNewReflnlist = TRUE;
		}

	      if (0 <= sTemp.find(" New!"))
		{
		  // A new filename enter, along with a new template
		  
		  sFilename = sTemp.before(" ");
		  vLoadImageFile(sFilename.string());
		  vNewImage();

		  if (sTemp.contains(" Template: "))
		    {
		      sTemplate = sTemp.after(" Template: ");
		      sTemplate = sTemplate.before(" New!");

		      m_poScan->vSetTemplate(sTemplate);
		    }
		  if (bNewReflnlist)
		    {
		      m_nReflnFileMode = 0;
		      vReflnFileCB(NULL, sReflnlist, 0);
		    }
		}
              else if (0 <= sTemp.find(" Seq: "))
                {
                  //+2012-11-30 JWP Modify this block of code a little bit 

                  sFilename = sTemp.before(" Template: ");
                  sTemplate = sTemp.after(" Template: ");
                  sTemplate = sTemplate.before(" Seq: ");
                  bool bNewImage = FALSE;
                  if (NULL == m_poScan)
                    {
                      // No scan available, so load image which creates m_poScan
                      vLoadImageFile(sFilename.string());
                      vNewImage();
                      bNewImage = TRUE;
                      m_poScan->vSetTemplate(sTemplate);
                    }
                  Cstring sScanTemplate;
                  sScanTemplate = m_poScan->sGetTemplate();
                  if (!sTemplate.contains('/'))
                    {
                      // If there is no slash in the template, 
                      // then there is probably no directory or path in the template,
                      // so assume the same directory or path as in the sScanTemplate.

                      sTemplate = sFileGetDirectory(sScanTemplate) + sTemplate;
                    }
                  if (m_poScan->sGetTemplate() != sTemplate)
                    {
                      // Template not the same, load image and make it 
                      // the same template
                          
                      vLoadImageFile(sFilename.string());
                      vNewImage();
                      bNewImage = TRUE;
                      m_poScan->vSetTemplate(sTemplate);
                    }
                  // TODO: Then if sequence is not same as the image, load image

                  // Template is now the same, 
                  // Should compare sequence number in image and after Seq:, if the same
                  // AND !bNewImage, do not call vFileTemplateCB(...)

                  XmTextSetString(_tfImageNum, (sTemp.after(" Seq: ")).string()); // Places image number in _tfImageNum
                  vFileTemplateCB(_tfImageNum, NULL, NULL); // This loads/displays image, requires legit m_poScan,

                  //-2012-11-30 JWP End: Modify this block of code a little bit 
                }
	      else if (0 <= sTemp.find("next"))
		{
		  vPutMessage(Cstring("next found:\n") + sReflnlist + '\n', 1);
//		  vFileTemplateCB(_pbImageNext, NULL, NULL);
		}
	      else if (0 <= sTemp.find("prev"))
		{
		  vPutMessage(Cstring("prev found:\n") + sReflnlist + '\n', 1);
//		  vFileTemplateCB(_pbImagePrev, NULL, NULL);
		}
	      else
		{
		  // A simple image filename was entered

		  sFilename = sTemp;
		  if (sFilename.contains(' '))
		    sFilename = sFilename.before(' ');

		  vLoadImageFile(sFilename.string());
		  vNewImage();

		  //XmTextSetString(_tfImageNum, sTemp.string());
		  //vFileTemplateCB(_tfImageNum, NULL, NULL);
		}

	      // Look for a header update with an image update

	      if (sTemp.contains(" Header:"))
		{
		  Cstring sHeader;
		  sHeader = sTemp.after(" Header:");

		  // Strip off any leading white-space

		  while (' ' == sHeader.GetAt(0))
		    sHeader = sHeader.after(0);

		  // Go up to first blank or eos

		  sHeader = sHeader.before(' ');

		  vPutMessage(Cstring("Header update:\n") + sHeader + '\n');
		  nNewHeader(sHeader, (bool)FALSE);
		}

	      if (bNewReflnlist)
		{
		  m_nReflnFileMode = 0;
		  vReflnFileCB(NULL, sReflnlist, 0);
		}

	      // Restore listen mode

	      XmToggleButtonSetState(_tbFileListenOther, bStateOther, True);
	      XmToggleButtonSetState(_tbFileListenCollect, bStateCollect, True);
	      XmToggleButtonSetState(_tbFileListenIntegrate, bStateIntegrate, True);
	    }
	}
      else if (PropertyDelete == pPropEvent->state)
	{
	  vPostError(_mbError, (XtPointer)"PropDelete$$Property deleted!", NULL);
	}
    }
  else if (pPropEvent->atom == m_hAtomReflnUpdate)
    {
      if (PropertyNewValue == pPropEvent->state)
	{
	  nStat = m_poXprop->nGetProperty(ms_sAtomNameReflnUpdate, &sTemp);
	  if ( (0 == nStat) && ("No refln property." != sTemp) )
	    {
//	      cout << "REFLN UPDATE: >>" << sTemp << "<<\n" << flush;

	      // Try to prevent another event from being queued 
	      // while we are in here (must be called AFTER m_poXprop->nGet...

	      XmToggleButtonSetState(_tbFileListenOther, False, True);
	      XmToggleButtonSetState(_tbFileListenCollect, False, True);
	      XmToggleButtonSetState(_tbFileListenIntegrate, False, True);

	      // In reality, dtcollect probably will not send a reflnlist update

	      nStat = sTemp.find("//dtcollect//");
	      if (   ( (0 <= nStat) && (!bStateCollect) )
		  || ( (0 >  nStat) && (!bStateOther) ) )
		{
		  // Update is from dtcollect, but dtcollect tog button NOT set
		  // OR update is NOT from dtcollect and OTHER tb NOT set
      
		  return;
		}

//	      cout << "Refln update:\n";
//	      cout << sTemp << endl;
	      
	      if (0 <= sTemp.find(" Header:"))
		{
		  Cstring sHeader;
		  sHeader = sTemp.after(" Header:");

		  // Strip off any leading white-space

		  while (' ' == sHeader.GetAt(0))
		    sHeader = sHeader.after(0);

		  // Go up to first blank or eos

		  sHeader = sHeader.before(' ');

		  vPutMessage(Cstring("Header update:\n") + sHeader + '\n');
		  nNewHeader(sHeader, (bool)FALSE);
		}

	      // Strip off any leading white-space

	      while ( (' ' == sTemp.GetAt(0)) && (1 < sTemp.length()) )
		sTemp = sTemp.after(0);

	      // Go up to first blank or eos

	      sTemp = sTemp.before(' ');

	      if ( (0 < sTemp.length()) && ("Header:" != sTemp) )
		{
		  vPutMessage(Cstring("Refln update:\n") + sTemp + '\n');
		  m_nReflnFileMode = 0;
		  vReflnFileCB(NULL, sTemp, 0);
		}

	      // Restore listen mode

	      XmToggleButtonSetState(_tbFileListenOther, bStateOther, True);
	      XmToggleButtonSetState(_tbFileListenCollect, bStateCollect, True);
	      XmToggleButtonSetState(_tbFileListenIntegrate, bStateIntegrate, True);
	    }
	}
    }
  else if (pPropEvent->atom == m_hAtomBeamCenterUpdate)
    {
      if (PropertyNewValue == pPropEvent->state)
	{
	  nStat = m_poXprop->nGetProperty(ms_sAtomNameBeamCenterUpdate, &sTemp);

	  if ( (0 == nStat) && ("No beamcenter property." != sTemp) )
	    {
	      // std::cout << "BEAMCENTER UPDATE: >>" << sTemp << "<<\n" << std::flush;

	      // Parse the string and do something with it.
	      Cstring asBeamCenter[3];
	      nStat = split(sTemp, asBeamCenter, 3, " ");
	      if ( (3 == nStat) && (NULL != m_poDetector) )
		{
		  float fCent0 = atof(asBeamCenter[1]);
		  float fCent1 = atof(asBeamCenter[2]);
		  m_poDetector->m_poSpatial->nSetBeamPosition(fCent0, fCent1);
		  XmToggleButtonSetState(_tbViewReso, True, False);
		  m_poXdisplay->vSetResol(m_poDetector, m_fS0, m_fWavelength, 5);
		  m_poXdisplay->vRefresh();
		  m_poDetector->m_poSpatial->nUpdateHeader(m_poHeader, "");
		  vPutMessage ("Direct beam position changed!\n"
			       "Don't forget File/Save Header ...", 1);
		}
	    }
	}
    }
  else
    {
      vPostError(_mbError, (XtPointer)"Unknown property!", NULL);
    }
}

void
MainWindow::vDestroy(void)
{
//  cout << "MainWindow::vDestroy called!!\n";

  if (NULL != m_po3Ddata)
    {
      delete m_po3Ddata;
      m_po3Ddata = NULL;
    }
  if (NULL != m_poXdisplay)
    {
      delete m_poXdisplay;
      m_poXdisplay = NULL;
    }
  if (NULL != m_poXdisplay1)
    {
      delete m_poXdisplay1;
      m_poXdisplay1 = NULL;
    }
  if (NULL != m_poDetector)
    {
      delete m_poDetector;
      m_poDetector = NULL;
    }
  if (NULL != m_poSource)
    {
      delete m_poSource;
      m_poSource = NULL;
    }
  if (NULL != m_poImage)
    {
      delete m_poImage;
      m_poImage = NULL;
    }
  if (NULL != m_poScan)
    {
      delete m_poScan;
      m_poScan = NULL;
    }
  if (NULL != m_poReflnlist)
    {
      delete m_poReflnlist;
      m_poReflnlist = NULL;
    }
  if (NULL != m_poColormap)
    {
      delete m_poColormap;
      m_poColormap = NULL;
    }
  if (NULL != m_poXhelp)
    {
      delete m_poXhelp;
      m_poXhelp = NULL;
    }
  if (NULL != m_poXcursor)
    {
      delete m_poXcursor;
      m_poXcursor = NULL;
    }

  // Stop the listen for updates event handler which deletes properties

  XmToggleButtonSetState(_tbFileListenOther, False, True);
  XmToggleButtonSetState(_tbFileListenCollect, False, True);
  XmToggleButtonSetState(_tbFileListenIntegrate, False, True);

  if (NULL != m_poXprop)
    {
      delete m_poXprop;   // This deletes properties, too
      m_poXprop = NULL;
    }
}

void
MainWindow::vPrintCBCallback(XtPointer pObj, const Cstring& sFilename, 
			     const Cstring& sComment, const Boolean& rbPrintName)
{
  MainWindow *obj = (MainWindow *)pObj;
  obj->vPrintCB(obj, sFilename, sComment, rbPrintName);
}

void
MainWindow::vPrintCB(XtPointer pObj, const Cstring& sFilename,
		     const Cstring& sComment, const Boolean& rbPrintName)
{
  //  cout << "vPrintCB called" << endl;

  int nStat;
  if (NULL != m_poXdisplay)
    {
      nStat = m_poXdisplay->nCreatePS(sFilename, sComment, rbPrintName);
      if (0 != nStat)
	{
	  vPostError(_mbError, (XtPointer)"PrintError$$Error creating PostScript file.", 0);
	}
    }
}

void
MainWindow::vImageViewPropsCBCallback(XtPointer pObj,     // Pointer to object 
			      const tagImageProps& tProps)
{
  MainWindow *obj = (MainWindow *)pObj;
  obj->vImageViewPropsCB(pObj, tProps);
}

void
MainWindow::vImageViewPropsCB(XtPointer pObj,             // Pointer to object 
			      const tagImageProps& tProps)
{
  if (NULL != m_poXdisplay)
    {
      // Transfer certain tProps to m_tImageProps

//      m_tImageProps.fRotStart        = tProps.fRotStart;
//      m_tImageProps.fRotEnd          = tProps.fRotEnd;
//      m_tImageProps.fExpTime         = tProps.fExpTime;
      m_tImageProps.fZoom            = tProps.fBorder;
      m_tImageProps.fScaleMin        = tProps.fScaleMin;
      m_tImageProps.fScaleMax        = tProps.fScaleMax;
      m_tImageProps.fImageMin        = tProps.fImageMin;
      m_tImageProps.fImageMax        = tProps.fImageMax;
      m_tImageProps.fAvg             = tProps.fAvg;
      m_tImageProps.fSD              = tProps.fSD;
      m_tImageProps.fAspectRatio     = tProps.fAspectRatio;
//      m_tImageProps.nDim[0]          = tProps.nDim[0];
//      m_tImageProps.nDim[1]          = tProps.nDim[1];
//      m_tImageProps.nOrig[0]         = tProps.nOrig[0];
//      m_tImageProps.nOrig[1]         = tProps.nOrig[1];
      m_tImageProps.nIntegrateBox[0] = tProps.nIntegrateBox[0];
      m_tImageProps.nIntegrateBox[1] = tProps.nIntegrateBox[1];
      m_tImageProps.nAutoRescale     = tProps.nAutoRescale;
      m_tImageProps.nOrient          = tProps.nOrient;
      m_tImageProps.nAspectMode      = tProps.nAspectMode;
//      m_tImageProps.nDisplayReflns   = tProps.nDisplayReflns;
//      m_tImageProps.nDisplayPixValues= tProps.nDisplayPixValues;
      m_tImageProps.fSatPixValue     = tProps.fSatPixValue;
      m_tImageProps.sSatPixColor     = tProps.sSatPixColor;
      m_tImageProps.fTooLowPixValue     = tProps.fTooLowPixValue;
      m_tImageProps.sTooLowPixColor     = tProps.sTooLowPixColor;

      m_poXdisplay->nSetImageProps(&m_tImageProps);
      if (NULL != m_poXdisplay1)
	m_poXdisplay1->nSetImageProps(&m_tImageProps);
    }
  if (1 == m_nEraseMode)
    m_poXcursor->vSetFont(XC_gumby, FALSE);
}

void
MainWindow::vReflnViewPropsCBCallback(XtPointer pObj,     // Pointer to object 
			      const tagReflnProps *ptProps)
{
  MainWindow *obj = (MainWindow *)pObj;
  obj->vReflnViewPropsCB(pObj, ptProps);
}

void
MainWindow::vReflnViewPropsCB(XtPointer pObj,             // Pointer to object 
			      const tagReflnProps *ptProps)
{
  if (NULL == ptProps)
    {
      // This means we need help

      vPopDialog(_pbHelpRefln, NULL, NULL);
    }
  else
    {
      // Transfer certain tProps to m_tReflnProps
      // (Moved out of if-statement below so values are set always.)
	  
      m_tReflnProps.a6fReflnSize[0] = ptProps->a6fReflnSize[0];
      m_tReflnProps.a6fReflnSize[1] = ptProps->a6fReflnSize[1];
      m_tReflnProps.a6fReflnSize[2] = ptProps->a6fReflnSize[2];
      m_tReflnProps.a6fReflnSize[3] = ptProps->a6fReflnSize[3];
      m_tReflnProps.a6fReflnSize[4] = ptProps->a6fReflnSize[4];
      m_tReflnProps.a6fReflnSize[5] = ptProps->a6fReflnSize[5];
      m_tReflnProps.sReflnColor     = ptProps->sReflnColor;
      m_tReflnProps.nReflnPredObs   = ptProps->nReflnPredObs;
      m_tReflnProps.nReflnSymbol    = ptProps->nReflnSymbol;
      
      if (NULL != m_poXdisplay)
	{
	  m_poXdisplay->nSetReflnProps(&m_tReflnProps);
	  if (NULL != m_poXdisplay1)
	    {
	      m_poXdisplay1->nSetReflnProps(&m_tReflnProps);
	    }
	}
    }
}


void
MainWindow::vProgressCBCallback(void *pObj,     // Pointer to object 
				int *pnImg)
{
  MainWindow *obj = (MainWindow *)pObj;
  obj->vProgressCB(pObj, pnImg);
}

void
MainWindow::vProgressCB(void *pObj,             // Pointer to object 
			int *pnImg)
{
  // Update the scale widget to show the progress
  // Check for the event of pressing the Cancel/Abort button in the _mbProgress

  XEvent event;
  Display *dpy = XtDisplay(_mbProgress);
  Window   win = XtWindow(_mbProgress);
  Window  win2 = XtWindow(_daImageBig);

  XmScaleSetValue(_scProgress, *pnImg);
  XFlush(dpy);
  XmUpdateDisplay(_scProgress);

  // Process all queued events, regardless of window and event type

  while (XCheckMaskEvent(dpy, (long)0xffffffff,
			 /* all masks 
			 ButtonPressMask | ButtonReleaseMask | ButtonMotionMask
			 | KeyPressMask | KeyReleaseMask | FocusChangeMask
			 | EnterWindowMask | LeaveWindowMask,
			 */
			 &event))
    {
      //      if ( (event.xany.window == win) || (event.xany.window == win2) )
	XtDispatchEvent(&event);
	//      else
	//	XBell(dpy, 75);
    }

  // Check if abort needs to be passed back to calling routine.
  // An abort is indicated by a change in the passed image number.

  if (0 != m_nProgressCancel)
    {
      *pnImg -= 1;
    }
}

void
MainWindow::vImageFileCBCallback(XtPointer pObj,           // Pointer to object 
				const Cstring& sFilename, // Filename
				const Cstring& sTemplate, // Template
				const int nSeqStart,      // Sequence start
				const int nSeqIncr,       // Sequence increment
				const int nNumImages)     // Number of images
{
  MainWindow *obj = (MainWindow *)pObj;
  obj->vImageFileCB(pObj, sFilename, sTemplate, nSeqStart, nSeqIncr, nNumImages);
}

void
MainWindow::vImageFileCB(XtPointer pObj,           // Pointer to object 
			const Cstring& sFilename, // Filename
			const Cstring& sTemplate, // Template
			const int nSeqStart,      // Sequence start
			const int nSeqIncr,       // Sequence increment
			const int nNumImages)     // Number of images
{
  // This is the callback for the _cUIimagefileSelect object
  // Do different things depending on which pushbutton (specified in m_hFilePB)
  // caused the object to be managed.

  if (NULL == m_poScan)
    {
      // We need a Cscan object to do most things here

      m_poScan = new Cscan ();	  
    }

  if ( (m_hFilePB == _pbFileOpen) || (m_hFilePB == _pbFileNewImage) )
    {
      if ("" != sFilename)
	{
	  vLoadImageFile(sFilename.string());
	  vNewImage();
	}
      else
	{
	  vPostError(_mbError, (XtPointer)"NoFileName$$No file name specified!", NULL);
	}
    }
  else if (m_hFilePB == _pbFileSaveAs)
    {
      if ("" != sFilename)
	{
	  if (NULL != m_poImage)
	    {
	      m_poXcursor->vSetWait();
	      m_poImage->nWrite(sFilename);
	      m_poXcursor->vReset();
	    }
	  else
	    {
	      vPostError(_mbError, (XtPointer)"NoImageAvail$$No image available!", NULL);
	    }
	}
      else
	{
	  vPostError(_mbError, (XtPointer)"NoSaveAsFile$$No file name specified!", NULL);
	}

      // Reset the _tbEditErase toggle button if set, since presumably
      // you have saved the image that was edited.

      m_nEraseMode = 0;
      XmToggleButtonSetState(_tbEditErase, False, True);

      // XmToggleButtonSetState(_tbEditErase, False, False);

    }
  else if (m_hFilePB == _pbFileSaveHeader)
    {
      if ("" != sFilename)
	{
	  if (NULL != m_poHeader)
	    {
	      m_poXcursor->vSetWait();
	      m_poHeader->nWrite(sFilename);
	      m_poXcursor->vReset();
	    }
	  else
	    {
	      vPostError(_mbError, (XtPointer)"NoHeaderAvail$$No header available!", NULL);
	    }
	}
      else
	{
	  vPostError(_mbError, (XtPointer)"NoSaveAsFile$$No file name specified!", NULL);
	}
    }
  else if (m_hFilePB == _pbFileTemplate)
    {
      m_poScan->vSetTemplate( sTemplate);
      m_poScan->vSetSeqStart( nSeqStart); 
      m_poScan->vSetSeqInc(nSeqIncr);
      m_poScan->vSetNumImgs(nNumImages);
      m_poScan->vInitSeqNum();
    }
  else if (m_hFilePB == _pbFileNewTile)
    {
      m_poScan->vSetTemplate( sTemplate);
      m_poScan->vSetSeqStart( nSeqStart); 
      m_poScan->vSetSeqInc(nSeqIncr);
      m_poScan->vSetNumImgs(nNumImages);

      // Turn off display of resolution arcs and reflnlists

      XmToggleButtonSetState(_tbViewObs, False, False);
      XmToggleButtonSetState(_tbViewReso, False, False);
      if (NULL != m_poXdisplay)
	{
	  m_poXdisplay->vSetResol(m_poDetector, m_fS0, m_fWavelength, -1);
	  m_poXdisplay->m_tImageProps.nDisplayReflns = 0;
	  m_poXdisplay->m_poReflnlist = NULL;   // This should be encapsulated!
	}
      if (NULL != m_poXdisplay1)
	{
	  m_poXdisplay1->vSetResol(m_poDetector, m_fS0, m_fWavelength, -1);
	  m_poXdisplay1->m_tImageProps.nDisplayReflns = 0;
	  m_poXdisplay1->m_poReflnlist = NULL;   // This should be encapsulated!
	}
      vTile();
    }
  else if (m_hFilePB == _pbFileNewAverage)
    {
      m_poScan->vSetTemplate( sTemplate);
      m_poScan->vSetSeqStart( nSeqStart); 
      m_poScan->vSetSeqInc(nSeqIncr);
      m_poScan->vSetNumImgs(nNumImages);
      vAverage();
    }
  else if (m_hFilePB == _pbFileNewOverlay)
    {
      m_poScan->vSetTemplate( sTemplate);
      m_poScan->vSetSeqStart( nSeqStart); 
      m_poScan->vSetSeqInc(nSeqIncr);
      m_poScan->vSetNumImgs(nNumImages);
      vOverlay();
    }
  else if (m_hFilePB == _pbFileNewUnderlay)
    {
      m_poScan->vSetTemplate( sTemplate);
      m_poScan->vSetSeqStart( nSeqStart); 
      m_poScan->vSetSeqInc(nSeqIncr);
      m_poScan->vSetNumImgs(nNumImages);
      vUnderlay();
    }
  else if (m_hFilePB == _pbFileNewMovie)
    {
      m_poScan->vSetTemplate( sTemplate);
      m_poScan->vSetSeqStart( nSeqStart); 
      m_poScan->vSetSeqInc(nSeqIncr);
      m_poScan->vSetNumImgs(nNumImages);
      vMovie();
    }

  // Presumably a scan has been specified, so sensitize
  // the Prev, Next and No: widgets

  if ("" != m_poScan->sGetTemplate()) 
    {
      XtSetSensitive(_pbImagePrev, True);
      XtSetSensitive(_pbImageNext, True);
      XtSetSensitive(_tfImageNum,  True);
      XtSetSensitive(_lbImageNum,  True);
    }
  else
    {
      XtSetSensitive(_pbImagePrev, False);
      XtSetSensitive(_pbImageNext, False);
      XtSetSensitive(_tfImageNum,  False);
      XtSetSensitive(_lbImageNum,  False);
    }

  if (NULL != m_poXdisplay)
    {
      m_poXdisplay->nSetReflnProps(&m_tReflnProps);
      if (NULL != m_poXdisplay1)
	{
	  m_poXdisplay1->nSetReflnProps(&m_tReflnProps);
	}
    }
}


void
MainWindow::vPutMessage(const Cstring& sMessage, const int nFlag)
{
  XmTextInsert(_tfOutput, XmTextGetLastPosition(_tfOutput), sMessage.string());
  XmTextShowPosition(_tfOutput, XmTextGetLastPosition(_tfOutput));
  if (0 != nFlag)
    {
      vPostError(_mbError, (XtPointer) sMessage.string(), NULL);
    }
}

void MainWindow::vRubberbandCBCallback (XtPointer pObj, const int nMode,
				const float fPx0, const float fPx1,
				const float fPx2, const float fPx3)

{
    MainWindow *obj = (MainWindow *)pObj;
    obj->vRubberbandCB(pObj, nMode, fPx0, fPx1, fPx2, fPx3);
}
void MainWindow::vRubberbandCB (XtPointer pObj, const int nMode,
				const float fPx0, const float fPx1,
				const float fPx2, const float fPx3)
{
  float fZ;

  // This is called by the CXdisplay class when a rubberband mode is finished.

  XmToggleButtonSetState(_tbCursorRect, False, False);
  XmToggleButtonSetState(_tbCursorBeam, False, False);

  //  XmToggleButtonSetState(_tbCursorMeasure, False, False);
  //  XmToggleButtonSetState(_tbCursorSpot, False, False);

  if ( (NULL != m_poXdisplay) && (NULL != m_poDetector) )
    {
      if ( (RB_LINE_MODE == nMode) || (RB_TLIN_MODE == nMode) )
	{
	  // Line mode
	  sprintf(m_a255cText, "Start pix: %.1f, %.1f\n  End pix: %.1f, %.1f\n",
		  fPx0, fPx1, fPx2, fPx3);
	  vPutMessage(m_a255cText);
	  double a3dDiff[3];

	  if (NULL != m_poDetector)
	    {
	      (void) m_poDetector->m_poSpatial->nPixeltoMM(fPx0, fPx1,
							   &m_fPrevPoint[0], 
							   &m_fPrevPoint[1],
							   &fZ);
	      m_fPrevPoint[2] 
		= m_poDetector->fCalcGetResolution((double)fPx0, (double)fPx1, 
						   m_fS0,
						   &m_dPrevPointX[0])
		  * m_fWavelength;

	      m_dCurrPoint[0] = (double)fPx2;
	      m_dCurrPoint[1] = (double)fPx3;

	      double dDspacing = m_poDetector->fCalcGetResolution(m_dCurrPoint[0], 
								  m_dCurrPoint[1],
								  m_fS0,
								  &m_dCurrPointX[0])
		* (double)m_fWavelength;
	      vSubVec3DVec3D(m_dCurrPointX, m_dPrevPointX, a3dDiff); 
	      dDspacing = fLenVec3D(a3dDiff);
	      if (0.0 != dDspacing)
		dDspacing = ABS(m_fWavelength / dDspacing);
	      else
		dDspacing = 999999.99;
	      sprintf(m_a255cText, 
		      "d-spacing between points:\n"
		      "  1X: %6.1lf A, 2X: %6.1lf A,\n"
                      "  3X: %6.1lf A, 4X: %6.1lf A\n", 
		      dDspacing,
		      dDspacing * 2.0,
		      dDspacing * 3.0,
		      dDspacing * 4.0);
	      vPutMessage(m_a255cText);
	    }
	}
      else if ( (RB_CIRC_MODE == nMode) || (RB_CIR2_MODE == nMode) )
	{
	  // Circle mode

	  float fRadiusPx, fRadiusMM, fZ;
	  float fTemp0, fTemp1;

	  (void) m_poDetector->m_poSpatial->nPixeltoMM(fPx0, fPx1,
						       &fTemp0, &fTemp1,
						       &fZ);
	  m_dPrevPoint[0] = fTemp0;
	  m_dPrevPoint[1] = fTemp1;
	  (void) m_poDetector->m_poSpatial->nPixeltoMM(fPx2, fPx3,
						       &fTemp0, &fTemp1,
						       &fZ);
	  m_dCurrPoint[0] = fTemp0;
	  m_dCurrPoint[1] = fTemp1;

	  fRadiusPx = m_dPrevPoint[0] - m_dCurrPoint[0];
	  fRadiusMM = fRadiusPx * fRadiusPx;
	  fRadiusPx = m_dPrevPoint[1] - m_dCurrPoint[1];
	  fRadiusMM = (float)sqrt((double)(fRadiusMM +  fRadiusPx * fRadiusPx));
	  fRadiusPx = (float)sqrt((double)(  (fPx2 - fPx0) * (fPx2 - fPx0)
			    + (fPx3 - fPx1) * (fPx3 - fPx1)));
	  
	  float fCent0, fCent1;
	  fCent0 = fPx0;
	  fCent1 = fPx1;
	  if (RB_CIR2_MODE == nMode)
	    {
	      fCent0 = fPx2;
	      fCent1 = fPx3;
	    }
	  sprintf(m_a255cText, "Center at: %.1f, %.1f\nPixel radius: %.1f\n"
		  "Mm radius: %.3f\n", fCent0, fCent1, fRadiusPx, fRadiusMM);
	  vPutMessage(m_a255cText);
	  if (RB_CIR2_MODE == nMode)
	    {
	      if ( (NULL != m_poDetector) && (NULL != m_poSource) )
		{
		  // Calculate pixel coordinates when m_fDetSwing is not 0
		  // First, get mm position of current beam center at this swing angle

		  int nStat = 0;
		  float a3fX[3], a3fS0[3], fBeamMM0, fBeamMM1;
		  m_poSource->vCalcGetS0((float*)a3fS0);
		  a3fX[0] = 0.0;
		  a3fX[1] = 0.0;
		  a3fX[2] = 0.0;
		  nStat = m_poDetector->nCalcDetCoords(a3fX, a3fS0,
						       &fBeamMM0, &fBeamMM1, 
						       &fCent0, &fCent1);
		  if (0 == nStat)
		    {
		      float fZ =  0.0;
		      fBeamMM0 = m_dCurrPoint[0] - fBeamMM0;
		      fBeamMM1 = m_dCurrPoint[1] - fBeamMM1;
		      nStat = m_poDetector->m_poSpatial->nMMtoPixel(fBeamMM0, fBeamMM1, fZ,
								    &fCent0, &fCent1);
		    }

		  // Should the following reset detector translations to 0,0,DX?

		  if (0 == nStat)
		    {
		      m_poDetector->m_poSpatial->nSetBeamPosition(fCent0, fCent1);
		      
		      XmToggleButtonSetState(_tbViewReso, True, False);
		      m_poXdisplay->vSetResol(m_poDetector, m_fS0, m_fWavelength, 5);
		      m_poXdisplay->vRefresh();
		      m_poDetector->m_poSpatial->nUpdateHeader(m_poHeader, "");
		      vPutMessage ("Direct beam position changed!\n"
				   "Don't forget File/Save Header ...", 1);
		    }
		  else
		    {
		      vPutMessage ("ERROR changing direct beam position!\n"
				   "Probably cause: beam position not on image!\n", 1);
		    }
		}
	    }
	}
      if (1 == m_nEraseMode)
	{
	  vErasePixels(nMode, fPx0, fPx1, fPx2, fPx3);
	}
    }
}

void 
MainWindow::vErasePixels(const int nMode, 	
			 const float fPx0, const float fPx1,
			 const float fPx2, const float fPx3)
{
  // Erase pixels in the IMAGE which corresponds to the mode
  // and pixels values input

  static float s_fCircRad = 1.0;

  if (NULL != m_poImage)
    {
      float fNewValue = 0.0;
//+2010-03-11 JWP
      // If the image Data_type is long int, make fNewValue -1
      if (   (eImage_I4 == m_poImage->nGetDataType())
          || (eImage_I2 == m_poImage->nGetDataType()) )
        {
          fNewValue = -1.0;
        }
//-2010-03-11 JWP

      if ("" != sGetEnv("DTDISPLAY_ERASE_VALUE"))
	{
	  fNewValue = atof(sGetEnv("DTDISPLAY_ERASE_VALUE").string());
	  if (0.0 > fNewValue)
	    {
	      // Trick: Use the value of the wavelength for the erase value
	      fNewValue = m_fWavelength;
	    }
	  Cstring sDemp;
	  sDemp = "INFO, erase value set to ";
	  sDemp = sDemp + sGetEnv("DTDISPLAY_ERASE_VALUE") + Cstring("\n");
	  vPutMessage (sDemp, 0);
	}


      if ( (RB_TLIN_MODE == nMode) || (RB_LINE_MODE == nMode) )
	{
	  // Equation of line is Ax + By + C = 0
	  // Distance from a point (x', y') to a line is:
	  //    |Ax' + By' + C| / sqrt(A*A + B*B)
	  
	  float fA, fB, fC;
	  
	  int i, j, idir, jdir;
	  
	  if ((int)fPx2 == (int) fPx0)
	    {
	      // Vertical line
	      
	      fA = 1.0;
	      fB = 0.0;
	      fC = -fPx0;
	    }
	  else
	    {
	      // Non-vertical line
	      if ((int)fPx3 == (int) fPx1)
		{
		  fA = 0.0;
		}
	      else
		{
		  fA = (fPx3 - fPx1) / (fPx2 - fPx0);
		}
	      fB = -1.0;
	      fC = fPx1 - (fA * fPx0);
	    }

	  float fDenom = (float)sqrt((double)(fA*fA + fB*fB));
	  float fTestDist;
	  float fDist;
	  idir = 1;
	  if (fPx2 < fPx0) idir = -1;
	  jdir = 1;
	  if (fPx3 < fPx1) jdir = -1;
	  j = (int)(fPx1 - (s_fCircRad * (float)jdir));
//+JWP 2011-03-02
	  float fEraseRad = s_fCircRad / 2.0;
	  fTestDist = max(0.5, fEraseRad);
//-JWP 2011-03-02
	  do 
	    {
	      fDist = fB * (float) j + fC;
	      i =  (int)(fPx0 - (fEraseRad * (float)idir));
	      do
		{
		  if (ABS(fDist + float(i) * fA) / fDenom <= fTestDist)
		    {
		      (void) (m_poImage->*m_poImage->prnSetPixel)(i, j,
								  fNewValue);
		    }
		  i = i + idir;
		} while (i != (int)(fPx2 + (fEraseRad * (float)idir)) + idir);
	      j = j + jdir;
	    } while (j != (int)(fPx3 + (fEraseRad * jdir) + jdir));
	}
      else if (RB_CIRC_MODE == nMode)
	{
	  // Zero out the pixels within the circle

	  int i, j;
	  float fJSq, fISq;
	  float fRadiusPx, fRadSq;
	  fRadSq =   ((fPx2 - fPx0) * (fPx2 - fPx0))
	           + ((fPx3 - fPx1) * (fPx3 - fPx1));
	  fRadiusPx = (float)sqrt((double)fRadSq);

	  s_fCircRad = fRadiusPx;
	  sprintf(m_a255cText, "Line thickness set to %.1f pixels\n", 
		  s_fCircRad);
	  m_fCircleRadius = s_fCircRad;

	  // Pass circle diameter to CXdisplay objects for future use

//+2011-03-02 JWP
	  m_poXdisplay->vSetLineWidth(m_fCircleRadius);
	  m_poXdisplay1->vSetLineWidth(m_fCircleRadius);
//-2011-03-02 JWP
	  vPutMessage(m_a255cText);
	  float fEraseRadiusPx = fRadiusPx;
	  for (j = (int)(fPx1-fEraseRadiusPx-1.); j <= (int)(fPx1+fEraseRadiusPx+1.); j++)
	    {
	      fJSq = (float) j + 0.5 - fPx1;  // Use pix j center: (j+0.5)
	      fJSq = fJSq * fJSq;
	      for (i = (int)(fPx0-fEraseRadiusPx-1.); i <= (int)(fPx0+fEraseRadiusPx+1.); i++)
		{
		  fISq = (float) i + 0.5 - fPx0;  // Use pix i center: (i+0.5)
		  if (fRadSq >= (fJSq + fISq * fISq) )
		    (void) (m_poImage->*m_poImage->prnSetPixel)(i, j, 
								fNewValue);
		}
	    }
	  // Always include the center ...
	  (void) (m_poImage->*m_poImage->prnSetPixel)((int)fPx0, (int)fPx1, 
						      fNewValue);
	}
      else if (RB_POIN_MODE == nMode)
	{
	  (void) (m_poImage->*m_poImage->prnSetPixel)((int)fPx0, (int)fPx1, 
						      fNewValue);
	}
    }
  if (NULL != m_poXdisplay) m_poXdisplay->vRefresh();
  m_poXcursor->vSetFont(XC_gumby, FALSE);
}


void
MainWindow::vReflnFileCBCallback(XtPointer pObj,
				 const Cstring& sFilename,
				 const int nReflnObjIndex)
{
  MainWindow *obj = (MainWindow *)pObj;
  obj->vReflnFileCB(pObj, sFilename, nReflnObjIndex);
}

void
MainWindow::vReflnFileCB(XtPointer pObj,
			 const Cstring& sFilename,
			 const int nReflnObjIndex)
{
  if (1 == m_nReflnFileMode)
    {
      // Write the reflnlist

      if ( (NULL != m_poReflnlist) && (m_poReflnlist->bIsAvailable()))
	{
	  if (0 != m_poReflnlist->nWrite(sFilename))
	    vPutMessage("ERROR writing reflnlist: " + sFilename, 1);
	  else
	    {
	      m_sReflnFilename = sFilename;
	      vPutMessage("Wrote: " + sFilename + '\n');
	    }
	}
      else
	{
	  vPutMessage("Reflnlist unavailable!\n", 1);
	}
    }
  else if (0 == m_nReflnFileMode)
    {
      // Read a new reflnlist

      if (NULL != m_poReflnlist)
	{
	  delete m_poReflnlist;
	  m_poReflnlist = NULL;
	}
  
      m_poXcursor->vSetWait();
      m_poReflnlist = new Creflnlist ((Cstring)sFilename);

      // Sort the reflection list on the nNonunfFlag if it exists because
      // that field will be used to color the reflections.

      if (0 <= m_poReflnlist->m_nFI_nNonunfFlag)
	{
	  m_nFI2 = m_poReflnlist->m_nFI_nNonunfFlag;
	}
      else
	{
	  // Sort on something else guarenteed to be there

	  m_nFI2 = m_poReflnlist->m_nFI_nH;
	}

      if ( m_poReflnlist->bIsAvailable() && (0 < m_poReflnlist->nGetNumReflns()))
	{
	  XtSetSensitive(_pbFileWrite, True);
	  XtSetSensitive(_pbEditDelRef, True);
	  m_poReflnlist->vSort(eReflnField_int_type, m_nFI2, NULL);
  
	  // Setup m_nFI0, m_nFI1 here ... for future use in vDAInputCB
  
	  m_nFI2 = m_poReflnlist->m_nFI_fCalcPx0;
	  m_nFI3 = m_poReflnlist->m_nFI_fCalcPx1;
	  m_nFI5 = m_poReflnlist->m_nFI_fCalcRotMid;
  
	  if (0 < m_poReflnlist->m_nFI_fObsPx0) 
	    m_nFI0 = m_poReflnlist->m_nFI_fObsPx0;
	  else
	    m_nFI0 = m_nFI2;
	  if (0 < m_poReflnlist->m_nFI_fObsPx1) 
	    m_nFI1 = m_poReflnlist->m_nFI_fObsPx1;
	  else
	    m_nFI1 = m_nFI3;
	  if (0 < m_poReflnlist->m_nFI_fObsRotMid)
	    m_nFI4 = m_poReflnlist->m_nFI_fObsRotMid;
	  else
	    m_nFI4 = m_nFI5;
  
	  //if (NULL != w) XtFree(pcFile);
  
	  // Set the View Observed reflection togglebutton to true and plot the list.
  
	  XmToggleButtonSetState(_tbViewObs, True, False);
	  if (sFilename.contains("zone") || sFilename.contains("axial"))
	    {
	      tagReflnProps tProps;
	      // Make sure the reflnlist filter is set so all reflns are
	      // plotted and not just the ones in a particular rotation range.
	      _cUIreflnviewprops->vGetValues(&tProps);
	      tProps.nReflnSymbol = 4;
	      m_tReflnProps.nReflnSymbol = 4;
	      _cUIreflnviewprops->vSetValues(tProps, 
					     sFilename, m_nReflnNum);
	    }
	  vPlotReflnListCB (_tbViewObs, NULL, NULL);
	  m_sReflnFilename = sFilename;

	}
      else
	{
	  // There is something wrong with the reflnlist just read in.  It
	  // could have no reflns.

	  XtSetSensitive(_pbFileWrite, False);
	  XtSetSensitive(_pbEditDelRef, False);
	  vPutMessage("ERROR reading reflnlist: " + sFilename, 1);
	  delete m_poReflnlist;
	  m_poReflnlist = NULL;
	  if (NULL != m_poXdisplay)
	    m_poXdisplay->m_poReflnlist = NULL;
	  if (NULL != m_poXdisplay1)
	    m_poXdisplay->m_poReflnlist = NULL;
	  XmToggleButtonSetState(_tbViewObs, False, False);
	}
      m_poXcursor->vReset();
    }
}
void
MainWindow::vPreStartPublicCB(Widget w, XtPointer clientData, XtPointer callData)
{
  // Public method to set the "Respond to Updates" options
  // This is called from the main-cc routine AFTER the main window is
  // popped up.  If you call it before then, then there really is
  // no mainwindow window id and nothing happens

  bool bListen = FALSE;
  if (XmToggleButtonGetState(_tbFileListenOther))
    {
      vFileListenCB(_tbFileListenOther, NULL, NULL);
      bListen = TRUE;
    }
  if (XmToggleButtonGetState(_tbFileListenCollect))
    {
      vFileListenCB(_tbFileListenCollect, NULL, NULL);
      bListen = TRUE;
    }
  if (XmToggleButtonGetState(_tbFileListenIntegrate))
    {
      vFileListenCB(_tbFileListenIntegrate, NULL, NULL);
      bListen = TRUE;
    }
  if ( (NULL != callData) && ((bool)callData) )
    {
      // Pop-up the file selection dialog to open an image

      XmToggleButtonSetState(_tbEditErase, FALSE, FALSE);
      vFileSelectionPostCB(_pbFileOpen, NULL, NULL);
    }
}
int
MainWindow::nNewHeader(const Cstring sHeaderFile, const bool bReadFiles)
{
  // Update m_poDetector, m_poSource, m_poRotation from file

  int nStat;
  Cimage_header *poHeader = NULL;

  poHeader = new Cimage_header(sHeaderFile);
  if ( (NULL == poHeader) || (!poHeader->bIsAvailable()))
    {
      sprintf(m_a255cText, "Header from file %s unavailable!\n", 
	      sHeaderFile.string());
      vPutMessage(m_a255cText);
      nStat = -1;
    }
  else
    {
      nStat = nNewHeader(*poHeader, bReadFiles);
    }
  if (NULL != poHeader) 
    delete poHeader;
  return (nStat);
}

int
MainWindow::nNewHeader(Cimage_header &roHeader, const bool bReadFiles)
{
  // Get new detector and source properties from the input header.
  // If bReadfiles is TRUE, then read in any nonunf and spatial distortion
  // files.
  // If bReadFiles is FALSE, then do not read in any nonunf and spatial 
  // distortion files.

  int nStat = 0;
  Cstring sTemp;

  if (NULL != m_poHeader)
    delete m_poHeader;

  m_poHeader = new Cimage_header(roHeader);

  // Read detector info from header

  // Get the prefix for the 1st detector, if there isn't one, then
  //  the null string will be returned, which is OK 

  sTemp = "";
  (void) m_poHeader->nGetValue(Cdetector::ms_sDetectorNames, 1, &sTemp);

  if (bReadFiles)
    {
      if (NULL != m_poDetector)
	delete m_poDetector;
      m_poDetector = new Cdetector(*m_poHeader, sTemp);
    }
  else
    {
      // Update the detector position from the header, but DO NOT read
      // in again any spatial distortion or nonunf files (use the ones we
      // already have).

      if (NULL == m_poDetector)
	{
	  vPutMessage("WARNING detector position update requested\n"
                      "        with no previous position available!\n"
                      "   Possible cause: no image is displayed.", 1);
	  m_poDetector = new Cdetector(*m_poHeader, sTemp);
	}
      m_poDetector->nUpdateFromHeader(*m_poHeader, sTemp, FALSE, FALSE);
    }

  if (NULL != m_poImage)
    {
      if ("" == sTemp)
	sTemp = D_K_DetectorPrefix;
      m_poImage->m_oHeader.nCopyMask(roHeader, Cstring(sTemp) + "*");
    }

  // Read source info from header

  if (NULL != m_poSource)
    delete m_poSource;
  m_poSource = new Csource(*m_poHeader);
  if (m_poSource->bIsAvailable())
    {
      m_poSource->vCalcGetS0(&m_fS0[0]);
      m_fWavelength = m_poSource->m_poWavelength->fGetWavelength(0);
      if (NULL != m_poImage)
	{
	  m_poImage->m_oHeader.nCopyMask(roHeader, 
					 Cstring(D_K_SourcePrefix) + "*");
	}
    }

  // Get min and max resolution on the detector.  This forces a
  // call to the detector vCalcGetDDDN routine which will be needed later.

  float fResMin, fResMax, fResMaxEdge;
  m_poDetector->nGetResolution(m_fS0, &fResMin, &fResMax, &fResMaxEdge);
  m_fDetDist   = m_poDetector->m_poGoniometer->fGetDistance();
  m_fDetSwing  = m_poDetector->m_poGoniometer->fGetSwing();

  if (NULL != m_poXdisplay)
    {
      if (XmToggleButtonGetState(_tbViewReso))
	{
	  m_poXdisplay->vSetResol(m_poDetector, m_fS0, m_fWavelength, 5);
	  vDrawResoCB(_tbViewReso, NULL, NULL);
	}
      else
	m_poXdisplay->vSetResol(m_poDetector, m_fS0, m_fWavelength, -1);
    }

  if (NULL != m_poImage)
    {
      m_poImage->m_oHeader.nCopyMask(roHeader, 
				     Cstring(D_K_CrystalPrefix) + "*");
    }

  // Update the info in the panel on the left

  vUpdateText();
  
  return (nStat);
}
void
MainWindow::vSetLabel(Widget w, char *pcNewText, char *pcNewColor)
{
  // Change the label of the widget label input as w to the
  // text specified in pcNewText

  static Arg  arg[1];                         // Make static so no malloc, free
  static Boolean  argok;                      // 
  if (NULL != pcNewText)
    {
      XmString xsString;
      xsString =  (XmString)BX_CONVERT(w, pcNewText, XmRXmString, 0, &argok);
      XtSetArg(arg[0], XmNlabelString, xsString);
      if (argok) 
	XtSetValues(w, arg, 1);
      XmStringFree(xsString);
    }

  if (NULL != pcNewColor)
    {
      Pixel hBackground;
      if ('?' == *pcNewColor)   // Flag to set to background of parent
	{
	  XtVaGetValues(XtParent(w), XmNbackground, &hBackground, NULL);
	  argok = TRUE;
	}
      else
	{
	  hBackground = (Pixel) BX_CONVERT(w, pcNewColor, XmRPixel, 0, &argok);
	}
      if (argok)
	{
#if (XmVersion >= 1002)
	  XmChangeColor(w, hBackground);
#else
	  XtVaSetValues(w, XmNbackground, hBackground, NULL);
#endif
	}
    }
}
//+JWP 2012-09-27
void
MainWindow::vMakeTitleStringFitWindow(Widget w, Cstring sTitleIn, Cstring *psTitleOut)
{
  // How this might work:
  // 1. Figure out number of pixels available by the width of the widget w.
  // 2. Figure out number characters in the title string.  
  // 3. Allow something like 10 pixels per character.
  // 4. Trim from beginning or middle to reduce the number of characters
  //    in the title string and replace with ... characters
  //  ...
  // 6. What about memory leaks?

  // It would be nice if this was called from the CXdisplay::vRefresh() method which
  // is called whenever the window is resized.
  // Right now, if the window is resized, the window manager adjusts the title string.  Not until
  // a new image is opened does this method get called and the title string is trimmed and adjusted.

  int nWidth = 0;
  int nLength = sTitleIn.length();

  //cout << "String: >>" << sTitleIn << "<<\n" << flush;
  //cout << "Length: " << nLength << "\n";
  XtVaGetValues(_MainWindow, XmNwidth, &nWidth, NULL);
  //XtVaGetValues(w, XmNwidth, &nWidth, NULL);
  //cout << "Width: " << nWidth << "\n";

  // So allowed number of characters is nWidth / 10, but also have some minimum number of chars 
  // such as 10.
  int nAllowNumChars = max(10, nWidth / 10);
  static Cstring sTemp;
  *psTitleOut = sTitleIn;

  // Now try to make things fit.  Try to keep right-most characters.
  // But maybe try to keep at least 5 of the first characters of the file path, too.

  if (nLength > nAllowNumChars-3)
    {
      // Trimming needed
      *psTitleOut = "..." + sTitleIn.right(nAllowNumChars-3);

      // If we lost the "ilename:", then do something in additional

      if (-1 == sTemp.find(':'))
	{
	  // What should the additional be?  Maybe start with first slash a few chars to final slash?
	  //cout << "Lost : character\n";
	}
      else
	{
	  // Still have the :, but maybe we should get rid of it?
	  if (-1 == psTitleOut->find("filename: "))
	    {
	      // Do NOT have entire string, so get rid of it:
	      *psTitleOut = psTitleOut->after(": ");
	    }
	}
    }
  return;
}
//-JWP 2012-09-27
// End user code block <tail>
