/*
 *
 * Copyright (C) 2014 Rigaku Americas Corporation
 *                    9009 New Trails Drive
 *                    The Woodlands, TX, USA  77381
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *    * Redistributions of source code must retain the above copyright
 *      notice(s), this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above copyright
 *      notice(s), this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 *    * Neither the name of the Rigaku Americas Corporation nor the
 *      names of its contributors may be used to endorse or promote products
 *      derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL RIGAKU AMERICAS CORPORATION BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA OR PROFITS; OR BUSINESS INTERUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
 * DAMAGE.
 *
 */
//
// README: Portions of this file are merged at file generation
// time. Edits can be made *only* in between specified code blocks, look
// for keywords <Begin user code> and <End user code>.
//
/////////////////////////////////////////////////////////////
//
// Source file for CUIwavelength
//
//    Created by Builder Xcessory Version 5.0.
//    Generated by Code Generator Xcessory 5.0 (05/22/98) .
//
//    This class is a user interface "component", as described
//    in "Object-Oriented Programming with C++ and OSF/Motif",
//    by Douglas Young, Prentice Hall, 1992. ISBN 0-13-630252-1
//
/////////////////////////////////////////////////////////////


// Begin user code block <file_comments>
// End user code block <file_comments>

#include <X11/StringDefs.h>
#include <Xm/SelectioB.h>
#include <Xm/Form.h>
#include <Xm/Label.h>
#include <Xm/RowColumn.h>
#include <Xm/ToggleB.h>
#include "CUIwavelength.h"

//
// Convenience functions from utilities file.
//
extern void RegisterBxConverters(XtAppContext);
extern XtPointer BX_CONVERT(Widget, char *, char *, int, Boolean *);
extern XtPointer BX_DOUBLE(double);
extern XtPointer BX_SINGLE(float);
extern void BX_MENU_POST(Widget, XtPointer, XEvent *, Boolean *);
extern Pixmap XPM_PIXMAP(Widget, char **);
extern void BX_SET_BACKGROUND_COLOR(Widget, ArgList, Cardinal *, Pixel);


// Begin user code block <head>

#include <ctype.h>

// Initialize some static variables

int CUIwavelength::snOptimizeNo     = 0;
int CUIwavelength::snOptimizeYes    = 1;
int CUIwavelength::snOptionAbs      = 0;
int CUIwavelength::snOptionPeak     = 1;
int CUIwavelength::snOptionInflRise = 2;
int CUIwavelength::snOptionInflFall = 3;

char CUIwavelength::ms_a4cWavOption[]   = { 'A', 'P', '+', '-' };
char CUIwavelength::ms_a2cWavOptimize[] = { 'N', 'Y' };
// End user code block <head>

//
// This table is used to define class resources that are placed
// in app-defaults. This table is necessary so each instance
// of this class has the proper default resource values set.
// This eliminates the need for each instance to have
// its own app-defaults values. This table must be NULL terminated.
//
#if defined(cxx_bx_compat)

Boolean CUIwavelength::_initAppDefaults = True;
UIAppDefault  CUIwavelength::_appDefaults[] = {
    {"", NULL, "dialogTitle", NULL},
    {"", NULL, "listItemCount", NULL},
    {"", NULL, "listItems", NULL},
    {"", NULL, "selectionLabelString", NULL},
    {"", NULL, "listLabelString", NULL},
    {"form", NULL, "sensitive", NULL},
    {"lbOptimize", NULL, "sensitive", NULL},
    {"lbOptimize", NULL, "labelString", NULL},
    {"lbOption", NULL, "sensitive", NULL},
    {"lbOption", NULL, "labelString", NULL},
    {"rbOptimize", NULL, "sensitive", NULL},
    {"tbOptimizeNo", NULL, "sensitive", NULL},
    {"tbOptimizeNo", NULL, "set", NULL},
    {"tbOptimizeNo", NULL, "labelString", NULL},
    {"tbOptimizeYes", NULL, "sensitive", NULL},
    {"tbOptimizeYes", NULL, "set", NULL},
    {"tbOptimizeYes", NULL, "labelString", NULL},
    {"rbOption", NULL, "sensitive", NULL},
    {"tbOptionAbs", NULL, "sensitive", NULL},
    {"tbOptionAbs", NULL, "set", NULL},
    {"tbOptionAbs", NULL, "labelString", NULL},
    {"tbOptionPeak", NULL, "sensitive", NULL},
    {"tbOptionPeak", NULL, "set", NULL},
    {"tbOptionPeak", NULL, "labelString", NULL},
    {"tbOptionInflRise", NULL, "sensitive", NULL},
    {"tbOptionInflRise", NULL, "set", NULL},
    {"tbOptionInflRise", NULL, "labelString", NULL},
    {"tbOptionInflFall", NULL, "sensitive", NULL},
    {"tbOptionInflFall", NULL, "set", NULL},
    {"tbOptionInflFall", NULL, "labelString", NULL},
    {NULL, NULL, NULL, NULL}
};
#endif

// These are default resources for widgets in objects of this class
// All resources will be prepended by *<name> at instantiation,
// where <name> is the name of the specific instance, as well as the
// name of the baseWidget. These are only defaults, and may be overriden
// in a resource file by providing a more specific resource name

String  CUIwavelength::_defaultCUIwavelengthResources[] = {
        NULL
};

//
// Old style constructor, for compatibility only.
//
CUIwavelength::CUIwavelength(const char *name, Widget parent) : 
    UIComponent(name)

// Begin user code block <alt_superclass>
// End user code block <alt_superclass>
{
    
    // Begin user code block <alt_constructor>
    // End user code block <alt_constructor>
    create(parent);
}

//
// Class Constructor.
//
CUIwavelength::CUIwavelength(const char *name) : UIComponent(name)

// Begin user code block <superclass>
// End user code block <superclass>
{
    
    // Begin user code block <constructor>
  m_prvOKCallback = NULL;
  m_pObj          = NULL;
    // End user code block <constructor>
}


//
// Minimal Destructor. Base class destroys widgets.
//
CUIwavelength::~CUIwavelength() 
{
    
    // Begin user code block <destructor>

  if (m_poXhelp != NULL)
    {
      delete m_poXhelp;
      m_poXhelp = NULL;
    }

    // End user code block <destructor>
    delete []  _clientDataStructs;
}

//
// Handle creation of all widgets in the class.
//
void CUIwavelength::create(Widget parent) 
{
    Cardinal ac = 0;
    Arg      args[256];
    Cardinal cdc = 0;
    Boolean  argok = False;
    
    _clientDataStructs = new UICallbackStruct[2];
    
    //
    // Load any class-defaulted resources for this object.
    //
    setDefaultResources(parent, _defaultCUIwavelengthResources);
    
#if defined(cxx_bx_compat)
    //
    // Setup app-defaults fallback table if not already done.
    //
    if (_initAppDefaults)
    {
        initAppDefaults(parent, "CUIwavelength", _appDefaults);
        _initAppDefaults = False;
    }
    //
    // Now set the app-defaults for this instance.
    //
    setAppDefaults(parent, _appDefaults, _name, False);
#endif
    
    //
    // Register the converters for the widgets.
    //
    RegisterBxConverters(XtWidgetToApplicationContext(parent));
    XtInitializeWidgetClass((WidgetClass)xmSelectionBoxWidgetClass);
    XtInitializeWidgetClass((WidgetClass)xmFormWidgetClass);
    XtInitializeWidgetClass((WidgetClass)xmLabelWidgetClass);
    XtInitializeWidgetClass((WidgetClass)xmRowColumnWidgetClass);
    XtInitializeWidgetClass((WidgetClass)xmToggleButtonWidgetClass);
    
    //
    // Create an unmanaged widget as the top of the hierarchy.
    //
    
    ac = 0;
    XtSetArg(args[ac], XmNautoUnmanage, True); ac++;
    XtSetArg(args[ac], XmNx, 97); ac++;
    XtSetArg(args[ac], XmNy, 283); ac++;
    XtSetArg(args[ac], XmNwidth, 647); ac++;
    XtSetArg(args[ac], XmNheight, 457); ac++;
    _CUIwavelength = XmCreateSelectionBox(parent,
        _name,
        args, 
        ac);
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_CUIwavelength,
        XmNokCallback,
        CUIwavelength::vWavelengthCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    _clientDataStructs[cdc].object = this;
    _clientDataStructs[cdc].client_data = (XtPointer)0;
    XtAddCallback(_CUIwavelength,
        XmNapplyCallback,
        CUIwavelength::vWavelengthCBCallback,
        (XtPointer)&_clientDataStructs[cdc]);
    cdc++;
    
    _w = _CUIwavelength;
    //
    // Add a callback to guard against widget destruction..
    //
    installDestroyHandler();
    
    ac = 0;
    XtSetArg(args[ac], XmNresizePolicy, XmRESIZE_GROW); ac++;
    XtSetArg(args[ac], XmNx, 11); ac++;
    XtSetArg(args[ac], XmNy, 207); ac++;
    XtSetArg(args[ac], XmNwidth, 625); ac++;
    XtSetArg(args[ac], XmNheight, 102); ac++;
    _form = XmCreateForm(_CUIwavelength,
        "form",
        args, 
        ac);
    XtManageChild(_form);
    
    ac = 0;
    XtSetArg(args[ac], XmNalignment, XmALIGNMENT_END); ac++;
    XtSetArg(args[ac], XmNtraversalOn, False); ac++;
    XtSetArg(args[ac], XmNx, 0); ac++;
    XtSetArg(args[ac], XmNy, 67); ac++;
    XtSetArg(args[ac], XmNwidth, 124); ac++;
    XtSetArg(args[ac], XmNheight, 28); ac++;
    _lbOptimize = XmCreateLabel(_form,
        "lbOptimize",
        args, 
        ac);
    XtManageChild(_lbOptimize);
    
    ac = 0;
    XtSetArg(args[ac], XmNalignment, XmALIGNMENT_END); ac++;
    XtSetArg(args[ac], XmNtraversalOn, False); ac++;
    XtSetArg(args[ac], XmNx, 0); ac++;
    XtSetArg(args[ac], XmNy, 0); ac++;
    XtSetArg(args[ac], XmNwidth, 124); ac++;
    XtSetArg(args[ac], XmNheight, 28); ac++;
    _lbOption = XmCreateLabel(_form,
        "lbOption",
        args, 
        ac);
    XtManageChild(_lbOption);
    
    ac = 0;
    XtSetArg(args[ac], XmNorientation, XmHORIZONTAL); ac++;
    XtSetArg(args[ac], XmNx, 150); ac++;
    XtSetArg(args[ac], XmNy, 67); ac++;
    XtSetArg(args[ac], XmNwidth, 139); ac++;
    XtSetArg(args[ac], XmNheight, 35); ac++;
    XtSetArg(args[ac], XmNisHomogeneous, False); ac++;
    _rbOptimize = XmCreateRadioBox(_form,
        "rbOptimize",
        args, 
        ac);
    XtManageChild(_rbOptimize);
    
    ac = 0;
    XtSetArg(args[ac], XmNwidth, 65); ac++;
    XtSetArg(args[ac], XmNheight, 29); ac++;
    _tbOptimizeNo = XmCreateToggleButton(_rbOptimize,
        "tbOptimizeNo",
        args, 
        ac);
    XtManageChild(_tbOptimizeNo);
    
    ac = 0;
    XtSetArg(args[ac], XmNwidth, 65); ac++;
    XtSetArg(args[ac], XmNheight, 29); ac++;
    _tbOptimizeYes = XmCreateToggleButton(_rbOptimize,
        "tbOptimizeYes",
        args, 
        ac);
    XtManageChild(_tbOptimizeYes);
    
    ac = 0;
    XtSetArg(args[ac], XmNnumColumns, 2); ac++;
    XtSetArg(args[ac], XmNpacking, XmPACK_COLUMN); ac++;
    XtSetArg(args[ac], XmNspacing, 3); ac++;
    XtSetArg(args[ac], XmNorientation, XmHORIZONTAL); ac++;
    XtSetArg(args[ac], XmNx, 150); ac++;
    XtSetArg(args[ac], XmNy, 0); ac++;
    XtSetArg(args[ac], XmNwidth, 475); ac++;
    XtSetArg(args[ac], XmNheight, 67); ac++;
    XtSetArg(args[ac], XmNisHomogeneous, False); ac++;
    _rbOption = XmCreateRadioBox(_form,
        "rbOption",
        args, 
        ac);
    XtManageChild(_rbOption);
    
    ac = 0;
    XtSetArg(args[ac], XmNwidth, 209); ac++;
    XtSetArg(args[ac], XmNheight, 29); ac++;
    _tbOptionAbs = XmCreateToggleButton(_rbOption,
        "tbOptionAbs",
        args, 
        ac);
    XtManageChild(_tbOptionAbs);
    
    ac = 0;
    XtSetArg(args[ac], XmNwidth, 209); ac++;
    XtSetArg(args[ac], XmNheight, 29); ac++;
    _tbOptionPeak = XmCreateToggleButton(_rbOption,
        "tbOptionPeak",
        args, 
        ac);
    XtManageChild(_tbOptionPeak);
    
    ac = 0;
    XtSetArg(args[ac], XmNwidth, 209); ac++;
    XtSetArg(args[ac], XmNheight, 29); ac++;
    _tbOptionInflRise = XmCreateToggleButton(_rbOption,
        "tbOptionInflRise",
        args, 
        ac);
    XtManageChild(_tbOptionInflRise);
    
    ac = 0;
    XtSetArg(args[ac], XmNwidth, 209); ac++;
    XtSetArg(args[ac], XmNheight, 29); ac++;
    _tbOptionInflFall = XmCreateToggleButton(_rbOption,
        "tbOptionInflFall",
        args, 
        ac);
    XtManageChild(_tbOptionInflFall);
    ac = 0;
    XtSetArg(args[ac], XmNtopAttachment, XmATTACH_WIDGET); ac++;
    XtSetArg(args[ac], XmNleftAttachment, XmATTACH_FORM); ac++;
    XtSetArg(args[ac], XmNbottomAttachment, XmATTACH_NONE); ac++;
    XtSetArg(args[ac], XmNbottomOffset, 0); ac++;
    XtSetArg(args[ac], XmNleftOffset, 0); ac++;
    XtSetArg(args[ac], XmNtopOffset, 0); ac++;
    XtSetArg(args[ac], XmNtopWidget, _rbOption); ac++;
    XtSetValues(_lbOptimize, args, ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNtopAttachment, XmATTACH_OPPOSITE_WIDGET); ac++;
    XtSetArg(args[ac], XmNrightAttachment, XmATTACH_NONE); ac++;
    XtSetArg(args[ac], XmNleftAttachment, XmATTACH_WIDGET); ac++;
    XtSetArg(args[ac], XmNbottomAttachment, XmATTACH_NONE); ac++;
    XtSetArg(args[ac], XmNbottomOffset, 0); ac++;
    XtSetArg(args[ac], XmNleftOffset, 26); ac++;
    XtSetArg(args[ac], XmNrightOffset, 0); ac++;
    XtSetArg(args[ac], XmNtopOffset, 0); ac++;
    XtSetArg(args[ac], XmNleftWidget, _lbOptimize); ac++;
    XtSetArg(args[ac], XmNtopWidget, _lbOptimize); ac++;
    XtSetValues(_rbOptimize, args, ac);
    
    ac = 0;
    XtSetArg(args[ac], XmNrightAttachment, XmATTACH_FORM); ac++;
    XtSetArg(args[ac], XmNleftAttachment, XmATTACH_FORM); ac++;
    XtSetArg(args[ac], XmNleftOffset, 150); ac++;
    XtSetArg(args[ac], XmNrightOffset, 0); ac++;
    XtSetArg(args[ac], XmNtopOffset, 0); ac++;
    XtSetValues(_rbOption, args, ac);
    
    
    // Begin user code block <endcreate>

    // Create the help object and add the help callback

    m_poXhelp     = new CXhelp (_w);

    _clientDataStructs = new UICallbackStruct;
    _clientDataStructs->object = (UIComponent *)m_poXhelp;
    _clientDataStructs->client_data = (XtPointer) "Wavelength$$"; // "DefaultFileName.html"
    XtAddCallback(_CUIwavelength,
        XmNhelpCallback,
        CXhelp::vHTMLHelpCallback,
        (XtPointer)_clientDataStructs);

    _clientDataStructs = new UICallbackStruct;
    _clientDataStructs->object = (UIComponent *)m_poXhelp;
    _clientDataStructs->client_data = (XtPointer)"Use chosen wavelength absolutely";
    XtAddCallback(_tbOptionAbs,
		  XmNarmCallback,
		  CXhelp::vPostOneLineCBCallback,
		  (XtPointer)_clientDataStructs);
    XtAddCallback(_tbOptionAbs,
		  XmNdisarmCallback,
		  CXhelp::vUnpostOneLineCBCallback,
		  (XtPointer)_clientDataStructs);


    _clientDataStructs = new UICallbackStruct;
    _clientDataStructs->object = (UIComponent *)m_poXhelp;
    _clientDataStructs->client_data = (XtPointer)"Choose wavelength of nearby peak intensity";
    XtAddCallback(_tbOptionPeak,
		  XmNarmCallback,
		  CXhelp::vPostOneLineCBCallback,
		  (XtPointer)_clientDataStructs);
    XtAddCallback(_tbOptionPeak,
		  XmNdisarmCallback,
		  CXhelp::vUnpostOneLineCBCallback,
		  (XtPointer)_clientDataStructs);

    _clientDataStructs = new UICallbackStruct;
    _clientDataStructs->object = (UIComponent *)m_poXhelp;
    _clientDataStructs->client_data = (XtPointer)"Choose wavelength at nearby inflection point";

    XtAddCallback(_tbOptionInflRise,
		  XmNarmCallback,
		  CXhelp::vPostOneLineCBCallback,
		  (XtPointer)_clientDataStructs);
    XtAddCallback(_tbOptionInflRise,
		  XmNdisarmCallback,
		  CXhelp::vUnpostOneLineCBCallback,
		  (XtPointer)_clientDataStructs);

    XtAddCallback(_tbOptionInflFall,
		  XmNarmCallback,
		  CXhelp::vPostOneLineCBCallback,
		  (XtPointer)_clientDataStructs);
    XtAddCallback(_tbOptionInflFall,
		  XmNdisarmCallback,
		  CXhelp::vUnpostOneLineCBCallback,
		  (XtPointer)_clientDataStructs);

    _clientDataStructs = new UICallbackStruct;
    _clientDataStructs->object = (UIComponent *)m_poXhelp;
    _clientDataStructs->client_data = (XtPointer)"Do NOT optimize beamline after reaching wavelength";
    XtAddCallback(_tbOptimizeNo,
		  XmNarmCallback,
		  CXhelp::vPostOneLineCBCallback,
		  (XtPointer)_clientDataStructs);
    XtAddCallback(_tbOptimizeNo,
		  XmNdisarmCallback,
		  CXhelp::vUnpostOneLineCBCallback,
		  (XtPointer)_clientDataStructs);

    _clientDataStructs = new UICallbackStruct;
    _clientDataStructs->object = (UIComponent *)m_poXhelp;
    _clientDataStructs->client_data = (XtPointer)"Do OPTIMIZE beamline after reaching wavelength";
    XtAddCallback(_tbOptimizeYes,
		  XmNarmCallback,
		  CXhelp::vPostOneLineCBCallback,
		  (XtPointer)_clientDataStructs);
    XtAddCallback(_tbOptimizeYes,
		  XmNdisarmCallback,
		  CXhelp::vUnpostOneLineCBCallback,
		  (XtPointer)_clientDataStructs);


    // The wavelength selectionBox list item is a bit bogus.
    // It has a single item specified by the resource file.
    // Get this item and parse it into multiple items

    XmString *ptItems;
    char *pcText;
    char cSep = ':';
    XtVaGetValues(_CUIwavelength, XmNlistItems, &ptItems, NULL);
    if (ptItems !=NULL)
      {
	// There are some items to parse
	if (XmStringGetLtoR(*ptItems, 
#if (XmVersion >= 1002)
			    XmFONTLIST_DEFAULT_TAG,
#else
			    XmSTRING_DEFAULT_CHARSET,
#endif
			    &pcText))
	  {
	    Cstring sTemp = pcText;
	    // Count number of newlines in sTemp
	    int nLines = 1;
	    int nAt = sTemp.find(cSep, 0);
	    while (nAt >= 0)
	      {
		nLines++;
		nAt=sTemp.find(cSep, nAt+1);
	      }
	    XmString *ptTemp;
	    ptTemp = (XmString *)XtMalloc(nLines * sizeof(XmString));
	    Boolean argok;
	    nAt    = 0;
	    nLines = 0;
	    Cstring sTemp2;
	    while (sTemp.index(cSep)>=0)
	      {
		sTemp2 = sTemp.before(cSep);
		ptTemp[nLines] = (XmString) BX_CONVERT(_CUIwavelength,
						    sTemp2.string(),
						    XmRXmString, 0, &argok);
		sTemp = sTemp.after(cSep);
		nLines++;
	      }
	    ptTemp[nLines] = (XmString) BX_CONVERT(_CUIwavelength,
						sTemp.string(),
						XmRXmString, 0, &argok);
	    nLines++;
	    XtVaSetValues(_CUIwavelength,
			  XmNlistItemCount, nLines,
			  XmNlistItems, ptTemp,
			  NULL);
	    for (ac = 0; ac < nLines; ac++)
	      {
		XmStringFree(ptTemp[ac]);
	      }
	    XtFree((char*)ptTemp);
	  }
	XtFree(pcText);
      }
    // End user code block <endcreate>
}

//
// Classname access.
//
const char *const CUIwavelength::className()
{
    return ("CUIwavelength");
}

void CUIwavelength::vWavelengthCBCallback(Widget w, 
    XtPointer clientData, XtPointer callData)
{
    UICallbackStruct *data = (UICallbackStruct *) clientData;
    CUIwavelength *obj = (CUIwavelength *)data->object;
    obj->vWavelengthCB(w, (XtPointer) data->client_data, callData);
}

void CUIwavelength::vWavelengthCB(Widget w, XtPointer clientData, XtPointer callData)
{
    
    // Begin user code block <vWavelengthCB>

  XmSelectionBoxCallbackStruct *pCBS = (XmSelectionBoxCallbackStruct *)callData;
  if ( ( (pCBS->reason == XmCR_OK) || (pCBS->reason == XmCR_APPLY) )
       && (m_prvOKCallback != NULL))
    {
      // Call callback if reason is OK or Apply

      float fWave;
      int   nOption, nOptimize;
      vGetValues(&fWave, &nOption, &nOptimize);
      m_prvOKCallback(m_pObj, fWave, nOption, nOptimize);
    }

    // End user code block <vWavelengthCB>
}

// Begin user code block <tail>
void 
CUIwavelength::vSetValues(const float fValue, const int nOption, 
			  const int nOptimize)
{
  // Place the input wavelength value into the selection text widget

  char a20cTemp[20];
  sprintf(a20cTemp, "%.5f", fValue);
  XmString sxTemp;
#if (XmVersion >= 1002)
  sxTemp = XmStringCreateLocalized(a20cTemp);
#else
  sxTemp = XmStringCreateSimple(a20cTemp);
#endif
  XtVaSetValues(_CUIwavelength, XmNtextString, sxTemp, NULL);
  XmStringFree(sxTemp);

  Widget w;
  w  = _tbOptionAbs;       // Default 
  if (nOption == snOptionPeak)
    w  = _tbOptionPeak;
  else if (nOption == snOptionInflRise)
    w  = _tbOptionInflRise;
  else if (nOption == snOptionInflFall)
    w  = _tbOptionInflFall;
  XmToggleButtonSetState(w, True, True);
  w  = _tbOptimizeNo;       // Default 
  if (nOptimize == snOptimizeYes)
    w  = _tbOptimizeYes;
  XmToggleButtonSetState(w, True, True);
}
void 
CUIwavelength::vSetValues(const char *pcString)
{
  // Parse pcString for wavelength, option and optimize modes

  if (NULL == pcString)
    return;

  int nStat;
  double dWave;
  int nOption, nOptimize;
  vParseValues(pcString, &dWave, &nOption, &nOptimize, NULL);
  vSetValues((float)dWave, nOption, nOptimize);
}

void
CUIwavelength::vGetValues(float *pfWave, int *pnOption, int *pnOptimize)
{
  float    fTemp;
  char    *pcTemp = NULL;
  XmString sxTemp;

  *pfWave = -1.0;          // Assume the worst

  XtVaGetValues(_CUIwavelength, XmNtextString, &sxTemp, NULL);
  if (XmStringGetLtoR(sxTemp,
#if (XmVersion >= 1002)
		      XmFONTLIST_DEFAULT_TAG,
#else
                      XmSTRING_DEFAULT_CHARSET,
#endif
		      &pcTemp))
    {
      if (pcTemp != NULL)
	{
	  int nStat = sscanf(pcTemp, "%f", &fTemp);
	  XtFree(pcTemp);
	  if (nStat == 1)
	    {
	      *pfWave = fTemp;
	    }
	}
    }
  *pnOption = snOptionAbs;                           // Default is ABSOLUTE
  if (XmToggleButtonGetState(_tbOptionInflRise))
    *pnOption = snOptionInflRise;
  else if (XmToggleButtonGetState(_tbOptionInflFall))
    *pnOption = snOptionInflFall;
  else if (XmToggleButtonGetState(_tbOptionPeak))
    *pnOption = snOptionPeak;

  *pnOptimize = snOptimizeNo;                         // Default is NO
  if (XmToggleButtonGetState(_tbOptimizeYes))
    *pnOptimize = snOptimizeYes;
}

void
CUIwavelength::vParseValues(const char *pcString, double *pdWavel,
			    int *pnOption, int *pnOptimize, char *pcResult)
{
  // Parse a wavelength string and return 

  int nStat;

  char cOption, cOptimize;
  nStat = sscanf(pcString, "%lf %c%c", pdWavel, &cOption, &cOptimize);
  *pnOption   = 0;
  *pnOptimize = 0;
  cOption   = (char)toupper( (int) cOption  );
  cOptimize = (char)toupper( (int) cOptimize);

  if (1 < nStat)
    {
      if (cOption == ms_a4cWavOption[1])
	*pnOption = 1;
      else if (cOption == ms_a4cWavOption[2])
	*pnOption = 2;
      else if (cOption == ms_a4cWavOption[3])
	*pnOption = 3;
      else
	cOption = ms_a4cWavOption[0];
    }
  else
    cOption = ms_a4cWavOption[0];

  if (2 < nStat)
    {
      if (cOptimize == ms_a2cWavOptimize[1])
	*pnOptimize = 1;
      else 
	cOptimize = ms_a2cWavOptimize[0];
    }
  else
    cOptimize = ms_a2cWavOptimize[0];

  if (NULL != pcResult)
    {
      if (100.0 < *pdWavel)
	sprintf(pcResult, "%.0lf %c%c", *pdWavel, cOption, cOptimize);
      else
	sprintf(pcResult, "%.5lf %c%c", *pdWavel, cOption, cOptimize);
    }
}

// End user code block <tail>
